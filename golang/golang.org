* 系统中安装设置go
** windows
https://golang.google.cn/
将go的安装目录go\bin添加的path中
设置GOPATH:go下载扩展包的存放位置
设置环境变量
GO111MODULE=on
设置代理
GOPROXY=https://mirrors.aliyun.com/goproxy/
** linux
+ 安装
  yay -S go
+ 设置变量
  .bashrc
  export GOROOT=/usr/lib/go
  export GOPATH=/store/go_mod
  export GO111MODULE=on
  export GOPROXY=https://mirrors.aliyun.com/goproxy/
                 https://goproxy.io
                 https://goproxy.cn
  export PATH="$GOROOT/bin:$GOBIN:$HOME/.local/bin:$HOME/.pyenv/shims:$PATH"
** 查看信息
go version	#查看Go的版本
go env		#查看Go的环境变量
** 安装其他工具
#+BEGIN_SRC shell
#安装lsp-mode后端
go get golang.org/x/tools/gopls@latest 或 GO111MODULE=on go get golang.org/x/tools/gopls@latest 
#+END_SRC
** 项目初始化
+ go mod init 项目名称(一般与根目录相同)
+ 编辑go.mod添加需要的模块
  require github.com/gin-gonic/gin v1.6.2
+ 在go.mod所在目录执行下载模块
  go mod download
* 编辑器设置
** vscode
+ 安装Go扩展
  Go 0.13.1
+ 安装Go语言开发工具包
  - 相关工具
    gocode
    gopkgs
    go-outline
    go-symbols
    guru
    gorename
    gotests
    gomodifytags
    impl
    fillstruct
    goplay
    godoctor
    dlv
    gocode-gomod
    godef
    goreturns
    golint
    gopls
    github.com/mdempsky/gocode 
    github.com/uudashr/gopkgs/v2/cmd/gopkgs
    github.com/ramya-rao-a/go-outline 
    github.com/acroca/go-symbols 
    golang.org/x/tools/cmd/guru 
    golang.org/x/tools/cmd/gorename 
    github.com/cweill/gotests/... 
    github.com/fatih/gomodifytags
    github.com/josharian/impl 
    github.com/davidrjenni/reftools/cmd/fillstruct 
    github.com/haya14busa/goplay/cmd/goplay 
    github.com/godoctor/godoctor 
    github.com/go-delve/delve/cmd/dlv 
    github.com/stamblerre/gocode 
    github.com/rogpeppe/godef 
    github.com/sqs/goreturns 
    golang.org/x/lint/golint 
    golang.org/x/tools/gopls 

    Ctrl+Shift+P
    go:install
    Go:Install/Update Tools
    勾选所有
  - 代码片段
    Ctrl+Shift+P
    snippets
* 常用库
** 文档操作
+ execl
  go get github.com/360EntSecGroup-Skylar/excelize
  升级 go get -u github.com/360EntSecGroup-Skylar/excelize
  在文件中直接引用，会在mod文件中自动添加
  require github.com/360EntSecGroup-Skylar/excelize v1.4.1 // indirect
* Go语言
** 常用命令
*** go get
*** go install
*** go mod
*** go build
+ 跨平台编译
  - 默认go build的可执行文件都是当前操作系统可执行的文件
  - 跨平台编译只需要指定目标操作系统的平台和处理器架构即可
    #+BEGIN_SRC shell
    SET CGO_ENABLED=0  // 禁用CGO,使用了cgo的代码是不支持跨平台编译的
    SET GOOS=linux  // 目标平台是linux
    SET GOARCH=amd64  // 目标处理器架构是amd64

    CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build
    CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build
    CGO_ENABLED=0 GOOS=darwin GOARCH=amd64 go build
    #+END_SRC
** 基础知识
*** 标识符、关键字
**** 标识符
- 标识符就是程序员定义的具有特殊意义的词，比如变量名、常量名、函数名等等。 Go语言中标识符由字母数字和_(下划线）组成，并且只能以字母和_开头。 举几个例子：abc, _, _123, a123
**** 关键字
- 关键字是指编程语言中预先定义好的具有特殊含义的标识符，关键字和保留字都不建议用作变量名
- 关键字
  break        default      func         interface    select
  case         defer        go           map          struct
  chan         else         goto         package      switch
  const        fallthrough  if           range        type
  continue     for          import       return       var
- 保留字
  Constants:    true  false  iota  nil

  Types:        int  int8  int16  int32  int64  
                uint  uint8  uint16  uint32  uint64  uintptr
                float32  float64  complex128  complex64
                bool  byte  rune  string  error

  Functions:    make  len  cap  new  append  copy  close  delete
                complex  real  imag
                panic  recover
*** 变量
**** 变量类型
Go语言中的每一个变量都有自己的类型，并且变量必须经过声明才能开始使用
**** 变量声明
+ 变量需要声明后才能使用，同一作用域内不支持重复声明。 并且Go语言的变量声明后必须使用
***** 标准声明
var 变量名 变量类型
#+BEGIN_SRC go
var name string
var age int
var isOk bool
#+END_SRC
***** 批量声明
go语言中还支持批量变量声明
#+BEGIN_SRC go
var (
    a string
    b int
    c bool
    d float32
)
#+END_SRC
**** 变量的初始化
+ Go语言在声明变量的时候，会自动对变量对应的内存区域进行初始化操作。每个变量会被初始化成其类型的默认值
  例如： 整型和浮点型变量的默认值为0；字符串变量的默认值为空字符串；布尔型变量默认为false；切片、函数、指针变量的默认为nil
+ 可在声明变量的时候为其指定初始值，变量初始化的标准格式如下
  var 变量名 类型 = 表达式
  #+BEGIN_SRC go
  var name string = "Q1mi"
  var age int = 18

  //一次初始化多个变量
  var name, age = "Q1mi", 20
  #+END_SRC
+ 类型推导
  有时候我们会将变量的类型省略，这个时候编译器会根据等号右边的值来推导变量的类型完成初始化
  #+BEGIN_SRC go
  var name = "Q1mi"
  var age = 18
  #+END_SRC
+ 短变量声明
  在函数内部，可以使用更简略的 := 方式声明并初始化变量
  #+BEGIN_SRC go
  package main

  import (
	  "fmt"
  )
  // 全局变量m
  var m = 100

  func main() {
  	n := 10
  	m := 200 // 此处声明局部变量m
  	fmt.Println(m, n)
  }
  #+END_SRC
+ 匿名变量
  - 在使用多重赋值时，如果想要忽略某个值，可以使用匿名变量（anonymous variable）,匿名变量用一个下划线_表示
  - 匿名变量不占用命名空间，不会分配内存，所以匿名变量之间不存在重复声明
  - _多用于占位，表示忽略值
  #+BEGIN_SRC go
  func foo() (int, string) {
  	return 10, "Q1mi"
  }
  func main() {
  	x, _ := foo()
  	_, y := foo()
  	fmt.Println("x=", x)
  	fmt.Println("y=", y)
  }
  #+END_SRC
*** 常量
+ 相对于变量，常量是恒定不变的值，多用于定义程序运行期间不会改变的那些值。 常量的声明和变量声明非常类似，只是把var换成了const，常量在定义的时候必须赋值
  #+BEGIN_SRC go
  const pi = 3.1415
  const e = 2.7182
  #+END_SRC
+ 多个常量也可以一起声明
  #+BEGIN_SRC go
  const (
    pi = 3.1415
    e = 2.7182
  )
  #+END_SRC
+ const同时声明多个常量时，如果省略了值则表示和上面一行的值相同
  #+BEGIN_SRC go
  const (
    n1 = 100
    n2
    n3
  )
  #+END_SRC
+ iota
  - iota是go语言的常量计数器，只能在常量的表达式中使用
  - iota在const关键字出现时将被重置为0。const中每新增一行常量声明将使iota计数一次(iota可理解为const语句块中的行索引)，使用iota能简化定义，在定义枚举时很有用
    #+BEGIN_SRC go
    const (
		         n1 = iota //0
		         n2        //1
		         n3        //2
		         n4        //3
	   )
    #+END_SRC
  - 几个常见的iota示例
    #+BEGIN_SRC go
    // 使用_跳过某些值
    const (
           n1 = iota //0
           n2        //1
           _
           n4        //3
    )
    
    // iota声明中间插队
    const (
		         n1 = iota //0
		         n2 = 100  //100
		         n3 = iota //2
		         n4        //3
     )
	   const n5 = iota //0

    // 定义数量级 （这里的<<表示左移操作，1<<10表示将1的二进制表示向左移10位，也就是由1变成了10000000000，也就是十进制的1024。同理2<<2表示将2的二进制表示向左移2位，也就是由10变成了1000，也就是十进制的8。）
    const (
		         _  = iota
		         KB = 1 << (10 * iota)
		         MB = 1 << (10 * iota)
		         GB = 1 << (10 * iota)
		         TB = 1 << (10 * iota)
		         PB = 1 << (10 * iota)
	   )

    // 多个iota定义在一行
    const (
		        a, b = iota + 1, iota + 2 //1,2
		        c, d                      //2,3
		        e, f                      //3,4
    )
    #+END_SRC
*** 数据类型
**** 基本数据类型
***** 整型
+ 常规整型
  整型分为以下两个大类： 按长度分为：int8、int16、int32、int64 对应的无符号整型：uint8、uint16、uint32、uint64
  | 类型     | 描述                                                          |
  |----------+---------------------------------------------------------------|
  | uint8    | 无符号 8位整型 (0 到 255)                                     |
  | uint16   | 无符号 16位整型 (0 到 65535)                                  |
  | uint32	 | 无符号 32位整型 (0 到 4294967295)                             |
  | uint64   | 无符号 64位整型 (0 到 18446744073709551615)                   |
  | int8     | 有符号 8位整型 (-128 到 127)                                  |
  | int16    | 有符号 16位整型 (-32768 到 32767)                             |
  | int32    | 有符号 32位整型 (-2147483648 到 2147483647)                   |
  | int64    | 有符号 64位整型 (-9223372036854775808 到 9223372036854775807) |
+ 特殊整型
  - 在使用int和 uint类型时，不能假定它是32位或64位的整型，而是考虑int和uint可能在不同平台上的差异
  - 获取对象的长度的内建len()函数返回的长度可以根据不同平台的字节长度进行变化。实际使用中，切片或 map 的元素数量等都可以用int来表示。在涉及到二进制传输、读写文件的结构描述时，为了保持文件的结构不会受到不同编译目标平台字节长度的影响，不要使用int和 uint
  | 类型    | 描述                                               |
  |---------+----------------------------------------------------|
  | uint    | 32位操作系统上就是uint32，64位操作系统上就是uint64 |
  | int     | 32位操作系统上就是int32，64位操作系统上就是int64   |
  | uintptr | 无符号整型，用于存放一个指针                       |
***** 数字字面量语法（Number literals syntax）
 便于开发者以二进制、八进制或十六进制浮点数的格式定义数字
 #+BEGIN_SRC go
 package main
 
 import "fmt"
 
 func main(){
   // 十进制
	 var a int = 10
	 fmt.Printf("%d \n", a)  // 10
	 fmt.Printf("%b \n", a)  // 1010  占位符%b表示二进制
 
	 // 八进制  以0开头
	 var b int = 077
	 fmt.Printf("%o \n", b)  // 77
 
	 // 十六进制  以0x开头
	 var c int = 0xff
	 fmt.Printf("%x \n", c)  // ff
	 fmt.Printf("%X \n", c)  // FF
 }
 #+END_SRC
***** 浮点型
+ Go语言支持两种浮点型数：float32和float64。这两种浮点型数据格式遵循IEEE 754标准： float32 的浮点数的最大范围约为 3.4e38，可以使用常量定义：math.MaxFloat32。 float64 的浮点数的最大范围约为 1.8e308，可以使用一个常量定义：math.MaxFloat64
+ 打印浮点数时，可以使用fmt包配合动词%f
  #+BEGIN_SRC go
  package main
  import (
          "fmt"
          "math"
  )
  func main() {
          fmt.Printf("%f\n", math.Pi)
          fmt.Printf("%.2f\n", math.Pi)
  }
  #+END_SRC
***** 复数
+ complex64和complex128，复数有实部和虚部，complex64的实部和虚部为32位，complex128的实部和虚部为64位
  #+BEGIN_SRC go
  var c1 complex64
  c1 = 1 + 2i
  var c2 complex128
  c2 = 2 + 3i
  fmt.Println(c1)
  fmt.Println(c2)
  #+END_SRC
***** 布尔值
+ Go语言中以bool类型进行声明布尔型数据，布尔型数据只有true（真）和false（假）两个值
+ 注意
  - 布尔类型变量的默认值为false
  - 不允许将整型强制转换为布尔型
  - 布尔型无法参与数值运算，也无法与其他类型进行转换
***** 字符串
+ 字符串以原生数据类型出现，使用字符串就像使用其他原生数据类型（int、bool、float32、float64 等）一样。 Go 语言里的字符串的内部实现使用UTF-8编码。 字符串的值为双引号(")中的内容，可以在Go语言的源码中直接添加非ASCII码字符
  #+BEGIN_SRC go
  s1 := "hello"
  s2 := "你好"
  #+END_SRC
+ 字符串转义符
  | 转义符 | 含义                               |
  |--------+------------------------------------|
  | \r     | 回车符（返回行首）                 |
  | \n     | 换行符（直接跳到下一行的同列位置） |
  | \t	   | 制表符                             |
  | \'     | 单引号                             |
  | \"     | 双引号                             |
  | \\     | 	反斜杠                           |
  例如打印一个Windows平台下的一个文件路径
  #+BEGIN_SRC go
  package main
  import (
      "fmt"
  )
  func main() {
      fmt.Println("str := \"c:\\Code\\lesson1\\go.exe\"")
  }
  #+END_SRC
+ 多行字符串
  Go语言中要定义一个多行字符串时，就必须使用反引号字符,反引号间换行将被作为字符串中的换行，但是所有的转义字符均无效，文本将会原样输出
  #+BEGIN_SRC go
  s1 := `第一行
  第二行
  第三行
  `
  fmt.Println(s1)
  #+END_SRC
+ 字符串的常用操作
  | 方法                                | 介绍           |
  |-------------------------------------+----------------|
  | len(str)                            | 求长度         |
  | +或fmt.Sprintf                      | 拼接字符串     |
  | strings.Split                       | 分割           |
  | strings.contains                    | 判断是否包含   |
  | strings.HasPrefix,strings.HasSuffix | 前缀/后缀判断  |
  | strings.Index(),strings.LastIndex() | 子串出现的位置 |
  | strings.Join(a[]string, sep string) | join操作       |
***** 字符
+ 组成每个字符串的元素叫做“字符”，可以通过遍历或者单个获取字符串元素获得字符。 字符用单引号（’）包裹起来
  #+BEGIN_SRC go
  var a := '中'
  var b := 'x'
  #+END_SRC
+ Go 语言的字符有以下两种
  - uint8类型，或者叫 byte 型，代表了ASCII码的一个字符
  - rune类型，代表一个 UTF-8字符
+ 当需要处理中文、日文或者其他复合字符时，则需要用到rune类型。rune类型实际是一个int32
+ Go 使用了特殊的 rune 类型来处理 Unicode，让基于 Unicode 的文本处理更为方便，也可以使用 byte 型进行默认字符串处理，性能和扩展性都有照顾
  #+BEGIN_SRC go
  // 遍历字符串
  func traversalString() {
	  s := "hello沙河"
	  for i := 0; i < len(s); i++ { //byte
		  fmt.Printf("%v(%c) ", s[i], s[i])
    }
	  fmt.Println()
	  for _, r := range s { //rune
		  fmt.Printf("%v(%c) ", r, r)
	  }
	  fmt.Println()
  }
  //输出
  104(h) 101(e) 108(l) 108(l) 111(o) 230(æ) 178(²) 153() 230(æ) 178(²) 179(³) 
  104(h) 101(e) 108(l) 108(l) 111(o) 27801(沙) 27827(河) 
  #+END_SRC
  - 因为UTF8编码下一个中文汉字由3~4个字节组成，所以我们不能简单的按照字节去遍历一个包含中文的字符串，否则就会出现上面输出中第一行的结果
  - 字符串底层是一个byte数组，所以可以和[]byte类型相互转换。字符串是不能修改的 字符串是由byte字节组成，所以字符串的长度是byte字节的长度。 rune类型用来表示utf8字符，一个rune字符由一个或多个byte组成
***** 修改字符串
+ 要修改字符串，需要先将其转换成[]rune或[]byte，完成后再转换为string。无论哪种转换，都会重新分配内存，并复制字节数组
  #+BEGIN_SRC go
  func changeString() {
	  s1 := "big"
	  // 强制类型转换
	  byteS1 := []byte(s1)
	  byteS1[0] = 'p'
	  fmt.Println(string(byteS1))

	  s2 := "白萝卜"
	  runeS2 := []rune(s2)
	  runeS2[0] = '红'
	  fmt.Println(string(runeS2))
  }
  #+END_SRC
***** 类型转换
+ Go语言中只有强制类型转换，没有隐式类型转换。该语法只能在两个类型之间支持相互转换的时候使用
+ 强制类型转换的基本语法如下
  T(表达式)
  T表示要转换的类型。表达式包括变量、复杂算子和函数返回值等
+ 比如计算直角三角形的斜边长时使用math包的Sqrt()函数，该函数接收的是float64类型的参数，而变量a和b都是int类型的，这个时候就需要将a和b强制类型转换为float64类型
  #+BEGIN_SRC go
  func sqrtDemo() {
    	var a, b = 3, 4
	    var c int
	    // math.Sqrt()接收的参数是float64类型，需要强制转换
	    c = int(math.Sqrt(float64(a*a + b*b)))
	    fmt.Println(c)
  }
  #+END_SRC
*** 运算符
+ 算术运算符
  ++（自增）和--（自减）在Go语言中是单独的语句，并不是运算符
  | 运算符 | 描述 |
  |--------+------|
  | " + "  | 相加 |
  | " - "  | 相减 |
  | " * "  | 相乘 |
  | " / "  | 相除 |
  | " % "  | 求余 |
+ 关系运算符
  | 运算符 | 描述                                                         |
  |--------+--------------------------------------------------------------|
  | " == " | 检查两个值是否相等，如果相等返回 True 否则返回 False         |
  | " != " | 检查两个值是否不相等，如果不相等返回 True 否则返回 False     |
  | " > "  | 检查左边值是否大于右边值，如果是返回 True 否则返回 False     |
  | " >= " | 检查左边值是否大于等于右边值，如果是返回 True 否则返回 False |
  | " < "  | 检查左边值是否小于右边值，如果是返回 True 否则返回 False     |
  | " <= " | 检查左边值是否小于等于右边值，如果是返回 True 否则返回 False |
+ 逻辑运算符
   &&  逻辑 AND 运算符。 如果两边的操作数都是 True，则为 True，否则为 False 
   ||  逻辑 OR 运算符。 如果两边的操作数有一个 True，则为 True，否则为 False
   !   逻辑 NOT 运算符。 如果条件为 True，则为 False，否则为 True
+ 位运算符
  位运算符对整数在内存中的二进制位进行操作
   &   参与运算的两数各对应的二进位相与。（两位均为1才为1） 
   |   参与运算的两数各对应的二进位相或。（两位有一个为1就为1）
   ^   参与运算的两数各对应的二进位相异或，当两对应的二进位相异时，结果为1。（两位不一样则为1）
   <<  左移n位就是乘以2的n次方。“a<<b”是把a的各二进位全部左移b位，高位丢弃，低位补0
   >>  右移n位就是除以2的n次方。“a>>b”是把a的各二进位全部右移b位
+ 赋值运算符
   =   简单的赋值运算符，将一个表达式的值赋给一个左值 
   +=  相加后再赋值                            
   -=  相减后再赋值                            
   *=  相乘后再赋值                            
   /=  相除后再赋值                            
   %=  求余后再赋值                            
   <<= 左移后赋值                              
   >>= 右移后赋值                              
   &=  按位与后赋值
   |=  按位或后赋值
   ^=  按位异或后赋值
*** 流程控制
**** if else(分支结构)
+ 基本写法
  #+BEGIN_SRC go
  if 表达式1 {
    分支1
  } else if 表达式2 {
    分支2
  } else{
    分支3
  }
  #+END_SRC
  - Go语言规定与if匹配的左括号"{"必须与if和表达式放在同一行，"{"放在其他位置会触发编译错误。 同理，与else匹配的"{"也必须与else写在同一行，else也必须与上一个if或else if右边的大括号在同一行
    #+BEGIN_SRC go
    func ifDemo1() {
      score := 65
      if score >= 90 {
        fmt.Println("A")
      } else if score > 75 {
        fmt.Println("B")
      } else {
        fmt.Println("C")
      }
    }
    #+END_SRC
+ 特殊写法
  可以在 if 表达式之前添加一个执行语句，再根据变量值进行判断
  #+BEGIN_SRC go
  func ifDemo2() {
      if score := 65; score >= 90 {
        fmt.Println("A")
      } else if score > 75 {
        fmt.Println("B")
      } else {
        fmt.Println("C")
      }
  }
  #+END_SRC
**** for(循环结构)
Go 语言中的所有循环类型均可以使用for关键字来完成
- 基本格式
  #+BEGIN_SRC go
  for 初始语句;条件表达式;结束语句{
      循环体语句
  }
  #+END_SRC
- 条件表达式返回true时循环体不停地进行循环，直到条件表达式返回false时自动退出循环
  #+BEGIN_SRC go
  func forDemo() {
      for i := 0; i < 10; i++ {
          fmt.Println(i)
      }
  }
  #+END_SRC
- for循环的初始语句可以被忽略，但是初始语句后的分号必须要写
  #+BEGIN_SRC go
  func forDemo2() {
      i := 0
      for ; i < 10; i++ {
          fmt.Println(i)
      }
  }
  #+END_SRC
- for循环的初始语句和结束语句都可以省略
  #+BEGIN_SRC go
  func forDemo3() {
      i := 0
      for i < 10 {
          fmt.Println(i)
          i++
      }
  }
  #+END_SRC
**** 无限循环
+ for循环可以通过break、goto、return、panic语句强制退出循环
  #+BEGIN_SRC go
  for {
      循环体语句
  }
  #+END_SRC
**** for range(键值循环)
+ Go语言中可以使用for range遍历数组、切片、字符串、map 及通道（channel）
+ 通过for range遍历的返回值有以下规律
  - 数组、切片、字符串返回索引和值
  - map返回键和值
  - 通道（channel）只返回通道内的值
**** switch case
+ 使用switch语句可方便地对大量的值进行条件判断
  #+BEGIN_SRC go
  func switchDemo1() {
      finger := 3
      switch finger {
      case 1:
        fmt.Println("大拇指")
      case 2:
        fmt.Println("食指")
      case 3:
        fmt.Println("中指")
      case 4:
        fmt.Println("无名指")
      case 5:
        fmt.Println("小拇指")
      default:
        fmt.Println("无效的输入！")
      }
  }
  #+END_SRC
+ Go语言规定每个switch只能有一个default分支
+ 一个分支可以有多个值，多个case值中间使用英文逗号分隔
  #+BEGIN_SRC go
  func testSwitch3() {
      switch n := 7; n {
      case 1, 3, 5, 7, 9:
        fmt.Println("奇数")
      case 2, 4, 6, 8:
        fmt.Println("偶数")
      default:
        fmt.Println(n)
      }
  }
  #+END_SRC
+ 分支还可以使用表达式，这时候switch语句后面不需要再跟判断变量
  #+BEGIN_SRC go
  func switchDemo4() {
      age := 30
      switch {
      case age < 25:
        fmt.Println("好好学习吧")
      case age > 25 && age < 35:
        fmt.Println("好好工作吧")
      case age > 60:
        fmt.Println("好好享受吧")
      default:
        fmt.Println("活着真好")
      }
  }
  #+END_SRC
+ fallthrough语法可以执行满足条件的case的下一个case，是为了兼容C语言中的case设计的
  #+BEGIN_SRC go
    func switchDemo5() {
        s := "a"
        switch {
        case s == "a":
          fmt.Println("a")
          fallthrough
        case s == "b":
          fmt.Println("b")
        case s == "c":
          fmt.Println("c")
        default:
          fmt.Println("...")
        }
    }
    // 输出
    // a
    // b
  #+END_SRC
**** goto(跳转到指定标签)
+ goto语句通过标签进行代码间的无条件跳转。goto语句可以在快速跳出循环、避免重复退出上有一定的帮助。Go语言中使用goto语句能简化一些代码的实现过程。 例如双层嵌套的for循环要退出时
  #+BEGIN_SRC go
  func gotoDemo1() {
      var breakFlag bool
      for i := 0; i < 10; i++ {
        for j := 0; j < 10; j++ {
          if j == 2 {
            // 设置退出标签
            breakFlag = true
            break
          }
          fmt.Printf("%v-%v\n", i, j)
        }
        // 外层for循环判断
        if breakFlag {
          break
        }
      }
  }
  // 使用goto语句能简化代码：
  func gotoDemo2() {
      for i := 0; i < 10; i++ {
        for j := 0; j < 10; j++ {
          if j == 2 {
            // 设置退出标签
            goto breakTag
          }
          fmt.Printf("%v-%v\n", i, j)
        }
      }
      return
      // 标签
    breakTag:
      fmt.Println("结束for循环")
  }
  #+END_SRC
**** break(跳出循环)
+ break语句可以结束for、switch和select的代码块
+ break语句还可以在语句后面添加标签，表示退出某个标签对应的代码块，标签要求必须定义在对应的for、switch和 select的代码块上
  #+BEGIN_SRC go
  func breakDemo1() {
  BREAKDEMO1:
      for i := 0; i < 10; i++ {
        for j := 0; j < 10; j++ {
          if j == 2 {
            break BREAKDEMO1
          }
          fmt.Printf("%v-%v\n", i, j)
        }
      }
      fmt.Println("...")
  }
  #+END_SRC
**** continue(继续下次循环)
+ continue语句可以结束当前循环，开始下一次的循环迭代过程，仅限在for循环内使用。
+ 在 continue语句后添加标签时，表示开始标签对应的循环
  #+BEGIN_SRC go
  func continueDemo() {
  forloop1:
      for i := 0; i < 5; i++ {
        // forloop2:
        for j := 0; j < 5; j++ {
          if i == 2 && j == 2 {
            continue forloop1
          }
          fmt.Printf("%v-%v\n", i, j)
        }
      }
  }
  #+END_SRC
*** 数组(Array)
数组是同一种数据类型元素的集合，在Go语言中，数组从声明时就确定，使用时可以修改数组成员，但是数组大小不可变化
**** 数组定义
#+BEGIN_SRC go
var 数组变量名 [元素数量]T

// 定义一个长度为3元素类型为int的数组a
var a [3]int
#+END_SRC
+ 数组的长度必须是常量，并且长度是数组类型的一部分。一旦定义，长度不能变。 [5]int和[10]int是不同的类型
  #+BEGIN_SRC go
  var a [3]int
  var b [4]int
  a = b //不可以这样做，因为此时a和b是不同的类型
  #+END_SRC
+ 数组可以通过下标进行访问，下标是从0开始，最后一个元素下标是：len-1，访问越界（下标在合法范围之外），则触发访问越界，会panic
**** 数组的初始化
数组的初始化也有很多方式
+ 方法一
  初始化数组时可以使用初始化列表来设置数组元素的值
  #+BEGIN_SRC go
  func main() {
      var testArray [3]int                        //数组会初始化为int类型的零值
      var numArray = [3]int{1, 2}                 //使用指定的初始值完成初始化
      var cityArray = [3]string{"北京", "上海", "深圳"} //使用指定的初始值完成初始化
      fmt.Println(testArray)                      //[0 0 0]
      fmt.Println(numArray)                       //[1 2 0]
      fmt.Println(cityArray)                      //[北京 上海 深圳]
  }
  #+END_SRC
+ 方法二
  按照上面的方法每次都要确保提供的初始值和数组长度一致，一般情况下我们可以让编译器根据初始值的个数自行推断数组的长度
  #+BEGIN_SRC go
  func main() {
      var testArray [3]int
      var numArray = [...]int{1, 2}
      var cityArray = [...]string{"北京", "上海", "深圳"}
      fmt.Println(testArray)                          //[0 0 0]
      fmt.Println(numArray)                           //[1 2]
      fmt.Printf("type of numArray:%T\n", numArray)   //type of numArray:[2]int
      fmt.Println(cityArray)                          //[北京 上海 深圳]
      fmt.Printf("type of cityArray:%T\n", cityArray) //type of cityArray:[3]string
  }
  #+END_SRC
+ 方法三
  可以使用指定索引值的方式来初始化数组
  #+BEGIN_SRC go
  func main() {
      a := [...]int{1: 1, 3: 5}
      fmt.Println(a)                  // [0 1 0 5]
      fmt.Printf("type of a:%T\n", a) //type of a:[4]int
  }
  #+END_SRC
**** 数组的遍历
遍历数组有以下两种方法
#+BEGIN_SRC go
func main() {
    var a = [...]string{"北京", "上海", "深圳"}
    // 方法1：for循环遍历
    for i := 0; i < len(a); i++ {
      fmt.Println(a[i])
    }

    // 方法2：for range遍历
    for index, value := range a {
      fmt.Println(index, value)
    }
}
#+END_SRC
**** 多维数组
+ Go语言是支持多维数组的，我们这里以二维数组为例（数组中又嵌套数组）
+ 二维数组的定义
  #+BEGIN_SRC go
  func main() {
      a := [3][2]string{
        {"北京", "上海"},
        {"广州", "深圳"},
        {"成都", "重庆"},
      }
      fmt.Println(a) //[[北京 上海] [广州 深圳] [成都 重庆]]
      fmt.Println(a[2][1]) //支持索引取值:重庆
  }
  #+END_SRC
+ 二维数组的遍历
  #+BEGIN_SRC go
  func main() {
      a := [3][2]string{
        {"北京", "上海"},
        {"广州", "深圳"},
        {"成都", "重庆"},
      }
      for _, v1 := range a {
        for _, v2 := range v1 {
          fmt.Printf("%s\t", v2)
        }
        fmt.Println()
      }
  }
  #+END_SRC
+  多维数组只有第一层可以使用...来让编译器推导数组长度
  #+BEGIN_SRC go
    //支持的写法
    a := [...][2]string{
      {"北京", "上海"},
      {"广州", "深圳"},
      {"成都", "重庆"},
    }
    //不支持多维数组的内层使用...
    b := [3][...]string{
      {"北京", "上海"},
      {"广州", "深圳"},
      {"成都", "重庆"},
    }

  #+END_SRC
**** 数组是值类型
+ 数组是值类型，赋值和传参会复制整个数组。因此改变副本的值，不会改变本身的值
  #+BEGIN_SRC go
  func modifyArray(x [3]int) {
      x[0] = 100
  }

  func modifyArray2(x [3][2]int) {
      x[2][0] = 100
  }
  func main() {
      a := [3]int{10, 20, 30}
      modifyArray(a) //在modify中修改的是a的副本x
      fmt.Println(a) //[10 20 30]
      b := [3][2]int{
        {1, 1},
        {1, 1},
        {1, 1},
      }
      modifyArray2(b) //在modify中修改的是b的副本x
      fmt.Println(b)  //[[1 1] [1 1] [1 1]]
  }
  #+END_SRC
**** 注意
+ 数组支持 “==“、”!=” 操作符，因为内存总是被初始化过的
+ [n]*T表示指针数组，*[n]T表示数组指针 
*** 切片(slice)
+ 切片（Slice）是一个拥有相同类型元素的可变长度的序列。它是基于数组类型做的一层封装。它非常灵活，支持自动扩容
+ 切片是一个引用类型，它的内部结构包含地址、长度和容量。切片一般用于快速地操作一块数据集合
+ 切片是引用类型，不支持直接比较，只能和nil比较
**** 定义
+ 声明切片类型的基本语法
  #+BEGIN_SRC go
  var name []T
  // name:表示变量名
  // T:表示切片中的元素类型
  #+END_SRC
  #+BEGIN_SRC go
  func main() {
      // 声明切片类型
      var a []string              //声明一个字符串切片
      var b = []int{}             //声明一个整型切片并初始化
      var c = []bool{false, true} //声明一个布尔切片并初始化
      var d = []bool{false, true} //声明一个布尔切片并初始化
      fmt.Println(a)              //[]
      fmt.Println(b)              //[]
      fmt.Println(c)              //[false true]
      fmt.Println(a == nil)       //true
      fmt.Println(b == nil)       //false
      fmt.Println(c == nil)       //false
      // fmt.Println(c == d)   //切片是引用类型，不支持直接比较，只能和nil比较
  }
  #+END_SRC
**** 切片的长度和容量
+ 切片拥有自己的长度和容量，我们可以通过使用内置的len()函数求长度，使用内置的cap()函数求切片的容量
**** 切片表达式
+ 切片表达式从字符串、数组、指向数组或切片的指针构造子字符串或切片。它有两种变体：一种指定low和high两个索引界限值的简单的形式，另一种是除了low和high索引界限值外还指定容量的完整的形式
***** 简单切片表达式
+ 切片的底层就是一个数组，所以我们可以基于数组通过切片表达式得到切片。 切片表达式中的low和high表示一个索引范围（左包含，右不包含），也就是下面代码中从数组a中选出1<=索引值<4的元素组成切片s，得到的切片长度=high-low，容量等于得到的切片的底层数组的容量
  #+BEGIN_SRC go
  func main() {
      a := [5]int{1, 2, 3, 4, 5}
      s := a[1:3]  // s := a[low:high]
      fmt.Printf("s:%v len(s):%v cap(s):%v\n", s, len(s), cap(s))
  }
  // 输出
  s:[2 3] len(s):2 cap(s):4
  #+END_SRC
+ 为了方便起见，可以省略切片表达式中的任何索引。省略了low则默认为0；省略了high则默认为切片操作数的长度
  #+BEGIN_SRC go
  a[2:]  // 等同于 a[2:len(a)]
  a[:3]  // 等同于 a[0:3]
  a[:]   // 等同于 a[0:len(a)]
  #+END_SRC
+ 注意
  - 对于数组或字符串，如果0 <= low <= high <= len(a)，则索引合法，否则就会索引越界（out of range）
  - 对切片再执行切片表达式时（切片再切片），high的上限边界是切片的容量cap(a)，而不是长度。常量索引必须是非负的，并且可以用int类型的值表示;对于数组或常量字符串，常量索引也必须在有效范围内。如果low和high两个指标都是常数，它们必须满足low <= high。如果索引在运行时超出范围，就会发生运行时panic
    #+BEGIN_SRC go
    func main() {
        a := [5]int{1, 2, 3, 4, 5}
        s := a[1:3]  // s := a[low:high]
        fmt.Printf("s:%v len(s):%v cap(s):%v\n", s, len(s), cap(s))
        s2 := s[3:4]  // 索引的上限是cap(s)而不是len(s)
        fmt.Printf("s2:%v len(s2):%v cap(s2):%v\n", s2, len(s2), cap(s2))
    }
    // 输出
    s:[2 3] len(s):2 cap(s):4
    s2:[5] len(s2):1 cap(s2):1
    #+END_SRC
***** 完整切片表达式
+ 对于数组，指向数组的指针，或切片a(注意不能是字符串)支持完整切片表达式
  #+BEGIN_SRC go
  a[low : high : max]
  #+END_SRC
+ 上面的代码会构造与简单切片表达式a[low: high]相同类型、相同长度和元素的切片。另外，它会将得到的结果切片的容量设置为max-low。在完整切片表达式中只有第一个索引值（low）可以省略；它默认为0
  #+BEGIN_SRC go
  func main() {
      a := [5]int{1, 2, 3, 4, 5}
      t := a[1:3:5]
      fmt.Printf("t:%v len(t):%v cap(t):%v\n", t, len(t), cap(t))
  }
  // 输出结果
  t:[2 3] len(t):2 cap(t):4
  #+END_SRC
+ 完整切片表达式需要满足的条件是0 <= low <= high <= max <= cap(a)，其他条件和简单切片表达式相同
**** 使用make()函数构造切片
+ 上面都是基于数组来创建的切片，如果需要动态的创建一个切片，我们就需要使用内置的make()函数
  #+BEGIN_SRC go
  make([]T, size, cap)
  // T:切片的元素类型
  // size:切片中元素的数量
  // cap:切片的容量

  func main() {
	    a := make([]int, 2, 10)
	    fmt.Println(a)      //[0 0]
	    fmt.Println(len(a)) //2
	    fmt.Println(cap(a)) //10
  }
  // 上面代码中a的内部存储空间已经分配了10个，但实际上只用了2个。 容量并不会影响当前元素的个数，所以len(a)返回2，cap(a)则返回该切片的容量
  #+END_SRC
**** 切片的本质
+ 切片的本质就是对底层数组的封装，它包含了三个信息：底层数组的指针、切片的长度（len）和切片的容量（cap）[[file:pic/%E5%88%87%E7%89%8701.png][示意图]]
**** 判断切片是否为空
+ 检查切片是否为空，请始终使用len(s) == 0来判断，而不应该使用s == nil来判断
**** 切片不能直接比较
+ 切片之间是不能比较的，我们不能使用==操作符来判断两个切片是否含有全部相等元素。 切片唯一合法的比较操作是和nil比较。 一个nil值的切片并没有底层数组，一个nil值的切片的长度和容量都是0。但是我们不能说一个长度和容量都是0的切片一定是nil
+ 要判断一个切片是否是空的，要是用len(s) == 0来判断，不应该使用s == nil来判断
  #+BEGIN_SRC go
  var s1 []int         //len(s1)=0;cap(s1)=0;s1==nil
  s2 := []int{}        //len(s2)=0;cap(s2)=0;s2!=nil
  s3 := make([]int, 0) //len(s3)=0;cap(s3)=0;s3!=nil
  #+END_SRC
**** 切片的赋值拷贝
+ 下面的代码中演示了拷贝前后两个变量共享底层数组，对一个切片的修改会影响另一个切片的内容，这点需要特别注意
  #+BEGIN_SRC go
  func main() {
      s1 := make([]int, 3) //[0 0 0]
      s2 := s1             //将s1直接赋值给s2，s1和s2共用一个底层数组
      s2[0] = 100
      fmt.Println(s1) //[100 0 0]
      fmt.Println(s2) //[100 0 0]
  }
  #+END_SRC
**** 切片遍历
+ 切片的遍历方式和数组是一致的，支持索引遍历和for range遍历
  #+BEGIN_SRC go
  func main() {
      s := []int{1, 3, 5}

      for i := 0; i < len(s); i++ {
        fmt.Println(i, s[i])
      }

      for index, value := range s {
        fmt.Println(index, value)
      }
  }
  #+END_SRC
**** append()方法为切片添加元素
+ Go语言的内建函数append()可以为切片动态添加元素。 可以一次添加一个元素，可以添加多个元素，也可以添加另一个切片中的元素（后面加…）
  #+BEGIN_SRC go
  func main(){
      var s []int
      s = append(s, 1)        // [1]
      s = append(s, 2, 3, 4)  // [1 2 3 4]
      s2 := []int{5, 6, 7}  
      s = append(s, s2...)    // [1 2 3 4 5 6 7]
  }
  #+END_SRC
+ 注意
  - 通过var声明的零值切片可以在append()函数直接使用，无需初始化
    #+BEGIN_SRC go
    var s []int
    s = append(s, 1, 2, 3)
    #+END_SRC
  - 没有必要像下面的代码一样初始化一个切片再传入append()函数使用
    #+BEGIN_SRC go
    s := []int{}  // 没有必要初始化
    s = append(s, 1, 2, 3)

    var s = make([]int)  // 没有必要初始化
    s = append(s, 1, 2, 3)
    #+END_SRC
  - 每个切片会指向一个底层数组，这个数组的容量够用就添加新增元素。当底层数组不能容纳新增的元素时，切片就会自动按照一定的策略进行“扩容”，此时该切片指向的底层数组就会更换。“扩容”操作往往发生在append()函数调用时，所以我们通常都需要用原变量接收append函数的返回值
    #+BEGIN_SRC go
    func main() {
        //append()添加元素和切片扩容
        var numSlice []int
        for i := 0; i < 10; i++ {
          numSlice = append(numSlice, i)
          fmt.Printf("%v  len:%d  cap:%d  ptr:%p\n", numSlice, len(numSlice), cap(numSlice), numSlice)
        }
    }
    // 输出：
    [0]  len:1  cap:1  ptr:0xc0000a8000
    [0 1]  len:2  cap:2  ptr:0xc0000a8040
    [0 1 2]  len:3  cap:4  ptr:0xc0000b2020
    [0 1 2 3]  len:4  cap:4  ptr:0xc0000b2020
    [0 1 2 3 4]  len:5  cap:8  ptr:0xc0000b6000
    [0 1 2 3 4 5]  len:6  cap:8  ptr:0xc0000b6000
    [0 1 2 3 4 5 6]  len:7  cap:8  ptr:0xc0000b6000
    [0 1 2 3 4 5 6 7]  len:8  cap:8  ptr:0xc0000b6000
    [0 1 2 3 4 5 6 7 8]  len:9  cap:16  ptr:0xc0000b8000
    [0 1 2 3 4 5 6 7 8 9]  len:10  cap:16  ptr:0xc0000b8000
    #+END_SRC
  - append()函数将元素追加到切片的最后并返回该切片
  - 切片numSlice的容量按照1，2，4，8，16这样的规则自动进行扩容，每次扩容后都是扩容前的2倍
  - append()函数还支持一次性追加多个元素
    #+BEGIN_SRC go
    var citySlice []string
    // 追加一个元素
    citySlice = append(citySlice, "北京")
    // 追加多个元素
    citySlice = append(citySlice, "上海", "广州", "深圳")
    // 追加切片
    a := []string{"成都", "重庆"}
    citySlice = append(citySlice, a...)
    fmt.Println(citySlice) //[北京 上海 广州 深圳 成都 重庆]
    #+END_SRC
**** 切片的扩容策略
+ 首先判断，如果新申请容量（cap）大于2倍的旧容量（old.cap），最终容量（newcap）就是新申请的容量（cap）
+ 否则判断，如果旧切片的长度小于1024，则最终容量(newcap)就是旧容量(old.cap)的两倍，即（newcap=doublecap）
+ 否则判断，如果旧切片长度大于等于1024，则最终容量（newcap）从旧容量（old.cap）开始循环增加原来的1/4，即（newcap=old.cap,for {newcap += newcap/4}）直到最终容量（newcap）大于等于新申请的容量(cap)，即（newcap >= cap）
+ 如果最终容量（cap）计算值溢出，则最终容量（cap）就是新申请容量（cap）
+ 需要注意的是，切片扩容还会根据切片中元素的类型不同而做不同的处理，比如int和string类型的处理方式就不一样
**** 使用copy()函数复制切片
+ Go语言内建的copy()函数可以迅速地将一个切片的数据复制到另外一个切片空间中，copy()函数的使用格式如下
  #+BEGIN_SRC go
  copy(destSlice, srcSlice []T)

  func main() {
	// copy()复制切片
	  a := []int{1, 2, 3, 4, 5}
	  c := make([]int, 5, 5)
	  copy(c, a)     //使用copy()函数将切片a中的元素复制到切片c
	  fmt.Println(a) //[1 2 3 4 5]
	  fmt.Println(c) //[1 2 3 4 5]
	  c[0] = 1000
	  fmt.Println(a) //[1 2 3 4 5]
	  fmt.Println(c) //[1000 2 3 4 5]
  }
  #+END_SRC
**** 从切片中删除元素
+ Go语言中并没有删除切片元素的专用方法，我们可以使用切片本身的特性来删除元素
  #+BEGIN_SRC go
  func main() {
      // 从切片中删除元素
      a := []int{30, 31, 32, 33, 34, 35, 36, 37}
      // 要删除索引为2的元素
      a = append(a[:2], a[3:]...)
      fmt.Println(a) //[30 31 33 34 35 36 37]
  }
  // 要从切片a中删除索引为index的元素，操作方法是a = append(a[:index], a[index+1:]...)
  #+END_SRC
*** map
+ Go语言中提供的映射关系容器为map，其内部使用散列表（hash）实现
+ map是一种无序的基于key-value的数据结构，Go语言中的map是引用类型，必须初始化才能使用
**** map定义
+ 语法
  #+BEGIN_SRC go
  map[KeyType]ValueType
  // KeyType:表示键的类型
  // ValueType:表示键对应的值的类型
  #+END_SRC
+ map类型的变量默认初始值为nil，需要使用make()函数来分配内存
  #+BEGIN_SRC go
  make(map[KeyType]ValueType, [cap])
  // 其中cap表示map的容量，该参数虽然不是必须的，但是我们应该在初始化map的时候就为其指定一个合适的容量
  #+END_SRC
**** 基本使用
+ map中的数据都是成对出现的，map的基本使用示例代码
  #+BEGIN_SRC go
  func main() {
      scoreMap := make(map[string]int, 8)
      scoreMap["张三"] = 90
      scoreMap["小明"] = 100
      fmt.Println(scoreMap)
      fmt.Println(scoreMap["小明"])
      fmt.Printf("type of a:%T\n", scoreMap)
  }
  // 输出：
  map[小明:100 张三:90]
  100
  type of a:map[string]int
  #+END_SRC
+ map也支持在声明的时候填充元素
  #+BEGIN_SRC go
  func main() {
      userInfo := map[string]string{
        "username": "沙河小王子",
        "password": "123456",
      }
      fmt.Println(userInfo) //
  }
  #+END_SRC
**** 判断某个键是否存在
+ Go语言中有个判断map中键是否存在的特殊写法
  #+BEGIN_SRC go
  value, ok := map[key]

  // 示例
  func main() {
      scoreMap := make(map[string]int)
      scoreMap["张三"] = 90
      scoreMap["小明"] = 100
      // 如果key存在ok为true,v为对应的值；不存在ok为false,v为值类型的零值
      v, ok := scoreMap["张三"]
      if ok {
        fmt.Println(v)
      } else {
        fmt.Println("查无此人")
      }
  }
  #+END_SRC
**** map的遍历
+ Go语言中使用for range遍历map
  #+BEGIN_SRC go
  func main() {
      scoreMap := make(map[string]int)
      scoreMap["张三"] = 90
      scoreMap["小明"] = 100
      scoreMap["娜扎"] = 60
      for k, v := range scoreMap {
        fmt.Println(k, v)
      }
  }
  #+END_SRC
+ 只想遍历key的时候，可以按下面的写法
  #+BEGIN_SRC go
  func main() {
      scoreMap := make(map[string]int)
      scoreMap["张三"] = 90
      scoreMap["小明"] = 100
      scoreMap["娜扎"] = 60
      for k := range scoreMap {
        fmt.Println(k)
      }
  }
  #+END_SRC
+ 遍历map时的元素顺序与添加键值对的顺序无关
**** 使用delete()函数删除键值对
+ 使用delete()内建函数从map中删除一组键值对，delete()函数的格式如下
  #+BEGIN_SRC go
  delete(map, key)

  // 示例
  func main(){
    	scoreMap := make(map[string]int)
	    scoreMap["张三"] = 90
	    scoreMap["小明"] = 100
	    scoreMap["娜扎"] = 60
	    delete(scoreMap, "小明")//将小明:100从map中删除
	    for k,v := range scoreMap{
		      fmt.Println(k, v)
	    }
  }
  #+END_SRC
**** 按照指定顺序遍历map
+ 示例
  #+BEGIN_SRC go
  func main() {
      rand.Seed(time.Now().UnixNano()) //初始化随机数种子

      var scoreMap = make(map[string]int, 200)

      for i := 0; i < 100; i++ {
        key := fmt.Sprintf("stu%02d", i) //生成stu开头的字符串
        value := rand.Intn(100)          //生成0~99的随机整数
        scoreMap[key] = value
      }
      //取出map中的所有key存入切片keys
      var keys = make([]string, 0, 200)
      for key := range scoreMap {
        keys = append(keys, key)
      }
      //对切片进行排序
      sort.Strings(keys)
      //按照排序后的key遍历map
      for _, key := range keys {
        fmt.Println(key, scoreMap[key])
      }
  }
  #+END_SRC
**** 元素为map类型的切片
+ 切片中的元素为map类型时的操作
  #+BEGIN_SRC go
  func main() {
      var mapSlice = make([]map[string]string, 3)
      for index, value := range mapSlice {
        fmt.Printf("index:%d value:%v\n", index, value)
      }
      fmt.Println("after init")
      // 对切片中的map元素进行初始化
      mapSlice[0] = make(map[string]string, 10)
      mapSlice[0]["name"] = "小王子"
      mapSlice[0]["password"] = "123456"
      mapSlice[0]["address"] = "沙河"
      for index, value := range mapSlice {
        fmt.Printf("index:%d value:%v\n", index, value)
      }
  }

  #+END_SRC
**** 值为切片类型的map
+ map中值为切片类型的操作
  #+BEGIN_SRC go
  func main() {
      var sliceMap = make(map[string][]string, 3)
      fmt.Println(sliceMap)
      fmt.Println("after init")
      key := "中国"
      value, ok := sliceMap[key]
      if !ok {
        value = make([]string, 0, 2)
      }
      value = append(value, "北京", "上海")
      sliceMap[key] = value
      fmt.Println(sliceMap)
  }
  #+END_SRC
*** 函数
Go语言中支持函数、匿名函数和闭包，并且函数在Go语言中属于“一等公民”
**** 定义
+ 定义函数使用func关键字
  #+BEGIN_SRC go
  func 函数名(参数)(返回值){
    函数体
  }
  #+END_SRC
+ 函数名：由字母、数字、下划线组成。但函数名的第一个字母不能是数字。在同一个包内，函数名也称不能重名
+ 参数：参数由参数变量和参数变量的类型组成，多个参数之间使用,分隔
+ 返回值：返回值由返回值变量和其变量类型组成，也可以只写返回值的类型，多个返回值必须用()包裹，并用,分隔
+ 函数体：实现指定功能的代码块
+ 函数的参数和返回值都是可选的
+ 示例
  #+BEGIN_SRC go
  func intSum(x int, y int) int {
      return x + y
  }

  func sayHello() {
      fmt.Println("Hello 沙河")
  }
  #+END_SRC
**** 调用
+ 定义了函数之后，我们可以通过函数名()的方式调用函数。 例如我们调用上面定义的两个函数
  #+BEGIN_SRC go
  func main() {
      sayHello()
      ret := intSum(10, 20)
      fmt.Println(ret)
  }
  #+END_SRC
+ 调用有返回值的函数时，可以不接收其返回值
**** 参数
+ 类型简写
  函数的参数中如果相邻变量的类型相同，则可以省略类型
  #+BEGIN_SRC go
  func intSum(x, y int) int {
	    return x + y
  }
  // 上面的代码中，intSum函数有两个参数，这两个参数的类型均为int，因此可以省略x的类型，因为y后面有类型说明，x参数也是该类型
  #+END_SRC
+ 可变参数
  - 可变参数是指函数的参数数量不固定。Go语言中的可变参数通过在参数名后加...来标识
  - 注意：可变参数通常要作为函数的最后一个参数,本质上，函数的可变参数是通过切片来实现的
    #+BEGIN_SRC go
    func intSum2(x ...int) int {
        fmt.Println(x) //x是一个切片
        sum := 0
        for _, v := range x {
          sum = sum + v
        }
        return sum
    }
    // 调用上面的函数
    ret1 := intSum2()
    ret2 := intSum2(10)
    ret3 := intSum2(10, 20)
    ret4 := intSum2(10, 20, 30)
    fmt.Println(ret1, ret2, ret3, ret4) //0 10 30 60
    #+END_SRC  
  - 固定参数搭配可变参数使用时，可变参数要放在固定参数的后面
    #+BEGIN_SRC go
    func intSum3(x int, y ...int) int {
        fmt.Println(x, y)
        sum := x
        for _, v := range y {
          sum = sum + v
        }
        return sum
    }
    // 调用上述函数：
    ret5 := intSum3(100)
    ret6 := intSum3(100, 10)
    ret7 := intSum3(100, 10, 20)
    ret8 := intSum3(100, 10, 20, 30)
    fmt.Println(ret5, ret6, ret7, ret8) //100 110 130 160
    #+END_SRC
**** 返回值
+ 通过return关键字向外输出返回值
+ 多返回值:Go语言中函数支持多返回值，函数如果有多个返回值时必须用()将所有返回值包裹起来
  #+BEGIN_SRC go
  func calc(x, y int) (int, int) {
      sum := x + y
      sub := x - y
      return sum, sub
  }
  #+END_SRC
+ 返回值命名:函数定义时可以给返回值命名，并在函数体中直接使用这些变量，最后通过return关键字返回
  #+BEGIN_SRC go
  func calc(x, y int) (sum, sub int) {
      sum = x + y
      sub = x - y
      return
  }
  #+END_SRC
+ 返回值补充:当我们的一个函数返回值类型为slice时，nil可以看做是一个有效的slice，没必要显示返回一个长度为0的切片
  #+BEGIN_SRC go
  func someFunc(x string) []int {
      if x == "" {
        return nil // 没必要返回[]int{}
      }
      ...
  }
  #+END_SRC
*** 函数进阶
**** 变量作用域
+ 全局变量
  全局变量是定义在函数外部的变量，它在程序整个运行周期内都有效。 在函数中可以访问到全局变量
  #+BEGIN_SRC go
  package main

  import "fmt"

  //定义全局变量num
  var num int64 = 10

  func testGlobalVar() {
      fmt.Printf("num=%d\n", num) //函数中可以访问全局变量num
  }
  func main() {
      testGlobalVar() //num=10
  }
  #+END_SRC

+ 局部变量
  - 函数内定义的变量无法在该函数外使用
    #+BEGIN_SRC go
    func testLocalVar() {
    //定义一个函数局部变量x,仅在该函数内生效
        var x int64 = 100
        fmt.Printf("x=%d\n", x)
    }

    func main() {
        testLocalVar()
        fmt.Println(x) // 此时无法使用变量x
    }
    #+END_SRC
  - 局部变量和全局变量重名，优先访问局部变量
    #+BEGIN_SRC go
    package main
    
    import "fmt"
    
    //定义全局变量num
    var num int64 = 10

    func testNum() {
        num := 100
        fmt.Printf("num=%d\n", num) // 函数中优先使用局部变量
    }
    func main() {
        testNum() // num=100
    }
    #+END_SRC
  - 语句块定义的变量，通常我们会在if条件判断、for循环、switch语句上使用这种定义变量的方式
    #+BEGIN_SRC go
    func testLocalVar2(x, y int) {
        fmt.Println(x, y) //函数的参数也是只在本函数中生效
        if x > 0 {
          z := 100 //变量z只在if语句块生效
          fmt.Println(z)
        }
        //fmt.Println(z)//此处无法使用变量z
    }
    #+END_SRC
**** 函数类型与变量
***** 定义函数类型
+ 可以使用type关键字来定义一个函数类型
  #+BEGIN_SRC go
  type calculation func(int, int) int
  // 上面语句定义了一个calculation类型，它是一种函数类型，这种函数接收两个int类型的参数并且返回一个int类型的返回值
  // 简单来说，凡是满足这个条件的函数都是calculation类型的函数，例如下面的add和sub是calculation类型
  func add(x, y int) int {
	    return x + y
  }

  func sub(x, y int) int {
	    return x - y
  }
  // add和sub都能赋值给calculation类型的变量
  var c calculation
  c = add
  #+END_SRC
***** 函数类型变量
+ 可以声明函数类型的变量并且为该变量赋值
  #+BEGIN_SRC go
  func main() {
      var c calculation               // 声明一个calculation类型的变量c
      c = add                         // 把add赋值给c
      fmt.Printf("type of c:%T\n", c) // type of c:main.calculation
      fmt.Println(c(1, 2))            // 像调用add一样调用c

      f := add                        // 将函数add赋值给变量f
      fmt.Printf("type of f:%T\n", f) // type of f:func(int, int) int
      fmt.Println(f(10, 20))          // 像调用add一样调用f
  }
  #+END_SRC
**** 高阶函数
***** 函数作为参数
+ 函数可以作为参数
  #+BEGIN_SRC go
  func add(x, y int) int {
      return x + y
    }
    func calc(x, y int, op func(int, int) int) int {
      return op(x, y)
    }
    func main() {
      ret2 := calc(10, 20, add)
      fmt.Println(ret2) //30
  }
  #+END_SRC
***** 函数作为返回值
+ 函数也可以作为返回值
  #+BEGIN_SRC go
  func do(s string) (func(int, int) int, error) {
      switch s {
      case "+":
        return add, nil
      case "-":
        return sub, nil
      default:
        err := errors.New("无法识别的操作符")
        return nil, err
      }
  }

  #+END_SRC
**** 匿名函数和闭包
***** 匿名函数
+ 函数当然还可以作为返回值，但是在Go语言中函数内部不能再像之前那样定义函数了，只能定义匿名函数。匿名函数就是没有函数名的函数，匿名函数的定义格式如下
  #+BEGIN_SRC go
  func(参数)(返回值){
      函数体
  }
  #+END_SRC
+ 匿名函数因为没有函数名，所以没办法像普通函数那样调用，所以匿名函数需要保存到某个变量或者作为立即执行函数
  #+BEGIN_SRC go
  func main() {
      // 将匿名函数保存到变量
      add := func(x, y int) {
        fmt.Println(x + y)
      }
      add(10, 20) // 通过变量调用匿名函数

      //自执行函数：匿名函数定义完加()直接执行
      func(x, y int) {
        fmt.Println(x + y)
      }(10, 20)
  }
  #+END_SRC
+ 匿名函数多用于实现回调函数和闭包
***** 闭包
+ 闭包指的是一个函数和与其相关的引用环境组合而成的实体。简单来说，闭包=函数+引用环境
  #+BEGIN_SRC go
  func adder() func(int) int {
      var x int
      return func(y int) int {
        x += y
        return x
      }
  }
  func main() {
      var f = adder()
      fmt.Println(f(10)) //10
      fmt.Println(f(20)) //30
      fmt.Println(f(30)) //60

      f1 := adder()
      fmt.Println(f1(40)) //40
      fmt.Println(f1(50)) //90
  }
  #+END_SRC

+ 变量f是一个函数并且它引用了其外部作用域中的x变量，此时f就是一个闭包。 在f的生命周期内，变量x也一直有效。 闭包进阶示例1
  #+BEGIN_SRC go
  func adder2(x int) func(int) int {
      return func(y int) int {
        x += y
        return x
      }
  }
  func main() {
      var f = adder2(10)
      fmt.Println(f(10)) //20
      fmt.Println(f(20)) //40
      fmt.Println(f(30)) //70

      f1 := adder2(20)
      fmt.Println(f1(40)) //60
      fmt.Println(f1(50)) //110
  }
  #+END_SRC
+ 闭包进阶示例2
  #+BEGIN_SRC go
  func makeSuffixFunc(suffix string) func(string) string {
      return func(name string) string {
        if !strings.HasSuffix(name, suffix) {
          return name + suffix
        }
        return name
      }
    }

  func main() {
      jpgFunc := makeSuffixFunc(".jpg")
      txtFunc := makeSuffixFunc(".txt")
      fmt.Println(jpgFunc("test")) //test.jpg
      fmt.Println(txtFunc("test")) //test.txt
  }
  #+END_SRC
+ 闭包进阶示例3
  #+BEGIN_SRC go
  func calc(base int) (func(int) int, func(int) int) {
      add := func(i int) int {
        base += i
        return base
      }

      sub := func(i int) int {
        base -= i
        return base
      }
      return add, sub
  }

  func main() {
      f1, f2 := calc(10)
      fmt.Println(f1(1), f2(2)) //11 9
      fmt.Println(f1(3), f2(4)) //12 8
      fmt.Println(f1(5), f2(6)) //13 7
  }
  #+END_SRC
**** defer语句
***** 基础
+ Go语言中的defer语句会将其后面跟随的语句进行延迟处理。在defer归属的函数即将返回时，将延迟处理的语句按defer定义的逆序进行执行，也就是说，先被defer的语句最后被执行，最后被defer的语句，最先被执行
  #+BEGIN_SRC go
  func main() {
      fmt.Println("start")
      defer fmt.Println(1)
      defer fmt.Println(2)
      defer fmt.Println(3)
      fmt.Println("end")
  }
  // 输出结果：
  start
  end
  3
  2
  1
  #+END_SRC
+ 由于defer语句延迟调用的特性，所以defer语句能非常方便的处理资源释放问题。比如：资源清理、文件关闭、解锁及记录时间等
***** defer执行时机
+ 在Go语言的函数中return语句在底层并不是原子操作，它分为给返回值赋值和RET指令两步。而defer语句执行的时机就在返回值赋值操作后，RET指令执行前[[file:pic/defer%E6%89%A7%E8%A1%8C%E6%97%B6%E6%9C%BA.png][图例]]
***** defer经典案例
+ 示例
  #+BEGIN_SRC go
  func f1() int {
      x := 5
      defer func() {
        x++
      }()
      return x
  }

  func f2() (x int) {
      defer func() {
        x++
      }()
      return 5
  }

  func f3() (y int) {
      x := 5
      defer func() {
        x++
      }()
      return x
  }
  func f4() (x int) {
      defer func(x int) {
        x++
      }(x)
      return 5
  }
  func main() {
      fmt.Println(f1())
      fmt.Println(f2())
      fmt.Println(f3())
      fmt.Println(f4())
  }
  #+END_SRC
**** 内置函数
+ 常用内置函数
  | 内置函数       | 介绍                                                            |
  |----------------+-----------------------------------------------------------------|
  | close          | 主要用来关闭channel                                             |
  | len            | 用来求长度，比如string、array、slice、map、channel              |
  | new            | 用来分配内存，主要用来分配值类型，比如int、struct。返回的是指针 |
  | make           | 用来分配内存，主要用来分配引用类型，比如chan、map、slice        |
  | append         | 用来追加元素到数组、slice中                                     |
  | panic和recover | 用来做错误处理                                                  |
+ panic/recover
  - Go语言中目前（Go1.12）是没有异常机制，但是使用panic/recover模式来处理错误。 panic可以在任何地方引发，但recover只有在defer调用的函数中有效
    #+BEGIN_SRC go
    func funcA() {
        fmt.Println("func A")
    }

    func funcB() {
        panic("panic in B")
    }

    func funcC() {
        fmt.Println("func C")
    }
    func main() {
        funcA()
        funcB()
        funcC()
    }
    // 输出：
    func A
    panic: panic in B

    goroutine 1 [running]:
    main.funcB(...)
        .../code/func/main.go:12
    main.main()
        .../code/func/main.go:20 +0x98
    #+END_SRC
  - 程序运行期间funcB中引发了panic导致程序崩溃，异常退出了。这个时候我们就可以通过recover将程序恢复回来，继续往后执行
    #+BEGIN_SRC go
    func funcA() {
        fmt.Println("func A")
    }

    func funcB() {
        defer func() {
          err := recover()
          //如果程序出出现了panic错误,可以通过recover恢复过来
          if err != nil {
            fmt.Println("recover in B")
          }
        }()
        panic("panic in B")
    }

    func funcC() {
        fmt.Println("func C")
    }
    func main() {
        funcA()
        funcB()
        funcC()
    }

    #+END_SRC
  - recover()必须搭配defer使用
  - defer一定要在可能引发panic的语句之前定义
*** 指针
**** Go语言中的指针
+ 任何程序数据载入内存后，在内存都有他们的地址，这就是指针。而为了保存一个数据在内存中的地址，我们就需要指针变量
+ 比如，“永远不要高估自己”这句话是我的座右铭，我想把它写入程序中，程序一启动这句话是要加载到内存（假设内存地址0x123456），我在程序中把这段话赋值给变量A，把内存地址赋值给变量B。这时候变量B就是一个指针变量。通过变量A和变量B都能找到我的座右铭
+ Go语言中的指针不能进行偏移和运算，因此Go语言中的指针操作非常简单，我们只需要记住两个符号：&（取地址）和*（根据地址取值）
**** 指针地址和指针类型
+ 每个变量在运行时都拥有一个地址，这个地址代表变量在内存中的位置。Go语言中使用&字符放在变量前面对变量进行“取地址”操作。 Go语言中的值类型（int、float、bool、string、array、struct）都有对应的指针类型，如：*int、*int64、*string等
+ 取变量指针的语法
  #+BEGIN_SRC go
  ptr := &v    // v的类型为T
  // v:代表被取地址的变量，类型为T
  // ptr:用于接收地址的变量，ptr的类型就为*T，称做T的指针类型。*代表指针

  func main() {
    	a := 10
	    b := &a
	    fmt.Printf("a:%d ptr:%p\n", a, &a) // a:10 ptr:0xc00001a078
	    fmt.Printf("b:%p type:%T\n", b, b) // b:0xc00001a078 type:*int
	    fmt.Println(&b)                    // 0xc00000e018
  }
  #+END_SRC
+ b := &a的[[file:pic/%E6%8C%87%E9%92%88%E5%9B%BE%E7%A4%BA.png][图例]]
**** 指针取值
+ 在对普通变量使用&操作符取地址后会获得这个变量的指针，然后可以对指针使用*操作，也就是指针取值
  #+BEGIN_SRC go
  func main() {
      //指针取值
      a := 10
      b := &a // 取变量a的地址，将指针保存到b中
      fmt.Printf("type of b:%T\n", b)
      c := *b // 指针取值（根据指针去内存取值）
      fmt.Printf("type of c:%T\n", c)
      fmt.Printf("value of c:%v\n", c)
  }
  // 输出如下
  type of b:*int
  type of c:int
  value of c:10
  #+END_SRC
+ 取地址操作符&和取值操作符*是一对互补操作符，&取出地址，*根据地址取出地址指向的值
+ 变量、指针地址、指针变量、取地址、取值的相互关系和特性如下
  - 对变量进行取地址（&）操作，可以获得这个变量的指针变量
  - 指针变量的值是指针地址
  - 对指针变量进行取值（*）操作，可以获得指针变量指向的原变量的值
+ 指针传值示例
  #+BEGIN_SRC go
  func modify1(x int) {
      x = 100
  }

  func modify2(x *int) {
      ,*x = 100
  }

  func main() {
      a := 10
      modify1(a)
      fmt.Println(a) // 10
      modify2(&a)
      fmt.Println(a) // 100
  }

  #+END_SRC
**** new和make
+ 执行下面的代码会引发panic，为什么呢？ 在Go语言中对于引用类型的变量，我们在使用的时候不仅要声明它，还要为它分配内存空间，否则我们的值就没办法存储。而对于值类型的声明不需要分配内存空间，是因为它们在声明的时候已经默认分配好了内存空间。要分配内存，就引出来今天的new和make。 Go语言中new和make是内建的两个函数，主要用来分配内存
  #+BEGIN_SRC go
  func main() {
      var a *int
      ,*a = 100
      fmt.Println(*a)

      var b map[string]int
      b["沙河娜扎"] = 100
      fmt.Println(b)
  }
  #+END_SRC
***** new
+ new是一个内置的函数，它的函数签名如下
  #+BEGIN_SRC go
  func new(Type) *Type
  // Type表示类型，new函数只接受一个参数，这个参数是一个类型
  // *Type表示类型指针，new函数返回一个指向该类型内存地址的指针。
  #+END_SRC
+ new函数不太常用，使用new函数得到的是一个类型的指针，并且该指针对应的值为该类型的零值
  #+BEGIN_SRC go
  func main() {
      a := new(int)
      b := new(bool)
      fmt.Printf("%T\n", a) // *int
      fmt.Printf("%T\n", b) // *bool
      fmt.Println(*a)       // 0
      fmt.Println(*b)       // false
  }	

  #+END_SRC
+ 示例代码中var a *int只是声明了一个指针变量a但是没有初始化，指针作为引用类型需要初始化后才会拥有内存空间，才可以给它赋值。应该按照如下方式使用内置的new函数对a进行初始化之后就可以正常对其赋值了
  #+BEGIN_SRC go
  func main() {
      var a *int
      a = new(int)
      ,*a = 10
      fmt.Println(*a)
    }

  #+END_SRC
***** make
+ make也是用于内存分配的，区别于new，它只用于slice、map以及chan的内存创建，而且它返回的类型就是这三个类型本身，而不是他们的指针类型，因为这三种类型就是引用类型，所以就没有必要返回他们的指针了。make函数的函数签名如下
  #+BEGIN_SRC go
  func make(t Type, size ...IntegerType) Type
  #+END_SRC
+ make函数是无可替代的，我们在使用slice、map以及channel的时候，都需要使用make进行初始化，然后才可以对它们进行操作
+ 示例中var b map[string]int只是声明变量b是一个map类型的变量，需要像下面的示例代码一样使用make函数进行初始化操作之后，才能对其进行键值对赋值
  #+BEGIN_SRC go
  func main() {
      var b map[string]int
      b = make(map[string]int, 10)
      b["沙河娜扎"] = 100
      fmt.Println(b)
  }
  #+END_SRC
***** new与make的区别
+ 二者都是用来做内存分配的
+ make只用于slice、map以及channel的初始化，返回的还是这三个引用类型本身
+ 而new用于类型的内存分配，并且内存对应的值为类型零值，返回的是指向类型的指针
*** 结构体（struct）
Go语言中没有“类”的概念，也不支持“类”的继承等面向对象的概念。Go语言中通过结构体的内嵌再配合接口比面向对象具有更高的扩展性和灵活性
**** 类型别名和自定义类型
***** 自定义类型
+ 在Go语言中有一些基本的数据类型，如string、整型、浮点型、布尔等数据类型， Go语言中可以使用type关键字来定义自定义类型
+ 自定义类型是定义了一个全新的类型。我们可以基于内置的基本类型定义，也可以通过struct定义
  #+BEGIN_SRC go
  //将MyInt定义为int类型
  type MyInt int
  // 通过type关键字的定义，MyInt就是一种新的类型，它具有int的特性
  #+END_SRC
***** 类型别名
+ 类型别名规定：TypeAlias只是Type的别名，本质上TypeAlias与Type是同一个类型。就像一个孩子小时候有小名
  #+BEGIN_SRC go
  type TypeAlias = Type

  type byte = uint8
  type rune = int32
  #+END_SRC
***** 自定义类型和类型别名的区别
+ 类型别名与自定义类型表面上看只有一个等号的差异，我们通过下面的这段代码来理解它们之间的区别
  #+BEGIN_SRC go
  //自定义类型
  type NewInt int

  //类型别名
  type MyInt = int

  func main() {
      var a NewInt
      var b MyInt
	
      fmt.Printf("type of a:%T\n", a) //type of a:main.NewInt
      fmt.Printf("type of b:%T\n", b) //type of b:int
  }

  #+END_SRC
**** 结构体
Go语言中的基础数据类型可以表示一些事物的基本属性，但是当我们想表达一个事物的全部或部分属性时，这时候再用单一的基本数据类型明显就无法满足需求了，Go语言提供了一种自定义数据类型，可以封装多个基本数据类型，这种数据类型叫结构体，英文名称struct。 也就是我们可以通过struct来定义自己的类型
***** 结构体的定义
+ 使用type和struct关键字来定义结构体
  #+BEGIN_SRC go
  type 类型名 struct {
        字段名 字段类型
        字段名 字段类型
        …
  }
  #+END_SRC
  - 类型名：标识自定义结构体的名称，在同一个包内不能重复
  - 字段名：表示结构体字段名。结构体中的字段名必须唯一
  - 字段类型：表示结构体字段的具体类型
+ 示例，我们定义一个Person（人）结构体
  #+BEGIN_SRC go
  type person struct {
	    name string
	    city string
	    age  int8
  }
  // 同样类型的字段也可以写在一行
  type person1 struct {
	    name, city string
	    age        int8
  }
  // 这样我们就拥有了一个person的自定义类型，它有name、city、age三个字段，分别表示姓名、城市和年龄。这样我们使用这个person结构体就能够很方便的在程序中表示和存储人信息了
  #+END_SRC
***** 结构体实例化
+ 只有当结构体实例化时，才会真正地分配内存。也就是必须实例化后才能使用结构体的字段
+ 结构体本身也是一种类型，我们可以像声明内置类型一样使用var关键字声明结构体类型
  #+BEGIN_SRC go
  var 结构体实例 结构体类型
  #+END_SRC
****** 基本实例化
+ 示例
  #+BEGIN_SRC go
  type person struct {
      name string
      city string
      age  int8
  }

  func main() {
      var p1 person
      p1.name = "沙河娜扎"
      p1.city = "北京"
      p1.age = 18
      fmt.Printf("p1=%v\n", p1)  //p1={沙河娜扎 北京 18}
      fmt.Printf("p1=%#v\n", p1) //p1=main.person{name:"沙河娜扎", city:"北京", age:18}
  }

  #+END_SRC
****** 匿名结构体
+ 在定义一些临时数据结构等场景下还可以使用匿名结构体
  #+BEGIN_SRC go
  package main
     
  import (
        "fmt"
  )
     
  func main() {
        var user struct{Name string; Age int}
        user.Name = "小王子"
        user.Age = 18
        fmt.Printf("%#v\n", user)
  }

  #+END_SRC
****** 创建指针类型结构体
+ 可以通过使用new关键字对结构体进行实例化，得到的是结构体的地址
  #+BEGIN_SRC go
  var p2 = new(person)
  fmt.Printf("%T\n", p2)     //*main.person
  fmt.Printf("p2=%#v\n", p2) //p2=&main.person{name:"", city:"", age:0}
  #+END_SRC
+ 在Go语言中支持对结构体指针直接使用.来访问结构体的成员
  #+BEGIN_SRC go
  var p2 = new(person)
  p2.name = "小王子"
  p2.age = 28
  p2.city = "上海"
  fmt.Printf("p2=%#v\n", p2) //p2=&main.person{name:"小王子", city:"上海", age:28}
  #+END_SRC
****** 取结构体的地址实化例
+ 使用&对结构体进行取地址操作相当于对该结构体类型进行了一次new实例化操作
  #+BEGIN_SRC go
  p3 := &person{}
  fmt.Printf("%T\n", p3)     //*main.person
  fmt.Printf("p3=%#v\n", p3) //p3=&main.person{name:"", city:"", age:0}
  p3.name = "七米"
  p3.age = 30
  p3.city = "成都"
  fmt.Printf("p3=%#v\n", p3) //p3=&main.person{name:"七米", city:"成都", age:30}
  // p3.name = "七米"其实在底层是(*p3).name = "七米"，这是Go语言帮我们实现的语法糖
  #+END_SRC
****** 结构体初始化
+ 没有初始化的结构体，其成员变量都是对应其类型的零值
  #+BEGIN_SRC go
  type person struct {
      name string
      city string
      age  int8
  }

  func main() {
      var p4 person
      fmt.Printf("p4=%#v\n", p4) //p4=main.person{name:"", city:"", age:0}
  }

  #+END_SRC
****** 使用键值对初始化
+ 使用键值对对结构体进行初始化时，键对应结构体的字段，值对应该字段的初始值
  #+BEGIN_SRC go
  p5 := person{
	    name: "小王子",
	    city: "北京",
	    age:  18,
      }
  fmt.Printf("p5=%#v\n", p5) //p5=main.person{name:"小王子", city:"北京", age:18}
  #+END_SRC
+ 也可以对结构体指针进行键值对初始化
  #+BEGIN_SRC go
  p6 := &person{
	    name: "小王子",
	    city: "北京",
	    age:  18,
      }
  fmt.Printf("p6=%#v\n", p6) //p6=&main.person{name:"小王子", city:"北京", age:18}
  #+END_SRC
+ 当某些字段没有初始值的时候，该字段可以不写。此时，没有指定初始值的字段的值就是该字段类型的零值
  #+BEGIN_SRC go
  p7 := &person{
	    city: "北京",
      }
  fmt.Printf("p7=%#v\n", p7) //p7=&main.person{name:"", city:"北京", age:0}
  #+END_SRC
****** 使用值的列表初始化
+ 初始化结构体的时候可以简写，也就是初始化的时候不写键，直接写值
  #+BEGIN_SRC go
  p8 := &person{
	    "沙河娜扎",
	    "北京",
	    28,
      }
  fmt.Printf("p8=%#v\n", p8) //p8=&main.person{name:"沙河娜扎", city:"北京", age:28}
  #+END_SRC
+ 使用这种格式初始化时，注意
  - 必须初始化结构体的所有字段
  - 初始值的填充顺序必须与字段在结构体中的声明顺序一致
  - 该方式不能和键值初始化方式混用
****** 结构体内存布局
+ 结构体占用一块连续的内存
  #+BEGIN_SRC go
  type test struct {
	    a int8
	    b int8
	    c int8
	    d int8
      }
  n := test{
    	1, 2, 3, 4,
  }
  fmt.Printf("n.a %p\n", &n.a)
  fmt.Printf("n.b %p\n", &n.b)
  fmt.Printf("n.c %p\n", &n.c)
  fmt.Printf("n.d %p\n", &n.d)
  // 输出：
  n.a 0xc0000a0060
  n.b 0xc0000a0061
  n.c 0xc0000a0062
  n.d 0xc0000a0063
  #+END_SRC
****** 空结构体
+ 空结构体是不占用空间的
  #+BEGIN_SRC go
  var v struct{}
  fmt.Println(unsafe.Sizeof(v))  // 0
  #+END_SRC
****** 构造函数
+ Go语言的结构体没有构造函数，我们可以自己实现。 例如，下方的代码就实现了一个person的构造函数。 因为struct是值类型，如果结构体比较复杂的话，值拷贝性能开销会比较大，所以该构造函数返回的是结构体指针类型
  #+BEGIN_SRC go
  func newPerson(name, city string, age int8) *person {
      return &person{
        name: name,
        city: city,
        age:  age,
      }
  }

  #+END_SRC
+ 调用构造函数
  #+BEGIN_SRC go
  p9 := newPerson("张三", "沙河", 90)
  fmt.Printf("%#v\n", p9) //&main.person{name:"张三", city:"沙河", age:90}
  #+END_SRC
***** 方法和接收者
****** 方法
+ Go语言中的方法（Method）是一种作用于特定类型变量的函数。这种特定类型变量叫做接收者（Receiver）。接收者的概念就类似于其他语言中的this或者 self
+ 方法的定义格式如下
  #+BEGIN_SRC go
  func (接收者变量 接收者类型) 方法名(参数列表) (返回参数) {
      函数体
  }
  #+END_SRC
+ 接收者变量：接收者中的参数变量名在命名时，官方建议使用接收者类型名称首字母的小写，而不是self、this之类的命名。例如，Person类型的接收者变量应该命名为 p，Connector类型的接收者变量应该命名为c等
+ 接收者类型：接收者类型和参数类似，可以是指针类型和非指针类型
+ 方法名、参数列表、返回参数：具体格式与函数定义相同
+ 方法与函数的区别是，函数不属于任何类型，方法属于特定的类型
+ 示例
  #+BEGIN_SRC go
  //Person 结构体
  type Person struct {
      name string
      age  int8
  }

  //NewPerson 构造函数
  func NewPerson(name string, age int8) *Person {
      return &Person{
        name: name,
        age:  age,
      }
  }

  //Dream Person做梦的方法
  func (p Person) Dream() {
      fmt.Printf("%s的梦想是学好Go语言！\n", p.name)
  }

  func main() {
      p1 := NewPerson("小王子", 25)
      p1.Dream()
  }

  #+END_SRC
****** 指针类型的接收者
+ 指针类型的接收者由一个结构体的指针组成，由于指针的特性，调用方法时修改接收者指针的任意成员变量，在方法结束后，修改都是有效的。这种方式就十分接近于其他语言中面向对象中的this或者self。 例如我们为Person添加一个SetAge方法，来修改实例变量的年龄
  #+BEGIN_SRC go
  // SetAge 设置p的年龄
  // 使用指针接收者
  func (p *Person) SetAge(newAge int8) {
	    p.age = newAge
  }
  
  // 调用
  func main() {
    	p1 := NewPerson("小王子", 25)
	    fmt.Println(p1.age) // 25
	    p1.SetAge(30)
	    fmt.Println(p1.age) // 30
  }
  #+END_SRC
****** 值类型的接收者
+ 当方法作用于值类型接收者时，Go语言会在代码运行时将接收者的值复制一份。在值类型接收者的方法中可以获取接收者的成员值，但修改操作只是针对副本，无法修改接收者变量本身
  #+BEGIN_SRC go
  // SetAge2 设置p的年龄
  // 使用值接收者
  func (p Person) SetAge2(newAge int8) {
      p.age = newAge
  }

  func main() {
      p1 := NewPerson("小王子", 25)
      p1.Dream()
      fmt.Println(p1.age) // 25
      p1.SetAge2(30) // (*p1).SetAge2(30)
      fmt.Println(p1.age) // 25
  }

  #+END_SRC
****** 什么时候应该使用指针类型接收者
+ 要修改接收者中的值
+ 接收者是拷贝代价比较大的大对象
+ 保证一致性，如果有某个方法使用了指针接收者，那么其他的方法也应该使用指针接收者
****** 任意类型添加方法
+ 在Go语言中，接收者的类型可以是任何类型，不仅仅是结构体，任何类型都可以拥有方法。 举个例子，我们基于内置的int类型使用type关键字可以定义新的自定义类型，然后为我们的自定义类型添加方法
  #+BEGIN_SRC go
  //MyInt 将int定义为自定义MyInt类型
  type MyInt int

  //SayHello 为MyInt添加一个SayHello的方法
  func (m MyInt) SayHello() {
      fmt.Println("Hello, 我是一个int。")
  }
  func main() {
      var m1 MyInt
      m1.SayHello() //Hello, 我是一个int。
      m1 = 100
      fmt.Printf("%#v  %T\n", m1, m1) //100  main.MyInt
  }

  #+END_SRC

+ 非本地类型不能定义方法，也就是说我们不能给别的包的类型定义方法
***** 结构体的匿名字段
+ 结构体允许其成员字段在声明时没有字段名而只有类型，这种没有名字的字段就称为匿名字段
+ 匿名字段默认采用类型名作为字段名，结构体要求字段名称必须唯一，因此一个结构体中同种类型的匿名字段只能有一个
  #+BEGIN_SRC go
  //Person 结构体Person类型
  type Person struct {
      string
      int
  }

  func main() {
      p1 := Person{
        "小王子",
        18,
      }
      fmt.Printf("%#v\n", p1)        //main.Person{string:"北京", int:18}
      fmt.Println(p1.string, p1.int) //北京 18
  }

  #+END_SRC
***** 嵌套结构体
+ 一个结构体中可以嵌套包含另一个结构体或结构体指针
  #+BEGIN_SRC go
  //Address 地址结构体
  type Address struct {
      Province string
      City     string
  }

  //User 用户结构体
  type User struct {
      Name    string
      Gender  string
      Address Address
  }

  func main() {
      user1 := User{
        Name:   "小王子",
        Gender: "男",
        Address: Address{
          Province: "山东",
          City:     "威海",
        },
      }
      fmt.Printf("user1=%#v\n", user1)//user1=main.User{Name:"小王子", Gender:"男", Address:main.Address{Province:"山东", City:"威海"}}
  }
  #+END_SRC
***** 嵌套匿名结构体
+ 当访问结构体成员时会先在结构体中查找该字段，找不到再去匿名结构体中查找
  #+BEGIN_SRC go
  //Address 地址结构体
  type Address struct {
      Province string
      City     string
  }

  //User 用户结构体
  type User struct {
      Name    string
      Gender  string
      Address //匿名结构体
  }

  func main() {
      var user2 User
      user2.Name = "小王子"
      user2.Gender = "男"
      user2.Address.Province = "山东"    //通过匿名结构体.字段名访问
      user2.City = "威海"                //直接访问匿名结构体的字段名
      fmt.Printf("user2=%#v\n", user2) //user2=main.User{Name:"小王子", Gender:"男", Address:main.Address{Province:"山东", City:"威海"}}
  }

  #+END_SRC
***** 嵌套结构体的字段名冲突
+ 嵌套结构体内部可能存在相同的字段名。这个时候为了避免歧义需要指定具体的内嵌结构体的字段
  #+BEGIN_SRC go
  //Address 地址结构体
  type Address struct {
      Province   string
      City       string
      CreateTime string
  }

  //Email 邮箱结构体
  type Email struct {
      Account    string
      CreateTime string
  }

  //User 用户结构体
  type User struct {
      Name   string
      Gender string
      Address
      Email
  }

  func main() {
      var user3 User
      user3.Name = "沙河娜扎"
      user3.Gender = "男"
      // user3.CreateTime = "2019" //ambiguous selector user3.CreateTime
      user3.Address.CreateTime = "2000" //指定Address结构体中的CreateTime
      user3.Email.CreateTime = "2000"   //指定Email结构体中的CreateTime
  }

  #+END_SRC
***** 结构体的“继承”
+ Go语言中使用结构体也可以实现其他编程语言中面向对象的继承
  #+BEGIN_SRC go
  //Animal 动物
  type Animal struct {
      name string
  }

  func (a *Animal) move() {
      fmt.Printf("%s会动！\n", a.name)
  }

  //Dog 狗
  type Dog struct {
      Feet    int8
      ,*Animal //通过嵌套匿名结构体实现继承
  }

  func (d *Dog) wang() {
      fmt.Printf("%s会汪汪汪~\n", d.name)
  }

  func main() {
      d1 := &Dog{
        Feet: 4,
        Animal: &Animal{ //注意嵌套的是结构体指针
          name: "乐乐",
        },
      }
      d1.wang() //乐乐会汪汪汪~
      d1.move() //乐乐会动！
  }

  #+END_SRC
***** 结构体字段的可见性
+ 结构体中字段大写开头表示可公开访问，小写表示私有（仅在定义当前结构体的包中可访问）
***** 结构体与JSON序列化
+ JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。易于人阅读和编写。同时也易于机器解析和生成。JSON键值对是用来保存JS对象的一种方式，键/值对组合中的键名写在前面并用双引号""包裹，使用冒号:分隔，然后紧接着值；多个键值之间使用英文,分隔
  #+BEGIN_SRC go
  //Student 学生
  type Student struct {
      ID     int
      Gender string
      Name   string
  }

  //Class 班级
  type Class struct {
      Title    string
      Students []*Student
  }

  func main() {
      c := &Class{
        Title:    "101",
        Students: make([]*Student, 0, 200),
      }
      for i := 0; i < 10; i++ {
        stu := &Student{
          Name:   fmt.Sprintf("stu%02d", i),
          Gender: "男",
          ID:     i,
        }
        c.Students = append(c.Students, stu)
      }
      //JSON序列化：结构体-->JSON格式的字符串
      data, err := json.Marshal(c)
      if err != nil {
        fmt.Println("json marshal failed")
        return
      }
      fmt.Printf("json:%s\n", data)
      //JSON反序列化：JSON格式的字符串-->结构体
      str := `{"Title":"101","Students":[{"ID":0,"Gender":"男","Name":"stu00"},{"ID":1,"Gender":"男","Name":"stu01"},{"ID":2,"Gender":"男","Name":"stu02"},{"ID":3,"Gender":"男","Name":"stu03"},{"ID":4,"Gender":"男","Name":"stu04"},{"ID":5,"Gender":"男","Name":"stu05"},{"ID":6,"Gender":"男","Name":"stu06"},{"ID":7,"Gender":"男","Name":"stu07"},{"ID":8,"Gender":"男","Name":"stu08"},{"ID":9,"Gender":"男","Name":"stu09"}]}`
      c1 := &Class{}
      err = json.Unmarshal([]byte(str), c1)
      if err != nil {
        fmt.Println("json unmarshal failed!")
        return
      }
      fmt.Printf("%#v\n", c1)
  }

  #+END_SRC
***** 结构体标签（Tag）
+ Tag是结构体的元信息，可以在运行的时候通过反射的机制读取出来。 Tag在结构体字段的后方定义，由一对反引号包裹起来，具体的格式如下
  #+BEGIN_SRC go
  `key1:"value1" key2:"value2"`
  #+END_SRC
+ 结构体标签由一个或多个键值对组成。键与值使用冒号分隔，值用双引号括起来。同一个结构体字段可以设置多个键值对标签（Tag），不同的键值对标签之间使用空格分隔
+ 为结构体编写Tag时，必须严格遵守键值对的规则。结构体标签的解析代码的容错能力很差，一旦格式写错，编译和运行时都不会提示任何错误，通过反射也无法正确取值。例如不要在key和value之间添加空格
+ 例如我们为Student结构体的每个字段定义json序列化时使用的Tag
  #+BEGIN_SRC go
  //Student 学生
  type Student struct {
      ID     int    `json:"id"` //通过指定tag实现json序列化该字段时的key
      Gender string //json序列化是默认使用字段名作为key
      name   string //私有不能被json包访问
  }

  func main() {
      s1 := Student{
        ID:     1,
        Gender: "男",
        name:   "沙河娜扎",
      }
      data, err := json.Marshal(s1)
      if err != nil {
        fmt.Println("json marshal failed!")
        return
      }
      fmt.Printf("json str:%s\n", data) //json str:{"id":1,"Gender":"男"}
  }

  #+END_SRC
***** 结构体和方法补充知识点
+ 因为slice和map这两种数据类型都包含了指向底层数据的指针，因此我们在需要复制它们时要特别注意
  #+BEGIN_SRC go
  type Person struct {
      name   string
      age    int8
      dreams []string
  }

  func (p *Person) SetDreams(dreams []string) {
      p.dreams = dreams
    }

    func main() {
      p1 := Person{name: "小王子", age: 18}
      data := []string{"吃饭", "睡觉", "打豆豆"}
      p1.SetDreams(data)

      // 你真的想要修改 p1.dreams 吗？
      data[1] = "不睡觉"
      fmt.Println(p1.dreams)  // ?
  }
  // 正确的做法是在方法中使用传入的slice的拷贝进行结构体赋值
  func (p *Person) SetDreams(dreams []string) {
	    p.dreams = make([]string, len(dreams))
	    copy(p.dreams, dreams)
  }
  // 同样的问题也存在于返回值slice和map的情况，在实际编码过程中一定要注意这个问题
  #+END_SRC
*** 包（package）
**** 介绍
+ 在工程化的Go语言开发项目中，Go语言的源码复用是建立在包（package）基础之上的
+ 包（package）是多个Go源码的集合，是一种高级的代码复用方案，Go语言为我们提供了很多内置包，如fmt、os、io等
**** 定义包
+ 可以根据自己的需要创建自己的包。一个包可以简单理解为一个存放.go文件的文件夹。 该文件夹下面的所有go文件都要在代码的第一行添加如下代码，声明该文件归属的包
  #+BEGIN_SRC go
  package 包名
  #+END_SRC
+ 一个文件夹下面直接包含的文件只能归属一个package，同样一个package的文件不能在多个文件夹下
+ 包名可以不和文件夹的名字一样，包名不能包含 - 符号
+ 包名为main的包为应用程序的入口包，这种包编译后会得到一个可执行文件，而编译不包含main包的源代码则不会得到可执行文件
**** 可见性
+ 如果想在一个包中引用另外一个包里的标识符（如变量、常量、类型、函数等）时，该标识符必须是对外可见的（public）。在Go语言中只需要将标识符的首字母大写就可以让标识符对外可见
  #+BEGIN_SRC go
  package pkg2

  import "fmt"

  // 包变量可见性

  var a = 100 // 首字母小写，外部包不可见，只能在当前包内使用

  // 首字母大写外部包可见，可在其他包中使用
  const Mode = 1
  
  type person struct { // 首字母小写，外部包不可见，只能在当前包内使用
      name string
  }

  // 首字母大写，外部包可见，可在其他包中使用
  func Add(x, y int) int {
      return x + y
  }

  func age() { // 首字母小写，外部包不可见，只能在当前包内使用
      var Age = 18 // 函数局部变量，外部包不可见，只能在当前函数内使用
      fmt.Println(Age)
  }

  #+END_SRC

+ 结构体中的字段名和接口中的方法名如果首字母都是大写，外部包可以访问这些字段和方法
  #+BEGIN_SRC go
  type Student struct {
      Name  string //可在包外访问的方法
      class string //仅限包内访问的字段
  }

  type Payer interface {
      init() //仅限包内访问的方法
      Pay()  //可在包外访问的方法
  }

  #+END_SRC
**** 导入
+ 要在代码中引用其他包的内容，需要使用import关键字导入使用的包
  #+BEGIN_SRC go
  import "包的路径"
  #+END_SRC
+ 注意事项
  - import导入语句通常放在文件开头包声明语句的下面
  - 导入的包名需要使用双引号包裹起来
  - 包名是从$GOPATH/src/后开始计算的，使用/进行路径分隔
  - Go语言中禁止循环导入包
+ 单行导入
  #+BEGIN_SRC go
  import "包1"
  import "包2"
  #+END_SRC
+ 多行导入
  #+BEGIN_SRC go
  import (
      "包1"
      "包2"
  )
  #+END_SRC
+ 自定义包名
  - 在导入包名的时候，我们还可以为导入的包设置别名。通常用于导入的包名太长或者导入的包名冲突的情况
    #+BEGIN_SRC go
    import 别名 "包的路径"
    #+END_SRC
  - 单行导入方式定义别名
    #+BEGIN_SRC go
    import "fmt"
    import m "github.com/Q1mi/studygo/pkg_test"

    func main() {
        fmt.Println(m.Add(100, 200))
        fmt.Println(m.Mode)
    }

    #+END_SRC
  - 多行导入方式定义别名
    #+BEGIN_SRC go
    import (
          "fmt"
          m "github.com/Q1mi/studygo/pkg_test"
    )

    func main() {
        fmt.Println(m.Add(100, 200))
        fmt.Println(m.Mode)
    }

    #+END_SRC
+ 匿名导入包
  - 如果只希望导入包，而不使用包内部的数据时，可以使用匿名导入包
    #+BEGIN_SRC go
    import _ "包的路径"
    #+END_SRC
  - 匿名导入的包与其他方式导入的包一样都会被编译到可执行文件中
**** init()初始化函数
+ 介绍
  - 在Go语言程序执行时导入包语句会自动触发包内部init()函数的调用。需要注意的是： init()函数没有参数也没有返回值。 init()函数在程序运行时自动被调用执行，不能在代码中主动调用它
  - 包初始化执行的顺序[[file:pic/%E5%8C%85init%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E6%97%B6%E6%9C%BA.png][图例]]
+ init()函数执行顺序
  - Go语言包会从main包开始检查其导入的所有包，每个包中又可能导入了其他的包。Go编译器由此构建出一个树状的包引用关系，再根据引用顺序决定编译顺序，依次编译这些包的代码
  - 在运行时，被最后导入的包会最先初始化并调用其init()函数[[file:pic/%E5%AF%BC%E5%85%A5%E5%8C%85%E9%A1%BA%E5%BA%8F.png][图例]]
*** 接口（interface）
接口定义了一个对象的行为规范，只定义规范不实现，由具体的对象来实现规范的细节,关于接口需要注意的是，只有当有两个或两个以上的具体类型必须以相同的方式进行处理时才需要定义接口。不要为了接口而写接口，那样只会增加不必要的抽象，导致不必要的运行时损耗
**** 接口类型
+ 在Go语言中接口（interface）是一种类型，一种抽象的类型
+ 接口是一组method的集合，是duck-type programming的一种体现。接口做的事情就像是定义一个协议（规则），只要一台机器有洗衣服和甩干的功能，我就称它为洗衣机。不关心属性（数据），只关心行为（方法）
**** 为什么要使用接口
+ 下面的代码中定义了猫和狗，然后它们都会叫，你会发现main函数中明显有重复的代码，如果我们后续再加上猪、青蛙等动物的话，我们的代码还会一直重复下去。那我们能不能把它们当成“能叫的动物”来处理呢？比如销售、行政、程序员都能计算月薪，我们能不能把他们当成“员工”来处理呢？
  #+BEGIN_SRC go
  type Cat struct{}

  func (c Cat) Say() string { return "喵喵喵" }
  
  type Dog struct{}

  func (d Dog) Say() string { return "汪汪汪" }

  func main() {
      c := Cat{}
      fmt.Println("猫:", c.Say())
      d := Dog{}
      fmt.Println("狗:", d.Say())
  }
  #+END_SRC
+ Go语言中为了解决类似上面的问题，就设计了接口这个概念。接口区别于我们之前所有的具体类型，接口是一种抽象的类型。当你看到一个接口类型的值时，你不知道它是什么，唯一知道的是通过它的方法能做什么
**** 定义
+ Go语言提倡面向接口编程
+ 每个接口由数个方法组成，接口的定义格式如下
  #+BEGIN_SRC go
  type 接口类型名 interface{
      方法名1( 参数列表1 ) 返回值列表1
      方法名2( 参数列表2 ) 返回值列表2
      …
  }
  #+END_SRC
+ 接口名：使用type将接口定义为自定义的类型名。Go语言的接口在命名时，一般会在单词后面添加er，如有写操作的接口叫Writer，有字符串功能的接口叫Stringer等。接口名最好要能突出该接口的类型含义
+ 方法名：当方法名首字母是大写且这个接口类型名首字母也是大写时，这个方法可以被接口所在的包（package）之外的代码访问
+ 参数列表、返回值列表：参数列表和返回值列表中的参数变量名可以省略
+ 当看到这个接口类型的值时，你不知道它是什么，唯一知道的就是可以通过它的Write方法来做一些事情
  #+BEGIN_SRC go
  type writer interface{
      Write([]byte) error
  }
  #+END_SRC
**** 实现接口的条件
+ 一个对象只要全部实现了接口中的方法，那么就实现了这个接口。换句话说，接口就是一个需要实现的方法列表
+ 例如定义一个Sayer接口
  #+BEGIN_SRC go
  // Sayer 接口
  type Sayer interface {
	    say()
  }
  #+END_SRC
+ 定义dog和cat两个结构体
  #+BEGIN_SRC go
  type dog struct {}

  type cat struct {}
  #+END_SRC
+ 因为Sayer接口里只有一个say方法，所以我们只需要给dog和cat 分别实现say方法就可以实现Sayer接口了
  #+BEGIN_SRC go
  // dog实现了Sayer接口
  func (d dog) say() {
	    fmt.Println("汪汪汪")
  }

  // cat实现了Sayer接口
  func (c cat) say() {
	    fmt.Println("喵喵喵")
  }
  #+END_SRC
**** 接口类型变量
+ 接口类型变量能够存储所有实现了该接口的实例。 例如上面的示例中，Sayer类型的变量能够存储dog和cat类型的变量
  #+BEGIN_SRC go
  func main() {
      var x Sayer // 声明一个Sayer类型的变量x
      a := cat{}  // 实例化一个cat
      b := dog{}  // 实例化一个dog
      x = a       // 可以把cat实例直接赋值给x
      x.say()     // 喵喵喵
      x = b       // 可以把dog实例直接赋值给x
      x.say()     // 汪汪汪
  }
  #+END_SRC
**** 值接收者和指针接收者实现接口的区别
+ 有一个Mover接口和一个dog结构体
  #+BEGIN_SRC go
  type Mover interface {
	    move()
  }

  type dog struct {}
  #+END_SRC
+ 值接收者实现接口
  #+BEGIN_SRC go
  func (d dog) move() {
    	fmt.Println("狗会动")
  }
  // 此时实现接口的是dog类型

  func main() {
    	var x Mover
	    var wangcai = dog{} // 旺财是dog类型
	    x = wangcai         // x可以接收dog类型
	    var fugui = &dog{}  // 富贵是*dog类型
	    x = fugui           // x可以接收*dog类型
	    x.move()
  }
  // 使用值接收者实现接口之后，不管是dog结构体还是结构体指针*dog类型的变量都可以赋值给该接口变量。因为Go语言中有对指针类型变量求值的语法糖，dog指针fugui内部会自动求值*fugui
  #+END_SRC
+ 指针接收者实现接口
  #+BEGIN_SRC go
  func (d *dog) move() {
      fmt.Println("狗会动")
  }
  func main() {
      var x Mover
      var wangcai = dog{} // 旺财是dog类型
      x = wangcai         // x不可以接收dog类型
      var fugui = &dog{}  // 富贵是*dog类型
      x = fugui           // x可以接收*dog类型
  }
  // 此时实现Mover接口的是*dog类型，所以不能给x传入dog类型的wangcai，此时x只能存储*dog类型的值
  #+END_SRC
**** 类型与接口的关系
***** 一个类型实现多个接口
+ 一个类型可以同时实现多个接口，而接口间彼此独立，不知道对方的实现。 例如，狗可以叫，也可以动。我们就分别定义Sayer接口和Mover接口，如下： Mover接口
  #+BEGIN_SRC go
  // Sayer 接口
  type Sayer interface {
      say()
  }

  // Mover 接口
  type Mover interface {
      move()
  }
  
  // dog既可以实现Sayer接口，也可以实现Mover接口
  type dog struct {
	    name string
  }

  // 实现Sayer接口
  func (d dog) say() {
	    fmt.Printf("%s会叫汪汪汪\n", d.name)
  }

  // 实现Mover接口
  func (d dog) move() {
	    fmt.Printf("%s会动\n", d.name)
  }

  func main() {
	    var x Sayer
	    var y Mover

	    var a = dog{name: "旺财"}
	    x = a
	    y = a
	    x.say()
	    y.move()
  }
  #+END_SRC
***** 多个类型实现同一接口
+ Go语言中不同的类型还可以实现同一接口 首先我们定义一个Mover接口，它要求必须由一个move方法
  #+BEGIN_SRC go
  // Mover 接口
  type Mover interface {
	    move()
  }
  
  // 例如狗可以动，汽车也可以动，可以使用如下代码实现这个关系
  type dog struct {
	    name string
  }

  type car struct {
	    brand string
  }

  // dog类型实现Mover接口
  func (d dog) move() {
	    fmt.Printf("%s会跑\n", d.name)
  }

  // car类型实现Mover接口
  func (c car) move() {
	    fmt.Printf("%s速度70迈\n", c.brand)
  }

  // 这个时候我们在代码中就可以把狗和汽车当成一个会动的物体来处理了，不再需要关注它们具体是什么，只需要调用它们的move方法就可以了
  func main() {
	    var x Mover
	    var a = dog{name: "旺财"}
	    var b = car{brand: "保时捷"}
	    x = a
	    x.move()
	    x = b
	    x.move()
  }
  // 输出
  // 旺财会跑
  // 保时捷速度70迈
  #+END_SRC
+ 一个接口的方法，不一定需要由一个类型完全实现，接口的方法可以通过在类型中嵌入其他类型或者结构体来实现
  #+BEGIN_SRC go
  // WashingMachine 洗衣机
  type WashingMachine interface {
      wash()
      dry()
  }

  // 甩干器
  type dryer struct{}

  // 实现WashingMachine接口的dry()方法
  func (d dryer) dry() {
      fmt.Println("甩一甩")
  }

  // 海尔洗衣机
  type haier struct {
      dryer //嵌入甩干器
  }

  // 实现WashingMachine接口的wash()方法
  func (h haier) wash() {
      fmt.Println("洗刷刷")
  }

  #+END_SRC
**** 接口嵌套
+ 接口与接口间可以通过嵌套创造出新的接口
  #+BEGIN_SRC go
  // Sayer 接口
  type Sayer interface {
      say()
  }

  // Mover 接口
  type Mover interface {
      move()
  }

  // 接口嵌套
  type animal interface {
      Sayer
      Mover
  }
  #+END_SRC
+ 嵌套得到的接口的使用与普通接口一样，这里我们让cat实现animal接口
  #+BEGIN_SRC go
  type cat struct {
      name string
  }

  func (c cat) say() {
      fmt.Println("喵喵喵")
  }

  func (c cat) move() {
      fmt.Println("猫会动")
  }

  func main() {
      var x animal
      x = cat{name: "花花"}
      x.move()
      x.say()
  }

  #+END_SRC
**** 空接口
***** 定义
+ 空接口是指没有定义任何方法的接口。因此任何类型都实现了空接口
+ 空接口类型的变量可以存储任意类型的变量
+ 因为空接口可以存储任意类型值的特点，所以空接口在Go语言中的使用十分广泛
  #+BEGIN_SRC go
  func main() {
      // 定义一个空接口x
      var x interface{}
      s := "Hello 沙河"
      x = s
      fmt.Printf("type:%T value:%v\n", x, x)
      i := 100
      x = i
      fmt.Printf("type:%T value:%v\n", x, x)
      b := true
      x = b
      fmt.Printf("type:%T value:%v\n", x, x)
  }
  #+END_SRC
***** 应用
+ 空接口作为函数的参数,使用空接口实现可以接收任意类型的函数参数
  #+BEGIN_SRC go
  // 空接口作为函数参数
  func show(a interface{}) {
	    fmt.Printf("type:%T value:%v\n", a, a)
  }
  #+END_SRC
+ 空接口作为map的值,使用空接口实现可以保存任意值的字典
  #+BEGIN_SRC go
  // 空接口作为map值
	var studentInfo = make(map[string]interface{})
	studentInfo["name"] = "沙河娜扎"
	studentInfo["age"] = 18
	studentInfo["married"] = false
	fmt.Println(studentInfo)
  #+END_SRC
**** 类型断言
空接口可以存储任意类型的值，那我们如何获取其存储的具体数据呢
***** 接口值
+ 一个接口的值（简称接口值）是由一个具体类型和具体类型的值两部分组成的。这两部分分别称为接口的动态类型和动态值
  #+BEGIN_SRC go
  var w io.Writer
  w = os.Stdout
  w = new(bytes.Buffer)
  w = nil
  #+END_SRC
+ 判断空接口中的值这个时候就可以使用类型断言，其语法格式
  #+BEGIN_SRC go
  x.(T)

  // x：表示类型为interface{}的变量
  // T：表示断言x可能是的类型。
  #+END_SRC
+ 该语法返回两个参数，第一个参数是x转化为T类型后的变量，第二个值是一个布尔值，若为true则表示断言成功，为false则表示断言失败
  #+BEGIN_SRC go
  func main() {
      var x interface{}
      x = "Hello 沙河"
      v, ok := x.(string)
      if ok {
        fmt.Println(v)
      } else {
        fmt.Println("类型断言失败")
      }
  }
  #+END_SRC
+ 上面的示例中如果要断言多次就需要写多个if判断，这个时候我们可以使用switch语句来实现
  #+BEGIN_SRC go
  func justifyType(x interface{}) {
      switch v := x.(type) {
      case string:
        fmt.Printf("x is a string，value is %v\n", v)
      case int:
        fmt.Printf("x is a int is %v\n", v)
      case bool:
        fmt.Printf("x is a bool is %v\n", v)
      default:
        fmt.Println("unsupport type！")
      }
  }
  #+END_SRC
*** 反射
**** 变量的内在机制
+ Go语言中的变量是分为两部分的
  - 类型信息：预先定义好的元信息
  - 值信息：程序运行过程中可动态变化的
**** 反射介绍
+ 
