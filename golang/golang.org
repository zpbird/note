* 系统中安装设置go
** windows
https://golang.google.cn/
将go的安装目录go\bin添加的path中
设置GOPATH:go下载扩展包的存放位置
设置环境变量
GO111MODULE=on
设置代理
GOPROXY=https://mirrors.aliyun.com/goproxy/
** linux
+ 安装
  yay -S go
  sudo apt install golang
+ 设置变量
  编辑 .xprofile
  export GOROOT=/usr/lib/go
  export GOPATH=/store/go_mod
  export GO111MODULE=on
  export GOPROXY=https://mirrors.aliyun.com/goproxy/
                 https://goproxy.io
                 https://goproxy.cn
  export PATH=$PATH:/usr/local/go/bin:$GOPATH/bin
** 查看信息
go version	#查看Go的版本
go env		#查看Go的环境变量
** 安装其他工具
#+BEGIN_SRC shell
#安装lsp-mode后端gopls
go get golang.org/x/tools/gopls@latest 或 GO111MODULE=on go get golang.org/x/tools/gopls@latest 
# godef
go get -u github.com/rogpeppe/godef
#+END_SRC
** 项目初始化
+ go mod init 项目名称(一般与根目录相同)
+ 编辑go.mod添加需要的模块
  require github.com/gin-gonic/gin v1.6.2
+ 在go.mod所在目录执行下载模块
  go mod download (go mod tidy)
* 编辑器及工具软件
** vscode
+ 安装Go扩展
  Go 0.13.1
+ 安装Go语言开发工具包
  - 相关工具
    gocode
    gopkgs
    go-outline
    go-symbols
    guru
    gorename
    gotests
    gomodifytags
    impl
    fillstruct
    goplay
    godoctor
    dlv
    gocode-gomod
    godef
    goreturns
    golint
    gopls
    github.com/mdempsky/gocode 
    github.com/uudashr/gopkgs/v2/cmd/gopkgs
    github.com/ramya-rao-a/go-outline 
    github.com/acroca/go-symbols 
    golang.org/x/tools/cmd/guru 
    golang.org/x/tools/cmd/gorename 
    github.com/cweill/gotests/... 
    github.com/fatih/gomodifytags
    github.com/josharian/impl 
    github.com/davidrjenni/reftools/cmd/fillstruct 
    github.com/haya14busa/goplay/cmd/goplay 
    github.com/godoctor/godoctor 
    github.com/go-delve/delve/cmd/dlv 
    github.com/stamblerre/gocode 
    github.com/rogpeppe/godef 
    github.com/sqs/goreturns 
    golang.org/x/lint/golint 
    golang.org/x/tools/gopls 

    Ctrl+Shift+P
    go:install
    Go:Install/Update Tools
    勾选所有
  - 代码片段
    Ctrl+Shift+P
    snippets
* Golang
** 常用命令
*** go 
**** version
+ 查看go语言版本
**** env
+ 查看og语言详细环境
**** list
+ 查看go语言文件目录
**** clean
+ 清空生成的可执行文件
**** vet
+ 静态分析文件是否有语法错误等
**** get
+ 下载go语言第三方库
**** install
**** mod
**** run
**** test
**** go build
+ 跨平台编译
  - 默认go build的可执行文件都是当前操作系统可执行的文件
  - 跨平台编译只需要指定目标操作系统的平台和处理器架构即可
    #+BEGIN_SRC shell
    SET CGO_ENABLED=0  // 禁用CGO,使用了cgo的代码是不支持跨平台编译的
    SET GOOS=linux  // 目标平台是linux
    SET GOARCH=amd64  // 目标处理器架构是amd64

    CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build
    CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build
    CGO_ENABLED=0 GOOS=darwin GOARCH=amd64 go build
    #+END_SRC
*** godoc
+ 查看、生成注释与文档工具
** 基础知识
*** 注释
**** 单行
//
**** 多行
/*
多行注释
*/
*** 标识符、关键字
**** 标识符
- 标识符就是程序员定义的具有特殊意义的词，比如变量名、常量名、函数名等等。 Go语言中标识符由字母数字和_(下划线）组成，并且只能以字母和_开头。 举几个例子：abc, _, _123, a123
**** 关键字
- 关键字是指编程语言中预先定义好的具有特殊含义的标识符，关键字和保留字都不建议用作变量名
- 关键字
  break        default      func         interface    select
  case         defer        go           map          struct
  chan         else         goto         package      switch
  const        fallthrough  if           range        type
  continue     for          import       return       var
- 保留字
  Constants:    true  false  iota  nil

  Types:        int  int8  int16  int32  int64  
                uint  uint8  uint16  uint32  uint64  uintptr
                float32  float64  complex128  complex64
                bool  byte  rune  string  error

  Functions:    make  len  cap  new  append  copy  close  delete
                complex  real  imag
                panic  recover
*** 转义字符(verb)
**** 形式
+ %+特定字母
  fmt.Printf("%T", "aaa")
+ \+特定字母
**** 常用转义字符
| verb     | 含义                       |
|----------+----------------------------|
| %d       | 十进制整数                 |
| %x,%X    | 大小写方式显示十六进制整数 |
| %o       | 八进制整数                 |
| %b       | 二进制整数                 |
| %f,%g,%e | 浮点数                     |
| %t       | 布尔值                     |
| %C       | 字符                       |
| %S       | 字符串                     |
| %q       | 带双引号字符串             |
| %v       | 内置格式内容               |
| %T       | 类型                       |
| %p       | 内存地址                   |
| %%	     | 字符%                      |
| \n       | 换行                       |
| \t	     | 缩进                       |
*** 打印输出
**** PrintXX()
+ PrintXX()把结果打印到控制台,返回内容长度和错误
+ Print()
+ Println()
+ Printf()
**** FprintXX()
+ 在Go Web中使用比较多,把内容写到响应流中
+ 函数参数中第一个参数是输出流,后面参数是内容,表示把内容写入到输出流中
+ 第一个返回值表示输出内容长度(字节数),第二个返回值表示错误,如果没有错误取值nil
+ Fprint()
+ Fprintln()
+ Fprintf()
**** SprintXX()
+ SprintXX()把形成结果以字符串返回,并没有打印到控制台
+ 所以从严格意义角度讲SprintXX不是打印输出,而更像字符串转换
+ Sprint()
+ Sprintln()
+ Sprintf()
*** 接收用户输入
+ 程序运行时,运行到接收用户输入语句,程序阻塞,用户在控制台输入内容后,把内容赋值给对应的变量,程序继续运行
+ Scanln(&变量名,&变量名)的方式接收
  - 输入的内容必须都在同一行
  - 每个内容之间使用空格分割
  - 回车换行后表示停止输入
  - 如果希望接收3个值,而在控制台只输入2个值,回车后也停止接收
  - 如果希望接收2个值,而在控制台输入3个,回车后只能接收两个值
+ Scanf()
  - Scanf("%s\n%s",&a,&b)
  - 结合上面的转义字符可以实现输入一个值后回车输入第二个值，不需要刻意使用空格，否则与Scanln()的效果相同，也需要使用空格分隔
*** 变量
**** 变量类型
Go语言中的每一个变量都有自己的类型，并且变量必须经过声明才能开始使用
**** 变量声明
+ 变量需要声明后才能使用，同一作用域内不支持重复声明。 并且Go语言的变量声明后必须使用
***** 标准声明
var 变量名 变量类型
#+BEGIN_SRC go
var name string
var age int
var isOk bool
#+END_SRC
***** 批量声明
go语言中还支持批量变量声明
#+BEGIN_SRC go
var (
    a string
    b int
    c bool
    d float32
)
#+END_SRC
**** 变量的初始化
+ Go语言在声明变量的时候，会自动对变量对应的内存区域进行初始化操作。每个变量会被初始化成其类型的默认值
  例如： 整型和浮点型变量的默认值为0；字符串变量的默认值为空字符串；布尔型变量默认为false；切片、函数、指针变量的默认为nil
+ 可在声明变量的时候为其指定初始值，变量初始化的标准格式如下
  var 变量名 类型 = 表达式
  #+BEGIN_SRC go
  var name string = "Q1mi"
  var age int = 18

  //一次初始化多个变量
  var name, age = "Q1mi", 20
  #+END_SRC
+ 类型推导
  有时候我们会将变量的类型省略，这个时候编译器会根据等号右边的值来推导变量的类型完成初始化
  #+BEGIN_SRC go
  var name = "Q1mi"
  var age = 18
  #+END_SRC
+ 短变量声明
  在函数内部，可以使用更简略的 := 方式声明并初始化变量
  #+BEGIN_SRC go
  package main

  import (
	  "fmt"
  )
  // 全局变量m
  var m = 100

  func main() {
  	n := 10
  	m := 200 // 此处声明局部变量m
  	fmt.Println(m, n)
  }
  #+END_SRC
+ 匿名变量
  - 在使用多重赋值时，如果想要忽略某个值，可以使用匿名变量（anonymous variable）,匿名变量用一个下划线_表示
  - 匿名变量不占用命名空间，不会分配内存，所以匿名变量之间不存在重复声明
  - _多用于占位，表示忽略值
  #+BEGIN_SRC go
  func foo() (int, string) {
  	return 10, "Q1mi"
  }
  func main() {
  	x, _ := foo()
  	_, y := foo()
  	fmt.Println("x=", x)
  	fmt.Println("y=", y)
  }
  #+END_SRC
*** 常量
+ 相对于变量，常量是恒定不变的值，多用于定义程序运行期间不会改变的那些值。 常量的声明和变量声明非常类似，只是把var换成了const，常量在定义的时候必须赋值
  #+BEGIN_SRC go
  const pi = 3.1415
  const e = 2.7182
  #+END_SRC
+ 多个常量也可以一起声明
  #+BEGIN_SRC go
  const (
    pi = 3.1415
    e = 2.7182
  )
  #+END_SRC
+ const同时声明多个常量时，如果省略了值则表示和上面一行的值相同
  #+BEGIN_SRC go
  const (
    n1 = 100
    n2
    n3
  )
  #+END_SRC
+ iota
  - iota是go语言的常量计数器，只能在常量的表达式中使用
  - iota在const关键字出现时将被重置为0。const中每新增一行常量声明将使iota计数一次(iota可理解为const语句块中的行索引)，使用iota能简化定义，在定义枚举时很有用
    #+BEGIN_SRC go
    const (
		         n1 = iota //0
		         n2        //1
		         n3        //2
		         n4        //3
	   )
    #+END_SRC
  - 几个常见的iota示例
    #+BEGIN_SRC go
    // 使用_跳过某些值
    const (
           n1 = iota //0
           n2        //1
           _
           n4        //3
    )
    
    // iota声明中间插队
    const (
		         n1 = iota //0
		         n2 = 100  //100
		         n3 = iota //2
		         n4        //3
     )
	   const n5 = iota //0

    // 定义数量级 （这里的<<表示左移操作，1<<10表示将1的二进制表示向左移10位，也就是由1变成了10000000000，也就是十进制的1024。同理2<<2表示将2的二进制表示向左移2位，也就是由10变成了1000，也就是十进制的8。）
    const (
		         _  = iota
		         KB = 1 << (10 * iota)
		         MB = 1 << (10 * iota)
		         GB = 1 << (10 * iota)
		         TB = 1 << (10 * iota)
		         PB = 1 << (10 * iota)
	   )

    // 多个iota定义在一行
    const (
		        a, b = iota + 1, iota + 2 //1,2
		        c, d                      //2,3
		        e, f                      //3,4
    )
    #+END_SRC
*** 数据类型
**** 基本数据类型
***** 整型
+ 常规整型
  整型分为以下两个大类： 按长度分为：int8、int16、int32、int64 对应的无符号整型：uint8、uint16、uint32、uint64
  | 类型     | 描述                                                          |
  |----------+---------------------------------------------------------------|
  | uint8    | 无符号 8位整型 (0 到 255)                                     |
  | uint16   | 无符号 16位整型 (0 到 65535)                                  |
  | uint32	 | 无符号 32位整型 (0 到 4294967295)                             |
  | uint64   | 无符号 64位整型 (0 到 18446744073709551615)                   |
  | int8     | 有符号 8位整型 (-128 到 127)                                  |
  | int16    | 有符号 16位整型 (-32768 到 32767)                             |
  | int32    | 有符号 32位整型 (-2147483648 到 2147483647)                   |
  | int64    | 有符号 64位整型 (-9223372036854775808 到 9223372036854775807) |
+ 特殊整型
  - 在使用int和 uint类型时，不能假定它是32位或64位的整型，而是考虑int和uint可能在不同平台上的差异
  - 获取对象的长度的内建len()函数返回的长度可以根据不同平台的字节长度进行变化。实际使用中，切片或 map 的元素数量等都可以用int来表示。在涉及到二进制传输、读写文件的结构描述时，为了保持文件的结构不会受到不同编译目标平台字节长度的影响，不要使用int和 uint
  | 类型    | 描述                                               |
  |---------+----------------------------------------------------|
  | uint    | 32位操作系统上就是uint32，64位操作系统上就是uint64 |
  | int     | 32位操作系统上就是int32，64位操作系统上就是int64   |
  | uintptr | 无符号整型，用于存放一个指针                       |
***** 数字字面量语法（Number literals syntax）
 便于开发者以二进制、八进制或十六进制浮点数的格式定义数字
 #+BEGIN_SRC go
 package main
 
 import "fmt"
 
 func main(){
   // 十进制
	 var a int = 10
	 fmt.Printf("%d \n", a)  // 10
	 fmt.Printf("%b \n", a)  // 1010  占位符%b表示二进制
 
	 // 八进制  以0开头
	 var b int = 077
	 fmt.Printf("%o \n", b)  // 77
 
	 // 十六进制  以0x开头
	 var c int = 0xff
	 fmt.Printf("%x \n", c)  // ff
	 fmt.Printf("%X \n", c)  // FF
 }
 #+END_SRC
***** 浮点型
+ Go语言支持两种浮点型数：float32和float64。这两种浮点型数据格式遵循IEEE 754标准： float32 的浮点数的最大范围约为 3.4e38，可以使用常量定义：math.MaxFloat32。 float64 的浮点数的最大范围约为 1.8e308，可以使用一个常量定义：math.MaxFloat64
+ 打印浮点数时，可以使用fmt包配合动词%f
  #+BEGIN_SRC go
  package main
  import (
          "fmt"
          "math"
  )
  func main() {
          fmt.Printf("%f\n", math.Pi)
          fmt.Printf("%.2f\n", math.Pi)
  }
  #+END_SRC
***** 复数
+ complex64和complex128，复数有实部和虚部，complex64的实部和虚部为32位，complex128的实部和虚部为64位
  #+BEGIN_SRC go
  var c1 complex64
  c1 = 1 + 2i
  var c2 complex128
  c2 = 2 + 3i
  fmt.Println(c1)
  fmt.Println(c2)
  #+END_SRC
***** 布尔值
+ Go语言中以bool类型进行声明布尔型数据，布尔型数据只有true（真）和false（假）两个值
+ 注意
  - 布尔类型变量的默认值为false
  - 不允许将整型强制转换为布尔型
  - 布尔型无法参与数值运算，也无法与其他类型进行转换
***** 字符串
+ 字符串以原生数据类型出现，使用字符串就像使用其他原生数据类型（int、bool、float32、float64 等）一样。 Go 语言里的字符串的内部实现使用UTF-8编码。 字符串的值为双引号(")中的内容，可以在Go语言的源码中直接添加非ASCII码字符
  #+BEGIN_SRC go
  s1 := "hello"
  s2 := "你好"
  #+END_SRC
+ 字符串转义符
  | 转义符 | 含义                               |
  |--------+------------------------------------|
  | \r     | 回车符（返回行首）                 |
  | \n     | 换行符（直接跳到下一行的同列位置） |
  | \t	   | 制表符                             |
  | \'     | 单引号                             |
  | \"     | 双引号                             |
  | \\     | 	反斜杠                           |
  例如打印一个Windows平台下的一个文件路径
  #+BEGIN_SRC go
  package main
  import (
      "fmt"
  )
  func main() {
      fmt.Println("str := \"c:\\Code\\lesson1\\go.exe\"")
  }
  #+END_SRC
+ 多行字符串
  Go语言中要定义一个多行字符串时，就必须使用反引号字符,反引号间换行将被作为字符串中的换行，但是所有的转义字符均无效，文本将会原样输出
  #+BEGIN_SRC go
  s1 := `第一行
  第二行
  第三行
  `
  fmt.Println(s1)
  #+END_SRC
+ 字符串的常用操作
  | 方法                                | 介绍           |
  |-------------------------------------+----------------|
  | len(str)                            | 求长度         |
  | +或fmt.Sprintf                      | 拼接字符串     |
  | strings.Split                       | 分割           |
  | strings.contains                    | 判断是否包含   |
  | strings.HasPrefix,strings.HasSuffix | 前缀/后缀判断  |
  | strings.Index(),strings.LastIndex() | 子串出现的位置 |
  | strings.Join(a[]string, sep string) | join操作       |
***** 字符
+ 组成每个字符串的元素叫做“字符”，可以通过遍历或者单个获取字符串元素获得字符。 字符用单引号（’）包裹起来
  #+BEGIN_SRC go
  var a := '中'
  var b := 'x'
  #+END_SRC
+ Go 语言的字符有以下两种
  - uint8类型，或者叫 byte 型，代表了ASCII码的一个字符
  - rune类型，代表一个 UTF-8字符
+ 当需要处理中文、日文或者其他复合字符时，则需要用到rune类型。rune类型实际是一个int32
+ Go 使用了特殊的 rune 类型来处理 Unicode，让基于 Unicode 的文本处理更为方便，也可以使用 byte 型进行默认字符串处理，性能和扩展性都有照顾
  #+BEGIN_SRC go
  // 遍历字符串
  func traversalString() {
	  s := "hello沙河"
	  for i := 0; i < len(s); i++ { //byte
		  fmt.Printf("%v(%c) ", s[i], s[i])
    }
	  fmt.Println()
	  for _, r := range s { //rune
		  fmt.Printf("%v(%c) ", r, r)
	  }
	  fmt.Println()
  }
  //输出
  104(h) 101(e) 108(l) 108(l) 111(o) 230(æ) 178(²) 153() 230(æ) 178(²) 179(³) 
  104(h) 101(e) 108(l) 108(l) 111(o) 27801(沙) 27827(河) 
  #+END_SRC
  - 因为UTF8编码下一个中文汉字由3~4个字节组成，所以我们不能简单的按照字节去遍历一个包含中文的字符串，否则就会出现上面输出中第一行的结果
  - 字符串底层是一个byte数组，所以可以和[]byte类型相互转换。字符串是不能修改的 字符串是由byte字节组成，所以字符串的长度是byte字节的长度。 rune类型用来表示utf8字符，一个rune字符由一个或多个byte组成
***** 修改字符串
+ 要修改字符串，需要先将其转换成[]rune或[]byte，完成后再转换为string。无论哪种转换，都会重新分配内存，并复制字节数组
  #+BEGIN_SRC go
  func changeString() {
	  s1 := "big"
	  // 强制类型转换
	  byteS1 := []byte(s1)
	  byteS1[0] = 'p'
	  fmt.Println(string(byteS1))

	  s2 := "白萝卜"
	  runeS2 := []rune(s2)
	  runeS2[0] = '红'
	  fmt.Println(string(runeS2))
  }
  #+END_SRC
***** 类型转换
+ Go语言中只有强制类型转换，没有隐式类型转换。该语法只能在两个类型之间支持相互转换的时候使用
+ 强制类型转换的基本语法如下
  T(表达式)
  T表示要转换的类型。表达式包括变量、复杂算子和函数返回值等
+ 比如计算直角三角形的斜边长时使用math包的Sqrt()函数，该函数接收的是float64类型的参数，而变量a和b都是int类型的，这个时候就需要将a和b强制类型转换为float64类型
  #+BEGIN_SRC go
  func sqrtDemo() {
    	var a, b = 3, 4
	    var c int
	    // math.Sqrt()接收的参数是float64类型，需要强制转换
	    c = int(math.Sqrt(float64(a*a + b*b)))
	    fmt.Println(c)
  }
  #+END_SRC
**** 数组(Array)
数组是同一种数据类型元素的集合，在Go语言中，数组从声明时就确定，使用时可以修改数组成员，但是数组大小不可变化
***** 数组定义
#+BEGIN_SRC go
var 数组变量名 [元素数量]T

// 定义一个长度为3元素类型为int的数组a
var a [3]int
#+END_SRC
+ 数组的长度必须是常量，并且长度是数组类型的一部分。一旦定义，长度不能变。 [5]int和[10]int是不同的类型
  #+BEGIN_SRC go
  var a [3]int
  var b [4]int
  a = b //不可以这样做，因为此时a和b是不同的类型
  #+END_SRC
+ 数组可以通过下标进行访问，下标是从0开始，最后一个元素下标是：len-1，访问越界（下标在合法范围之外），则触发访问越界，会panic
***** 数组的初始化
数组的初始化也有很多方式
+ 方法一
  初始化数组时可以使用初始化列表来设置数组元素的值
  #+BEGIN_SRC go
  func main() {
      var testArray [3]int                        //数组会初始化为int类型的零值
      var numArray = [3]int{1, 2}                 //使用指定的初始值完成初始化
      var cityArray = [3]string{"北京", "上海", "深圳"} //使用指定的初始值完成初始化
      fmt.Println(testArray)                      //[0 0 0]
      fmt.Println(numArray)                       //[1 2 0]
      fmt.Println(cityArray)                      //[北京 上海 深圳]
  }
  #+END_SRC
+ 方法二
  按照上面的方法每次都要确保提供的初始值和数组长度一致，一般情况下我们可以让编译器根据初始值的个数自行推断数组的长度
  #+BEGIN_SRC go
  func main() {
      var testArray [3]int
      var numArray = [...]int{1, 2}
      var cityArray = [...]string{"北京", "上海", "深圳"}
      fmt.Println(testArray)                          //[0 0 0]
      fmt.Println(numArray)                           //[1 2]
      fmt.Printf("type of numArray:%T\n", numArray)   //type of numArray:[2]int
      fmt.Println(cityArray)                          //[北京 上海 深圳]
      fmt.Printf("type of cityArray:%T\n", cityArray) //type of cityArray:[3]string
  }
  #+END_SRC
+ 方法三
  可以使用指定索引值的方式来初始化数组
  #+BEGIN_SRC go
  func main() {
      a := [...]int{1: 1, 3: 5}
      fmt.Println(a)                  // [0 1 0 5]
      fmt.Printf("type of a:%T\n", a) //type of a:[4]int

  }
  #+END_SRC
***** 数组的遍历
遍历数组有以下两种方法
#+BEGIN_SRC go
func main() {
    var a = [...]string{"北京", "上海", "深圳"}
    // 方法1：for循环遍历
    for i := 0; i < len(a); i++ {
      fmt.Println(a[i])
    }

    // 方法2：for range遍历
    for index, value := range a {
      fmt.Println(index, value)
    }
}
#+END_SRC
***** 多维数组
+ Go语言是支持多维数组的，我们这里以二维数组为例（数组中又嵌套数组）
+ 二维数组的定义
  #+BEGIN_SRC go
  func main() {
      a := [3][2]string{
        {"北京", "上海"},
        {"广州", "深圳"},
        {"成都", "重庆"},
      }
      fmt.Println(a) //[[北京 上海] [广州 深圳] [成都 重庆]]
      fmt.Println(a[2][1]) //支持索引取值:重庆
  }
  #+END_SRC
+ 二维数组的遍历
  #+BEGIN_SRC go
  func main() {
      a := [3][2]string{
        {"北京", "上海"},
        {"广州", "深圳"},
        {"成都", "重庆"},
      }
      for _, v1 := range a {
        for _, v2 := range v1 {
          fmt.Printf("%s\t", v2)
        }
        fmt.Println()
      }
  }
  #+END_SRC
+  多维数组只有第一层可以使用...来让编译器推导数组长度
  #+BEGIN_SRC go
    //支持的写法
    a := [...][2]string{
      {"北京", "上海"},
      {"广州", "深圳"},
      {"成都", "重庆"},
    }
    //不支持多维数组的内层使用...
    b := [3][...]string{
      {"北京", "上海"},
      {"广州", "深圳"},
      {"成都", "重庆"},
    }

  #+END_SRC
***** 数组是值类型
+ 数组是值类型，赋值和传参会复制整个数组。因此改变副本的值，不会改变本身的值
  #+BEGIN_SRC go
  func modifyArray(x [3]int) {
      x[0] = 100
  }

  func modifyArray2(x [3][2]int) {
      x[2][0] = 100
  }
  func main() {
      a := [3]int{10, 20, 30}
      modifyArray(a) //在modify中修改的是a的副本x
      fmt.Println(a) //[10 20 30]
      b := [3][2]int{
        {1, 1},
        {1, 1},
        {1, 1},
      }
      modifyArray2(b) //在modify中修改的是b的副本x
      fmt.Println(b)  //[[1 1] [1 1] [1 1]]
  }
  #+END_SRC
***** 注意
+ 数组支持 “==“、”!=” 操作符，因为内存总是被初始化过的
+ [n]*T表示指针数组，*[n]T表示数组指针 
**** 切片(slice)
+ 切片（Slice）是一个拥有相同类型元素的可变长度的序列。它是基于数组类型做的一层封装。它非常灵活，支持自动扩容
+ 切片是一个引用类型，它的内部结构包含地址、长度和容量。切片一般用于快速地操作一块数据集合
+ 切片是引用类型，不支持直接比较，只能和nil比较
***** 定义
+ 声明切片类型的基本语法
  #+BEGIN_SRC go
  var name []T
  // name:表示变量名
  // T:表示切片中的元素类型
  #+END_SRC
  #+BEGIN_SRC go
  func main() {
      // 声明切片类型
      var a []string              //声明一个字符串切片
      var b = []int{}             //声明一个整型切片并初始化
      var c = []bool{false, true} //声明一个布尔切片并初始化
      var d = []bool{false, true} //声明一个布尔切片并初始化
      fmt.Println(a)              //[]
      fmt.Println(b)              //[]
      fmt.Println(c)              //[false true]
      fmt.Println(a == nil)       //true
      fmt.Println(b == nil)       //false
      fmt.Println(c == nil)       //false
      // fmt.Println(c == d)   //切片是引用类型，不支持直接比较，只能和nil比较
  }
  #+END_SRC
+ 通过数组得到切片
  #+BEGIN_SRC go
  var a = [5]int{7, 9, 15, 8, 2}
  var s = a[1:4]
  #+END_SRC
+ 再切片
  #+BEGIN_SRC go
  var a = [5]int{7, 9, 15, 8, 2}
  var s = a[1:4]
  var c = s[0:len(s)]
  #+END_SRC
***** 切片的长度和容量
+ 切片拥有自己的长度和容量，我们可以通过使用内置的len()函数求长度，使用内置的cap()函数求切片的容量
***** 切片表达式
+ 切片表达式从字符串、数组、指向数组或切片的指针构造子字符串或切片。它有两种变体：一种指定low和high两个索引界限值的简单的形式，另一种是除了low和high索引界限值外还指定容量的完整的形式
****** 简单切片表达式
+ 切片的底层就是一个数组，所以我们可以基于数组通过切片表达式得到切片。 切片表达式中的low和high表示一个索引范围（左包含，右不包含），也就是下面代码中从数组a中选出1<=索引值<4的元素组成切片s，得到的切片长度=high-low，容量等于得到的切片的底层数组的容量
  #+BEGIN_SRC go
  func main() {
      a := [5]int{1, 2, 3, 4, 5}
      s := a[1:3]  // s := a[low:high]
      fmt.Printf("s:%v len(s):%v cap(s):%v\n", s, len(s), cap(s))
  }
  // 输出
  s:[2 3] len(s):2 cap(s):4
  #+END_SRC
+ 为了方便起见，可以省略切片表达式中的任何索引。省略了low则默认为0；省略了high则默认为切片操作数的长度
  #+BEGIN_SRC go
  a[2:]  // 等同于 a[2:len(a)]
  a[:3]  // 等同于 a[0:3]
  a[:]   // 等同于 a[0:len(a)]
  #+END_SRC
+ 注意
  - 对于数组或字符串，如果0 <= low <= high <= len(a)，则索引合法，否则就会索引越界（out of range）
  - 对切片再执行切片表达式时（切片再切片），high的上限边界是切片的容量cap(a)，而不是长度。常量索引必须是非负的，并且可以用int类型的值表示;对于数组或常量字符串，常量索引也必须在有效范围内。如果low和high两个指标都是常数，它们必须满足low <= high。如果索引在运行时超出范围，就会发生运行时panic
    #+BEGIN_SRC go
    func main() {
        a := [5]int{1, 2, 3, 4, 5}
        s := a[1:3]  // s := a[low:high]
        fmt.Printf("s:%v len(s):%v cap(s):%v\n", s, len(s), cap(s))
        s2 := s[3:4]  // 索引的上限是cap(s)而不是len(s)
        fmt.Printf("s2:%v len(s2):%v cap(s2):%v\n", s2, len(s2), cap(s2))
    }
    // 输出
    s:[2 3] len(s):2 cap(s):4
    s2:[5] len(s2):1 cap(s2):1
    #+END_SRC
****** 完整切片表达式
+ 对于数组，指向数组的指针，或切片a(注意不能是字符串)支持完整切片表达式
  #+BEGIN_SRC go
  a[low : high : max]
  #+END_SRC
+ 上面的代码会构造与简单切片表达式a[low: high]相同类型、相同长度和元素的切片。另外，它会将得到的结果切片的容量设置为max-low。在完整切片表达式中只有第一个索引值（low）可以省略；它默认为0
  #+BEGIN_SRC go
  func main() {
      a := [5]int{1, 2, 3, 4, 5}
      t := a[1:3:5]
      fmt.Printf("t:%v len(t):%v cap(t):%v\n", t, len(t), cap(t))
  }
  // 输出结果
  t:[2 3] len(t):2 cap(t):4
  #+END_SRC
+ 完整切片表达式需要满足的条件是0 <= low <= high <= max <= cap(a)，其他条件和简单切片表达式相同
***** 使用make()函数构造切片
+ 上面都是基于数组来创建的切片，如果需要动态的创建一个切片，我们就需要使用内置的make()函数
  #+BEGIN_SRC go
  make([]T, size, cap)
  // T:切片的元素类型
  // size:切片中元素的数量
  // cap:切片的容量

  func main() {
	    a := make([]int, 2, 10)
	    fmt.Println(a)      //[0 0]
	    fmt.Println(len(a)) //2
	    fmt.Println(cap(a)) //10
  }
  // 上面代码中a的内部存储空间已经分配了10个，但实际上只用了2个。 容量并不会影响当前元素的个数，所以len(a)返回2，cap(a)则返回该切片的容量
  #+END_SRC
***** 切片的本质
+ 切片的本质就是对底层数组的封装，它包含了三个信息：底层数组的指针、切片的长度（len）和切片的容量（cap）[[file:pic/%E5%88%87%E7%89%8701.png][示意图]]
***** 判断切片是否为空
+ 检查切片是否为空，请始终使用len(s) == 0来判断，而不应该使用s == nil来判断
***** 切片不能直接比较
+ 切片之间是不能比较的，我们不能使用==操作符来判断两个切片是否含有全部相等元素。 切片唯一合法的比较操作是和nil比较。 一个nil值的切片并没有底层数组，一个nil值的切片的长度和容量都是0。但是我们不能说一个长度和容量都是0的切片一定是nil
+ 要判断一个切片是否是空的，要是用len(s) == 0来判断，不应该使用s == nil来判断
  #+BEGIN_SRC go
  var s1 []int         //len(s1)=0;cap(s1)=0;s1==nil
  s2 := []int{}        //len(s2)=0;cap(s2)=0;s2!=nil
  s3 := make([]int, 0) //len(s3)=0;cap(s3)=0;s3!=nil
  #+END_SRC
***** 切片的赋值拷贝
+ 下面的代码中演示了拷贝前后两个变量共享底层数组，对一个切片的修改会影响另一个切片的内容，这点需要特别注意
  #+BEGIN_SRC go
  func main() {
      s1 := make([]int, 3) //[0 0 0]
      s2 := s1             //将s1直接赋值给s2，s1和s2共用一个底层数组
      s2[0] = 100
      fmt.Println(s1) //[100 0 0]
      fmt.Println(s2) //[100 0 0]
  }
  #+END_SRC
***** 切片遍历
+ 切片的遍历方式和数组是一致的，支持索引遍历和for range遍历
  #+BEGIN_SRC go
  func main() {
      s := []int{1, 3, 5}

      for i := 0; i < len(s); i++ {
        fmt.Println(i, s[i])
      }

      for index, value := range s {
        fmt.Println(index, value)
      }
  }
  #+END_SRC
***** append()方法为切片添加元素
+ Go语言的内建函数append()可以为切片动态添加元素。 可以一次添加一个元素，可以添加多个元素，也可以添加另一个切片中的元素（后面加…）
  #+BEGIN_SRC go
  func main(){
      var s []int
      s = append(s, 1)        // [1]
      s = append(s, 2, 3, 4)  // [1 2 3 4]
      s2 := []int{5, 6, 7}  
      s = append(s, s2...)    // [1 2 3 4 5 6 7]
  }
  #+END_SRC
+ 注意
  - 通过var声明的零值切片可以在append()函数直接使用，无需初始化
    #+BEGIN_SRC go
    var s []int
    s = append(s, 1, 2, 3)
    #+END_SRC
  - 没有必要像下面的代码一样初始化一个切片再传入append()函数使用
    #+BEGIN_SRC go
    s := []int{}  // 没有必要初始化
    s = append(s, 1, 2, 3)

    var s = make([]int)  // 没有必要初始化
    s = append(s, 1, 2, 3)
    #+END_SRC
  - 每个切片会指向一个底层数组，这个数组的容量够用就添加新增元素。当底层数组不能容纳新增的元素时，切片就会自动按照一定的策略进行“扩容”，此时该切片指向的底层数组就会更换。“扩容”操作往往发生在append()函数调用时，所以我们通常都需要用原变量接收append函数的返回值
    #+BEGIN_SRC go
    func main() {
        //append()添加元素和切片扩容
        var numSlice []int
        for i := 0; i < 10; i++ {
          numSlice = append(numSlice, i)
          fmt.Printf("%v  len:%d  cap:%d  ptr:%p\n", numSlice, len(numSlice), cap(numSlice), numSlice)
        }
    }
    // 输出：
    [0]  len:1  cap:1  ptr:0xc0000a8000
    [0 1]  len:2  cap:2  ptr:0xc0000a8040
    [0 1 2]  len:3  cap:4  ptr:0xc0000b2020
    [0 1 2 3]  len:4  cap:4  ptr:0xc0000b2020
    [0 1 2 3 4]  len:5  cap:8  ptr:0xc0000b6000
    [0 1 2 3 4 5]  len:6  cap:8  ptr:0xc0000b6000
    [0 1 2 3 4 5 6]  len:7  cap:8  ptr:0xc0000b6000
    [0 1 2 3 4 5 6 7]  len:8  cap:8  ptr:0xc0000b6000
    [0 1 2 3 4 5 6 7 8]  len:9  cap:16  ptr:0xc0000b8000
    [0 1 2 3 4 5 6 7 8 9]  len:10  cap:16  ptr:0xc0000b8000
    #+END_SRC
  - append()函数将元素追加到切片的最后并返回该切片
  - 切片numSlice的容量按照1，2，4，8，16这样的规则自动进行扩容，每次扩容后都是扩容前的2倍
  - append()函数还支持一次性追加多个元素
    #+BEGIN_SRC go
    var citySlice []string
    // 追加一个元素
    citySlice = append(citySlice, "北京")
    // 追加多个元素
    citySlice = append(citySlice, "上海", "广州", "深圳")
    // 追加切片
    a := []string{"成都", "重庆"}
    citySlice = append(citySlice, a...)
    fmt.Println(citySlice) //[北京 上海 广州 深圳 成都 重庆]
    #+END_SRC
***** 切片的扩容策略
+ 首先判断，如果新申请容量（cap）大于2倍的旧容量（old.cap），最终容量（newcap）就是新申请的容量（cap）
+ 否则判断，如果旧切片的长度小于1024，则最终容量(newcap)就是旧容量(old.cap)的两倍，即（newcap=doublecap）
+ 否则判断，如果旧切片长度大于等于1024，则最终容量（newcap）从旧容量（old.cap）开始循环增加原来的1/4，即（newcap=old.cap,for {newcap += newcap/4}）直到最终容量（newcap）大于等于新申请的容量(cap)，即（newcap >= cap）
+ 如果最终容量（cap）计算值溢出，则最终容量（cap）就是新申请容量（cap）
+ 需要注意的是，切片扩容还会根据切片中元素的类型不同而做不同的处理，比如int和string类型的处理方式就不一样
***** 使用copy()函数复制切片
+ Go语言内建的copy()函数可以迅速地将一个切片的数据复制到另外一个切片空间中，copy()函数的使用格式如下
  #+BEGIN_SRC go
  copy(destSlice, srcSlice []T)

  func main() {
	// copy()复制切片
	  a := []int{1, 2, 3, 4, 5}
	  c := make([]int, 5, 5)
	  copy(c, a)     //使用copy()函数将切片a中的元素复制到切片c
	  fmt.Println(a) //[1 2 3 4 5]
	  fmt.Println(c) //[1 2 3 4 5]
	  c[0] = 1000
	  fmt.Println(a) //[1 2 3 4 5]
	  fmt.Println(c) //[1000 2 3 4 5]
  }
  #+END_SRC
***** 从切片中删除元素
+ Go语言中并没有删除切片元素的专用方法，我们可以使用切片本身的特性来删除元素
  #+BEGIN_SRC go
  func main() {
      // 从切片中删除元素
      a := []int{30, 31, 32, 33, 34, 35, 36, 37}
      // 要删除索引为2的元素
      a = append(a[:2], a[3:]...)
      fmt.Println(a) //[30 31 33 34 35 36 37]
  }
  // 要从切片a中删除索引为index的元素，操作方法是a = append(a[:index], a[index+1:]...)
  #+END_SRC
**** map
+ Go语言中提供的映射关系容器为map，其内部使用散列表（hash）实现
+ map是一种无序的基于key-value的数据结构，Go语言中的map是引用类型，必须初始化才能使用
***** map定义
+ 语法
  #+BEGIN_SRC go
  map[KeyType]ValueType
  // KeyType:表示键的类型
  // ValueType:表示键对应的值的类型
  #+END_SRC
+ map类型的变量默认初始值为nil，需要使用make()函数来分配内存
  #+BEGIN_SRC go
  make(map[KeyType]ValueType, [cap])
  // 其中cap表示map的容量，该参数虽然不是必须的，但是我们应该在初始化map的时候就为其指定一个合适的容量
  #+END_SRC
***** 基本使用
+ map中的数据都是成对出现的，map的基本使用示例代码
  #+BEGIN_SRC go
  func main() {
      scoreMap := make(map[string]int, 8)
      scoreMap["张三"] = 90
      scoreMap["小明"] = 100
      fmt.Println(scoreMap)
      fmt.Println(scoreMap["小明"])
      fmt.Printf("type of a:%T\n", scoreMap)
  }
  // 输出：
  map[小明:100 张三:90]
  100
  type of a:map[string]int
  #+END_SRC
+ map也支持在声明的时候填充元素
  #+BEGIN_SRC go
  func main() {
      userInfo := map[string]string{
        "username": "沙河小王子",
        "password": "123456",
      }
      fmt.Println(userInfo) //
  }
  #+END_SRC
***** 打印格式
+ 可以使用打印控制，显示成习惯的形式
  fmt.Printf("变量名:%#v\n", 变量名)
***** 判断某个键是否存在
+ Go语言中有个判断map中键是否存在的特殊写法
  #+BEGIN_SRC go
  value, ok := map[key]

  // 示例
  func main() {
      scoreMap := make(map[string]int)
      scoreMap["张三"] = 90
      scoreMap["小明"] = 100
      // 如果key存在ok为true,v为对应的值；不存在ok为false,v为值类型的零值
      v, ok := scoreMap["张三"]
      if ok {
        fmt.Println(v)
      } else {
        fmt.Println("查无此人")
      }
  }
  #+END_SRC
***** map的遍历
+ Go语言中使用for range遍历map
  #+BEGIN_SRC go
  func main() {
      scoreMap := make(map[string]int)
      scoreMap["张三"] = 90
      scoreMap["小明"] = 100
      scoreMap["娜扎"] = 60
      for k, v := range scoreMap {
        fmt.Println(k, v)
      }
  }
  #+END_SRC
+ 只想遍历key的时候，可以按下面的写法
  #+BEGIN_SRC go
  func main() {
      scoreMap := make(map[string]int)
      scoreMap["张三"] = 90
      scoreMap["小明"] = 100
      scoreMap["娜扎"] = 60
      for k := range scoreMap {
        fmt.Println(k)
      }
  }
  #+END_SRC
+ 遍历map时的元素顺序与添加键值对的顺序无关
***** 使用delete()函数删除键值对
+ 使用delete()内建函数从map中删除一组键值对，delete()函数的格式如下
  #+BEGIN_SRC go
  delete(map, key)

  // 示例
  func main(){
    	scoreMap := make(map[string]int)
	    scoreMap["张三"] = 90
	    scoreMap["小明"] = 100
	    scoreMap["娜扎"] = 60
	    delete(scoreMap, "小明")//将小明:100从map中删除
	    for k,v := range scoreMap{
		      fmt.Println(k, v)
	    }
  }
  #+END_SRC
***** 按照指定顺序遍历map
+ 示例
  #+BEGIN_SRC go
  func main() {
      rand.Seed(time.Now().UnixNano()) //初始化随机数种子

      var scoreMap = make(map[string]int, 200)

      for i := 0; i < 100; i++ {
        key := fmt.Sprintf("stu%02d", i) //生成stu开头的字符串
        value := rand.Intn(100)          //生成0~99的随机整数
        scoreMap[key] = value
      }
      //取出map中的所有key存入切片keys
      var keys = make([]string, 0, 200)
      for key := range scoreMap {
        keys = append(keys, key)
      }
      //对切片进行排序
      sort.Strings(keys)
      //按照排序后的key遍历map
      for _, key := range keys {
        fmt.Println(key, scoreMap[key])
      }
  }
  #+END_SRC
***** 元素为map类型的切片
+ 切片中的元素为map类型时的操作
  #+BEGIN_SRC go
  func main() {
      var mapSlice = make([]map[string]string, 3)
      for index, value := range mapSlice {
        fmt.Printf("index:%d value:%v\n", index, value)
      }
      fmt.Println("after init")
      // 对切片中的map元素进行初始化
      mapSlice[0] = make(map[string]string, 10)
      mapSlice[0]["name"] = "小王子"
      mapSlice[0]["password"] = "123456"
      mapSlice[0]["address"] = "沙河"
      for index, value := range mapSlice {
        fmt.Printf("index:%d value:%v\n", index, value)
      }
  }

  #+END_SRC
***** 值为切片类型的map
+ map中值为切片类型的操作
  #+BEGIN_SRC go
  func main() {
      var sliceMap = make(map[string][]string, 3)
      fmt.Println(sliceMap)
      fmt.Println("after init")
      key := "中国"
      value, ok := sliceMap[key]
      if !ok {
        value = make([]string, 0, 2)
      }
      value = append(value, "北京", "上海")
      sliceMap[key] = value
      fmt.Println(sliceMap)
  }
  #+END_SRC
**** 指针
***** Go语言中的指针
+ 任何程序数据载入内存后，在内存都有他们的地址，这就是指针。而为了保存一个数据在内存中的地址，我们就需要指针变量
+ 比如，“永远不要高估自己”这句话是我的座右铭，我想把它写入程序中，程序一启动这句话是要加载到内存（假设内存地址0x123456），我在程序中把这段话赋值给变量A，把内存地址赋值给变量B。这时候变量B就是一个指针变量。通过变量A和变量B都能找到我的座右铭
+ Go语言中的指针不能进行偏移和运算，因此Go语言中的指针操作非常简单，我们只需要记住两个符号：&（取地址）和*（根据地址取值）
***** 指针地址和指针类型
+ 每个变量在运行时都拥有一个地址，这个地址代表变量在内存中的位置。Go语言中使用&字符放在变量前面对变量进行“取地址”操作。 Go语言中的值类型（int、float、bool、string、array、struct）都有对应的指针类型，如：*int、*int64、*string等
+ 取变量指针的语法
  #+BEGIN_SRC go
  ptr := &v    // v的类型为T
  // v:代表被取地址的变量，类型为T
  // ptr:用于接收地址的变量，ptr的类型就为*T，称做T的指针类型。*代表指针

  func main() {
    	a := 10
	    b := &a
	    fmt.Printf("a:%d ptr:%p\n", a, &a) // a:10 ptr:0xc00001a078
	    fmt.Printf("b:%p type:%T\n", b, b) // b:0xc00001a078 type:*int
	    fmt.Println(&b)                    // 0xc00000e018
  }
  #+END_SRC
+ b := &a的[[file:pic/%E6%8C%87%E9%92%88%E5%9B%BE%E7%A4%BA.png][图例]]
***** 指针取值
+ 在对普通变量使用&操作符取地址后会获得这个变量的指针，然后可以对指针使用*操作，也就是指针取值
  #+BEGIN_SRC go
  func main() {
      //指针取值
      a := 10
      b := &a // 取变量a的地址，将指针保存到b中
      fmt.Printf("type of b:%T\n", b)
      c := *b // 指针取值（根据指针去内存取值）
      fmt.Printf("type of c:%T\n", c)
      fmt.Printf("value of c:%v\n", c)
  }
  // 输出如下
  type of b:*int
  type of c:int
  value of c:10
  #+END_SRC
+ 取地址操作符&和取值操作符*是一对互补操作符，&取出地址，*根据地址取出地址指向的值
+ 变量、指针地址、指针变量、取地址、取值的相互关系和特性如下
  - 对变量进行取地址（&）操作，可以获得这个变量的指针变量
  - 指针变量的值是指针地址
  - 对指针变量进行取值（*）操作，可以获得指针变量指向的原变量的值
+ 指针传值示例
  #+BEGIN_SRC go
  func modify1(x int) {
      x = 100
  }

  func modify2(x *int) {
      ,*x = 100
  }

  func main() {
      a := 10
      modify1(a)
      fmt.Println(a) // 10
      modify2(&a)
      fmt.Println(a) // 100
  }

  #+END_SRC
***** new和make
+ 执行下面的代码会引发panic，为什么呢？ 在Go语言中对于引用类型的变量，我们在使用的时候不仅要声明它，还要为它分配内存空间，否则我们的值就没办法存储。而对于值类型的声明不需要分配内存空间，是因为它们在声明的时候已经默认分配好了内存空间。要分配内存，就引出来今天的new和make。 Go语言中new和make是内建的两个函数，主要用来分配内存
  #+BEGIN_SRC go
  func main() {
      var a *int
      ,*a = 100
      fmt.Println(*a)

      var b map[string]int
      b["沙河娜扎"] = 100
      fmt.Println(b)
  }
  #+END_SRC
****** new
+ new是一个内置的函数，它的函数签名如下
  #+BEGIN_SRC go
  func new(Type) *Type
  // Type表示类型，new函数只接受一个参数，这个参数是一个类型
  // *Type表示类型指针，new函数返回一个指向该类型内存地址的指针。
  #+END_SRC
+ new函数不太常用，使用new函数得到的是一个类型的指针，并且该指针对应的值为该类型的零值
  #+BEGIN_SRC go
  func main() {
      a := new(int)
      b := new(bool)
      fmt.Printf("%T\n", a) // *int
      fmt.Printf("%T\n", b) // *bool
      fmt.Println(*a)       // 0
      fmt.Println(*b)       // false
  }	

  #+END_SRC
+ 示例代码中var a *int只是声明了一个指针变量a但是没有初始化，指针作为引用类型需要初始化后才会拥有内存空间，才可以给它赋值。应该按照如下方式使用内置的new函数对a进行初始化之后就可以正常对其赋值了
  #+BEGIN_SRC go
  func main() {
      var a *int
      a = new(int)
      ,*a = 10
      fmt.Println(*a)
    }

  #+END_SRC
****** make
+ make也是用于内存分配的，区别于new，它只用于slice、map以及chan的内存创建，而且它返回的类型就是这三个类型本身，而不是他们的指针类型，因为这三种类型就是引用类型，所以就没有必要返回他们的指针了。make函数的函数签名如下
  #+BEGIN_SRC go
  func make(t Type, size ...IntegerType) Type
  #+END_SRC
+ make函数是无可替代的，我们在使用slice、map以及channel的时候，都需要使用make进行初始化，然后才可以对它们进行操作
+ 示例中var b map[string]int只是声明变量b是一个map类型的变量，需要像下面的示例代码一样使用make函数进行初始化操作之后，才能对其进行键值对赋值
  #+BEGIN_SRC go
  func main() {
      var b map[string]int
      b = make(map[string]int, 10)
      b["沙河娜扎"] = 100
      fmt.Println(b)
  }
  #+END_SRC
****** new与make的区别
+ 二者都是用来做内存分配的
+ make只用于slice、map以及channel的初始化，返回的还是这三个引用类型本身
+ 而new用于类型的内存分配，并且内存对应的值为类型零值，返回的是指向类型的指针
**** 结构体（struct）
+ Go语言中没有“类”的概念，也不支持“类”的继承等面向对象的概念。Go语言中通过结构体的内嵌再配合接口比面向对象具有更高的扩展性和灵活性
+ 常用打印结构体结构和结构的语句
  fmt.Printf("%#v\n", 结构体变量)
***** 类型别名和自定义类型
****** 自定义类型
+ 在Go语言中有一些基本的数据类型，如string、整型、浮点型、布尔等数据类型， Go语言中可以使用type关键字来定义自定义类型
+ 自定义类型是定义了一个全新的类型。我们可以基于内置的基本类型定义，也可以通过struct定义
  #+BEGIN_SRC go
  //将MyInt定义为int类型
  type MyInt int
  // 通过type关键字的定义，MyInt就是一种新的类型，它具有int的特性
  #+END_SRC
****** 类型别名
+ 类型别名规定：TypeAlias只是Type的别名，本质上TypeAlias与Type是同一个类型。就像一个孩子小时候有小名
  #+BEGIN_SRC go
  type TypeAlias = Type

  type byte = uint8
  type rune = int32
  #+END_SRC
****** 自定义类型和类型别名的区别
+ 类型别名与自定义类型表面上看只有一个等号的差异，我们通过下面的这段代码来理解它们之间的区别
+ 自定义类型可以添加的方法并在其他包中引用，类型别名不能
+ 自定义类型 输出类型是属于一个全新的类型 而类型别名输出的是一个源头的类型，类型别名可以同相同类型进行计算，自定义类型则不能
+ 类型声明与类型别名最大区别在于: 类型别名和原类型是相同的, 而类型声明和原类型则是完全不同的两个东西, 只不过, 类型声明的新类型拥有与原类型相同的字段结构, 但, 不拥有任何原类型的方法
  #+BEGIN_SRC go
  //自定义类型
  type NewInt int

  //类型别名
  type MyInt = int

  func main() {
      var a NewInt
      var b MyInt
	
      fmt.Printf("type of a:%T\n", a) //type of a:main.NewInt
      fmt.Printf("type of b:%T\n", b) //type of b:int
  }

  #+END_SRC
***** 结构体
Go语言中的基础数据类型可以表示一些事物的基本属性，但是当我们想表达一个事物的全部或部分属性时，这时候再用单一的基本数据类型明显就无法满足需求了，Go语言提供了一种自定义数据类型，可以封装多个基本数据类型，这种数据类型叫结构体，英文名称struct。 也就是我们可以通过struct来定义自己的类型
****** 结构体的定义
+ 使用type和struct关键字来定义结构体
  #+BEGIN_SRC go
  type 类型名 struct {
        字段名 字段类型
        字段名 字段类型
        …
  }
  #+END_SRC
  - 类型名：标识自定义结构体的名称，在同一个包内不能重复
  - 字段名：表示结构体字段名。结构体中的字段名必须唯一
  - 字段类型：表示结构体字段的具体类型
+ 示例，我们定义一个Person（人）结构体
  #+BEGIN_SRC go
  type person struct {
	    name string
	    city string
	    age  int8
  }
  // 同样类型的字段也可以写在一行
  type person1 struct {
	    name, city string
	    age        int8
  }
  // 这样我们就拥有了一个person的自定义类型，它有name、city、age三个字段，分别表示姓名、城市和年龄。这样我们使用这个person结构体就能够很方便的在程序中表示和存储人信息了
  #+END_SRC
****** 结构体实例化
+ 只有当结构体实例化时，才会真正地分配内存。也就是必须实例化后才能使用结构体的字段
+ 结构体本身也是一种类型，我们可以像声明内置类型一样使用var关键字声明结构体类型
  #+BEGIN_SRC go
  var 结构体实例 结构体类型
  #+END_SRC
******* 基本实例化
+ 示例
  #+BEGIN_SRC go
  type person struct {
      name string
      city string
      age  int8
  }

  func main() {
      var p1 person
      p1.name = "沙河娜扎"
      p1.city = "北京"
      p1.age = 18
      fmt.Printf("p1=%v\n", p1)  //p1={沙河娜扎 北京 18}
      fmt.Printf("p1=%#v\n", p1) //p1=main.person{name:"沙河娜扎", city:"北京", age:18}
  }

  #+END_SRC
******* 匿名结构体
+ 在定义一些临时数据结构等场景下还可以使用匿名结构体
  #+BEGIN_SRC go
  package main
     
  import (
        "fmt"
  )
     
  func main() {
        var user struct{Name string; Age int}
        user.Name = "小王子"
        user.Age = 18
        fmt.Printf("%#v\n", user)
  }

  #+END_SRC
******* 创建指针类型结构体
+ 可以通过使用new关键字对结构体进行实例化，得到的是结构体的地址
  #+BEGIN_SRC go
  var p2 = new(person)
  fmt.Printf("%T\n", p2)     //*main.person
  fmt.Printf("p2=%#v\n", p2) //p2=&main.person{name:"", city:"", age:0}
  #+END_SRC
+ 在Go语言中支持对结构体指针直接使用.来访问结构体的成员
  #+BEGIN_SRC go
  var p2 = new(person)
  p2.name = "小王子"
  p2.age = 28
  p2.city = "上海"
  fmt.Printf("p2=%#v\n", p2) //p2=&main.person{name:"小王子", city:"上海", age:28}
  #+END_SRC
******* 取结构体的地址实化例
+ 使用&对结构体进行取地址操作相当于对该结构体类型进行了一次new实例化操作
  #+BEGIN_SRC go
  p3 := &person{}
  fmt.Printf("%T\n", p3)     //*main.person
  fmt.Printf("p3=%#v\n", p3) //p3=&main.person{name:"", city:"", age:0}
  p3.name = "七米"
  p3.age = 30
  p3.city = "成都"
  fmt.Printf("p3=%#v\n", p3) //p3=&main.person{name:"七米", city:"成都", age:30}
  // p3.name = "七米"其实在底层是(*p3).name = "七米"，这是Go语言帮我们实现的语法糖
  #+END_SRC
******* 结构体初始化
+ 没有初始化的结构体，其成员变量都是对应其类型的零值
  #+BEGIN_SRC go
  type person struct {
      name string
      city string
      age  int8
  }

  func main() {
      var p4 person
      fmt.Printf("p4=%#v\n", p4) //p4=main.person{name:"", city:"", age:0}
  }

  #+END_SRC
******* 使用键值对初始化
+ 使用键值对对结构体进行初始化时，键对应结构体的字段，值对应该字段的初始值
  #+BEGIN_SRC go
  p5 := person{
	    name: "小王子",
	    city: "北京",
	    age:  18,
      }
  fmt.Printf("p5=%#v\n", p5) //p5=main.person{name:"小王子", city:"北京", age:18}
  #+END_SRC
+ 也可以对结构体指针进行键值对初始化
  #+BEGIN_SRC go
  p6 := &person{
	    name: "小王子",
	    city: "北京",
	    age:  18,
      }
  fmt.Printf("p6=%#v\n", p6) //p6=&main.person{name:"小王子", city:"北京", age:18}
  #+END_SRC
+ 当某些字段没有初始值的时候，该字段可以不写。此时，没有指定初始值的字段的值就是该字段类型的零值
  #+BEGIN_SRC go
  p7 := &person{
	    city: "北京",
      }
  fmt.Printf("p7=%#v\n", p7) //p7=&main.person{name:"", city:"北京", age:0}
  #+END_SRC
******* 使用值的列表初始化
+ 初始化结构体的时候可以简写，也就是初始化的时候不写键，直接写值
  #+BEGIN_SRC go
  p8 := &person{
	    "沙河娜扎",
	    "北京",
	    28,
      }
  fmt.Printf("p8=%#v\n", p8) //p8=&main.person{name:"沙河娜扎", city:"北京", age:28}
  #+END_SRC
+ 使用这种格式初始化时，注意
  - 必须初始化结构体的所有字段
  - 初始值的填充顺序必须与字段在结构体中的声明顺序一致
  - 该方式不能和键值初始化方式混用
******* 结构体内存布局
+ 结构体占用一块连续的内存
  #+BEGIN_SRC go
  type test struct {
	    a int8
	    b int8
	    c int8
	    d int8
      }
  n := test{
    	1, 2, 3, 4,
  }
  fmt.Printf("n.a %p\n", &n.a)
  fmt.Printf("n.b %p\n", &n.b)
  fmt.Printf("n.c %p\n", &n.c)
  fmt.Printf("n.d %p\n", &n.d)
  // 输出：
  n.a 0xc0000a0060
  n.b 0xc0000a0061
  n.c 0xc0000a0062
  n.d 0xc0000a0063
  #+END_SRC
******* 空结构体
+ 空结构体是不占用空间的
  #+BEGIN_SRC go
  var v struct{}
  fmt.Println(unsafe.Sizeof(v))  // 0
  #+END_SRC
******* 构造函数
+ Go语言的结构体没有构造函数，我们可以自己实现。 例如，下方的代码就实现了一个person的构造函数。 因为struct是值类型，如果结构体比较复杂的话，值拷贝性能开销会比较大，所以该构造函数返回的是结构体指针类型
  #+BEGIN_SRC go
  func newPerson(name, city string, age int8) *person {
      return &person{
        name: name,
        city: city,
        age:  age,
      }
  }

  #+END_SRC
+ 调用构造函数
  #+BEGIN_SRC go
  p9 := newPerson("张三", "沙河", 90)
  fmt.Printf("%#v\n", p9) //&main.person{name:"张三", city:"沙河", age:90}
  #+END_SRC
****** 方法(method)
******* 方法
+ Go语言中的方法（Method）是一种作用于特定类型变量的函数。这种特定类型变量叫做接收者（Receiver）。接收者的概念就类似于其他语言中的this或者 self，可以理解为此方法从属于某个特定的结构类型，即该结构类型的方法
+ 方法的定义格式如下
  #+BEGIN_SRC go
  func (接收者变量 接收者类型) 方法名(参数列表) (返回参数) {
      函数体
  }
  #+END_SRC
+ 接收者变量：接收者中的参数变量名在命名时，官方建议使用接收者类型名称首字母的小写，而不是self、this之类的命名。例如，Person类型的接收者变量应该命名为 p，Connector类型的接收者变量应该命名为c等
+ 接收者类型：接收者类型和参数类似，可以是指针类型和非指针类型
+ 方法名、参数列表、返回参数：具体格式与函数定义相同
+ 方法与函数的区别是，函数不属于任何类型，方法属于特定的类型
+ 示例
  #+BEGIN_SRC go
  //Person 结构体
  type Person struct {
      name string
      age  int8
  }

  //NewPerson 构造函数
  func NewPerson(name string, age int8) *Person {
      return &Person{
        name: name,
        age:  age,
      }
  }

  //Dream Person做梦的方法
  func (p Person) Dream() {
      fmt.Printf("%s的梦想是学好Go语言！\n", p.name)
  }

  func main() {
      p1 := NewPerson("小王子", 25)
     (*p1).Dream()
      p1.Dream()
  }

  #+END_SRC
******* 指针类型的接收者
+ 指针类型的接收者由一个结构体的指针组成，由于指针的特性，调用方法时修改接收者指针的任意成员变量，在方法结束后，修改都是有效的。这种方式就十分接近于其他语言中面向对象中的this或者self。 例如我们为Person添加一个SetAge方法，来修改实例变量的年龄
  #+BEGIN_SRC go
  // SetAge 设置p的年龄
  // 使用指针接收者
  func (p *Person) SetAge(newAge int8) {
	    p.age = newAge
  }
  
  // 调用
  func main() {
    	p1 := NewPerson("小王子", 25)
	    fmt.Println(p1.age) // 25
	    p1.SetAge(30)
	    fmt.Println(p1.age) // 30
  }
  #+END_SRC
******* 值类型的接收者
+ 当方法作用于值类型接收者时，Go语言会在代码运行时将接收者的值复制一份。在值类型接收者的方法中可以获取接收者的成员值，但修改操作只是针对副本，无法修改接收者变量本身
  #+BEGIN_SRC go
  // SetAge2 设置p的年龄
  // 使用值接收者
  func (p Person) SetAge2(newAge int8) {
      p.age = newAge
  }

  func main() {
      p1 := NewPerson("小王子", 25)
      p1.Dream()
      fmt.Println(p1.age) // 25
      p1.SetAge2(30) // (*p1).SetAge2(30)
      fmt.Println(p1.age) // 25
  }

  #+END_SRC
******* 什么时候应该使用指针类型接收者
+ 要修改接收者中的值
+ 接收者是拷贝代价比较大的大对象
+ 保证一致性，如果有某个方法使用了指针接收者，那么其他的方法也应该使用指针接收者
******* 任意类型添加方法
+ 在Go语言中，接收者的类型可以是任何类型，不仅仅是结构体，任何类型都可以拥有方法。 举个例子，我们基于内置的int类型使用type关键字可以定义新的自定义类型，然后为我们的自定义类型添加方法
  #+BEGIN_SRC go
  //MyInt 将int定义为自定义MyInt类型
  type MyInt int

  //SayHello 为MyInt添加一个SayHello的方法
  func (m MyInt) SayHello() {
      fmt.Println("Hello, 我是一个int。")
  }
  func main() {
      var m1 MyInt
      m1.SayHello() //Hello, 我是一个int。
      m1 = 100
      fmt.Printf("%#v  %T\n", m1, m1) //100  main.MyInt
  }

  #+END_SRC

+ 非本地类型不能定义方法，也就是说我们不能给别的包的类型定义方法
****** 结构体的匿名字段
+ 结构体允许其成员字段在声明时没有字段名而只有类型，这种没有名字的字段就称为匿名字段
+ 匿名字段默认采用类型名作为字段名，结构体要求字段名称必须唯一，因此一个结构体中同种类型的匿名字段只能有一个
  #+BEGIN_SRC go
  //Person 结构体Person类型
  type Person struct {
      string
      int
  }

  func main() {
      p1 := Person{
        "小王子",
        18,
      }
      fmt.Printf("%#v\n", p1)        //main.Person{string:"北京", int:18}
      fmt.Println(p1.string, p1.int) //北京 18
  }

  #+END_SRC
****** 嵌套结构体
+ 一个结构体中可以嵌套包含另一个结构体或结构体指针
  #+BEGIN_SRC go
  //Address 地址结构体
  type Address struct {
      Province string
      City     string
  }

  //User 用户结构体
  type User struct {
      Name    string
      Gender  string
      Address Address
  }

  func main() {
      user1 := User{
        Name:   "小王子",
        Gender: "男",
        Address: Address{
          Province: "山东",
          City:     "威海",
        },
      }
      fmt.Printf("user1=%#v\n", user1)//user1=main.User{Name:"小王子", Gender:"男", Address:main.Address{Province:"山东", City:"威海"}}
  }
  #+END_SRC
****** 嵌套匿名结构体
+ 当访问结构体成员时会先在结构体中查找该字段，找不到再去匿名结构体中查找
  #+BEGIN_SRC go
  //Address 地址结构体
  type Address struct {
      Province string
      City     string
  }

  //User 用户结构体
  type User struct {
      Name    string
      Gender  string
      Address //匿名结构体
  }

  func main() {
      var user2 User
      user2.Name = "小王子"
      user2.Gender = "男"
      user2.Address.Province = "山东"    //通过匿名结构体.字段名访问
      user2.City = "威海"                //直接访问匿名结构体的字段名
      fmt.Printf("user2=%#v\n", user2) //user2=main.User{Name:"小王子", Gender:"男", Address:main.Address{Province:"山东", City:"威海"}}
  }

  #+END_SRC
****** 嵌套结构体的字段名冲突
+ 嵌套结构体内部可能存在相同的字段名。这个时候为了避免歧义需要指定具体的内嵌结构体的字段
  #+BEGIN_SRC go
  //Address 地址结构体
  type Address struct {
      Province   string
      City       string
      CreateTime string
  }

  //Email 邮箱结构体
  type Email struct {
      Account    string
      CreateTime string
  }

  //User 用户结构体
  type User struct {
      Name   string
      Gender string
      Address
      Email
  }

  func main() {
      var user3 User
      user3.Name = "沙河娜扎"
      user3.Gender = "男"
      // user3.CreateTime = "2019" //ambiguous selector user3.CreateTime
      user3.Address.CreateTime = "2000" //指定Address结构体中的CreateTime
      user3.Email.CreateTime = "2005"   //指定Email结构体中的CreateTime
  }

  #+END_SRC
****** 结构体的“继承”
+ Go语言中使用结构体也可以实现其他编程语言中面向对象的继承
  #+BEGIN_SRC go
  //Animal 动物
  type Animal struct {
      name string
  }

  func (a *Animal) move() {
      fmt.Printf("%s会动！\n", a.name)
  }

  //Dog 狗
  type Dog struct {
      Feet    int8
      ,*Animal //通过嵌套匿名结构体实现继承
  }

  func (d *Dog) wang() {
      fmt.Printf("%s会汪汪汪~\n", d.name)
  }

  func main() {
      d1 := &Dog{
        Feet: 4,
        Animal: &Animal{ //注意嵌套的是结构体指针
          name: "乐乐",
        },
      }
      d1.wang() //乐乐会汪汪汪~
      d1.move() //乐乐会动！
  }

  #+END_SRC
****** 结构体字段的可见性
+ 结构体中字段大写开头表示可公开访问，小写表示私有（仅在定义当前结构体的包中可访问）
****** 结构体与JSON序列化
+ JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。易于人阅读和编写。同时也易于机器解析和生成。JSON键值对是用来保存JS对象的一种方式，键/值对组合中的键名写在前面并用双引号""包裹，使用冒号:分隔，然后紧接着值；多个键值之间使用英文,分隔
  #+BEGIN_SRC go
  //Student 学生
  type Student struct {
      ID     int
      Gender string
      Name   string
  }

  //Class 班级
  type Class struct {
      Title    string
      Students []*Student
  }

  func main() {
      c := &Class{
        Title:    "101",
        Students: make([]*Student, 0, 200),
      }
      for i := 0; i < 10; i++ {
        stu := &Student{
          Name:   fmt.Sprintf("stu%02d", i),
          Gender: "男",
          ID:     i,
        }
        c.Students = append(c.Students, stu)
      }
      //JSON序列化：结构体-->JSON格式的字符串
      data, err := json.Marshal(c)
      if err != nil {
        fmt.Println("json marshal failed")
        return
      }
      fmt.Printf("json:%s\n", data)
      //JSON反序列化：JSON格式的字符串-->结构体
      str := `{"Title":"101","Students":[{"ID":0,"Gender":"男","Name":"stu00"},{"ID":1,"Gender":"男","Name":"stu01"},{"ID":2,"Gender":"男","Name":"stu02"},{"ID":3,"Gender":"男","Name":"stu03"},{"ID":4,"Gender":"男","Name":"stu04"},{"ID":5,"Gender":"男","Name":"stu05"},{"ID":6,"Gender":"男","Name":"stu06"},{"ID":7,"Gender":"男","Name":"stu07"},{"ID":8,"Gender":"男","Name":"stu08"},{"ID":9,"Gender":"男","Name":"stu09"}]}`
      c1 := &Class{}
      err = json.Unmarshal([]byte(str), c1)
      if err != nil {
        fmt.Println("json unmarshal failed!")
        return
      }
      fmt.Printf("%#v\n", c1)
  }

  #+END_SRC
****** 结构体标签（Tag）
+ Tag是结构体的元信息，key通常是指调用该结构体字段的包名称，value指给字段名指定的新名称，可以在运行的时候通过反射的机制读取出来。 Tag在结构体字段的后方定义，由一对反引号包裹起来，具体的格式如下
  #+BEGIN_SRC go
  `key1:"value1" key2:"value2"`
  #+END_SRC
+ 结构体标签由一个或多个键值对组成。键与值使用冒号分隔，值用双引号括起来。同一个结构体字段可以设置多个键值对标签（Tag），不同的键值对标签之间使用空格分隔
+ 为结构体编写Tag时，必须严格遵守键值对的规则。结构体标签的解析代码的容错能力很差，一旦格式写错，编译和运行时都不会提示任何错误，通过反射也无法正确取值。例如不要在key和value之间添加空格
+ 例如我们为Student结构体的每个字段定义json序列化时使用的Tag
  #+BEGIN_SRC go
  //Student 学生
  type Student struct {
      ID     int    `json:"id"` //通过指定tag实现json序列化该字段时的key
      Gender string //json序列化是默认使用字段名作为key
      name   string //私有不能被json包访问
  }

  func main() {
      s1 := Student{
        ID:     1,
        Gender: "男",
        name:   "沙河娜扎",
      }
      data, err := json.Marshal(s1)
      if err != nil {
        fmt.Println("json marshal failed!")
        return
      }
      fmt.Printf("json str:%s\n", data) //json str:{"id":1,"Gender":"男"}
  }

  #+END_SRC
****** 结构体和方法补充知识点
+ 因为slice和map这两种数据类型都包含了指向底层数据的指针，因此我们在需要复制它们时要特别注意
  #+BEGIN_SRC go
  type Person struct {
      name   string
      age    int8
      dreams []string
  }

  func (p *Person) SetDreams(dreams []string) {
      p.dreams = dreams
    }

    func main() {
      p1 := Person{name: "小王子", age: 18}
      data := []string{"吃饭", "睡觉", "打豆豆"}
      p1.SetDreams(data)

      // 你真的想要修改 p1.dreams 吗？
      data[1] = "不睡觉"
      fmt.Println(p1.dreams)  // ?
  }
  // 正确的做法是在方法中使用传入的slice的拷贝进行结构体赋值
  func (p *Person) SetDreams(dreams []string) {
	    p.dreams = make([]string, len(dreams))
	    copy(p.dreams, dreams)
  }
  // 同样的问题也存在于返回值slice和map的情况，在实际编码过程中一定要注意这个问题
  #+END_SRC
*** 运算符
+ 算术运算符
  ++（自增）和--（自减）在Go语言中是单独的语句，并不是运算符
  | 运算符 | 描述 |
  |--------+------|
  | " + "  | 相加 |
  | " - "  | 相减 |
  | " * "  | 相乘 |
  | " / "  | 相除 |
  | " % "  | 求余 |
+ 关系运算符
  | 运算符 | 描述                                                         |
  |--------+--------------------------------------------------------------|
  | " == " | 检查两个值是否相等，如果相等返回 True 否则返回 False         |
  | " != " | 检查两个值是否不相等，如果不相等返回 True 否则返回 False     |
  | " > "  | 检查左边值是否大于右边值，如果是返回 True 否则返回 False     |
  | " >= " | 检查左边值是否大于等于右边值，如果是返回 True 否则返回 False |
  | " < "  | 检查左边值是否小于右边值，如果是返回 True 否则返回 False     |
  | " <= " | 检查左边值是否小于等于右边值，如果是返回 True 否则返回 False |
+ 逻辑运算符
   &&  逻辑 AND 运算符。 如果两边的操作数都是 True，则为 True，否则为 False 
   ||  逻辑 OR 运算符。 如果两边的操作数有一个 True，则为 True，否则为 False
   !   逻辑 NOT 运算符。 如果条件为 True，则为 False，否则为 True
+ 位运算符
  位运算符对整数在内存中的二进制位进行操作
   &   参与运算的两数各对应的二进位相与。（两位均为1才为1） 
   |   参与运算的两数各对应的二进位相或。（两位有一个为1就为1）
   ^   参与运算的两数各对应的二进位相异或，当两对应的二进位相异时，结果为1。（两位不一样则为1）
   <<  左移n位就是乘以2的n次方。“a<<b”是把a的各二进位全部左移b位，高位丢弃，低位补0
   >>  右移n位就是除以2的n次方。“a>>b”是把a的各二进位全部右移b位
+ 赋值运算符
   =   简单的赋值运算符，将一个表达式的值赋给一个左值 
   +=  相加后再赋值                            
   -=  相减后再赋值                            
   *=  相乘后再赋值                            
   /=  相除后再赋值                            
   %=  求余后再赋值                            
   <<= 左移后赋值                              
   >>= 右移后赋值                              
   &=  按位与后赋值
   |=  按位或后赋值
   ^=  按位异或后赋值
*** 流程控制
**** if else(分支结构)
+ 基本写法
  #+BEGIN_SRC go
  if 表达式1 {
    分支1
  } else if 表达式2 {
    分支2
  } else{
    分支3
  }
  #+END_SRC
  - Go语言规定与if匹配的左括号"{"必须与if和表达式放在同一行，"{"放在其他位置会触发编译错误。 同理，与else匹配的"{"也必须与else写在同一行，else也必须与上一个if或else if右边的大括号在同一行
    #+BEGIN_SRC go
    func ifDemo1() {
      score := 65
      if score >= 90 {
        fmt.Println("A")
      } else if score > 75 {
        fmt.Println("B")
      } else {
        fmt.Println("C")
      }
    }
    #+END_SRC
+ 特殊写法
  可以在 if 表达式之前添加一个执行语句，再根据变量值进行判断
  #+BEGIN_SRC go
  func ifDemo2() {
      if score := 65; score >= 90 {
        fmt.Println("A")
      } else if score > 75 {
        fmt.Println("B")
      } else {
        fmt.Println("C")
      }
  }
  #+END_SRC
**** for(循环结构)
Go 语言中的所有循环类型均可以使用for关键字来完成
- 基本格式
  #+BEGIN_SRC go
  for 初始语句;条件表达式;结束语句{
      循环体语句
  }
  #+END_SRC
- 条件表达式返回true时循环体不停地进行循环，直到条件表达式返回false时自动退出循环
  #+BEGIN_SRC go
  func forDemo() {
      for i := 0; i < 10; i++ {
          fmt.Println(i)
      }
  }
  #+END_SRC
- for循环的初始语句可以被忽略，但是初始语句后的分号必须要写
  #+BEGIN_SRC go
  func forDemo2() {
      i := 0
      for ; i < 10; i++ {
          fmt.Println(i)
      }
  }
  #+END_SRC
- for循环的初始语句和结束语句都可以省略
  #+BEGIN_SRC go
  func forDemo3() {
      i := 0
      for i < 10 {
          fmt.Println(i)
          i++
      }
  }
  #+END_SRC
**** 无限循环
+ for循环可以通过break、goto、return、panic语句强制退出循环
  #+BEGIN_SRC go
  for {
      循环体语句
  }
  #+END_SRC
**** for range(键值循环)
+ Go语言中可以使用for range遍历数组、切片、字符串、map 及通道（channel）
+ 通过for range遍历的返回值有以下规律
  - 数组、切片、字符串返回索引和值
  - map返回键和值
  - 通道（channel）只返回通道内的值
**** switch case
+ 使用switch语句可方便地对大量的值进行条件判断
  #+BEGIN_SRC go
  func switchDemo1() {
      finger := 3
      switch finger {
      case 1:
        fmt.Println("大拇指")
      case 2:
        fmt.Println("食指")
      case 3:
        fmt.Println("中指")
      case 4:
        fmt.Println("无名指")
      case 5:
        fmt.Println("小拇指")
      default:
        fmt.Println("无效的输入！")
      }
  }
  #+END_SRC
+ Go语言规定每个switch只能有一个default分支
+ 一个分支可以有多个值，多个case值中间使用英文逗号分隔
  #+BEGIN_SRC go
  func testSwitch3() {
      switch n := 7; n {
      case 1, 3, 5, 7, 9:
        fmt.Println("奇数")
      case 2, 4, 6, 8:
        fmt.Println("偶数")
      default:
        fmt.Println(n)
      }
  }
  #+END_SRC
+ 分支还可以使用表达式，这时候switch语句后面不需要再跟判断变量
  #+BEGIN_SRC go
  func switchDemo4() {
      age := 30
      switch {
      case age < 25:
        fmt.Println("好好学习吧")
      case age > 25 && age < 35:
        fmt.Println("好好工作吧")
      case age > 60:
        fmt.Println("好好享受吧")
      default:
        fmt.Println("活着真好")
      }
  }
  #+END_SRC
+ fallthrough语法可以执行满足条件的case的下一个case，是为了兼容C语言中的case设计的
  #+BEGIN_SRC go
    func switchDemo5() {
        s := "a"
        switch {
        case s == "a":
          fmt.Println("a")
          fallthrough
        case s == "b":
          fmt.Println("b")
        case s == "c":
          fmt.Println("c")
        default:
          fmt.Println("...")
        }
    }
    // 输出
    // a
    // b
  #+END_SRC
**** goto(跳转到指定标签)
+ goto语句通过标签进行代码间的无条件跳转。goto语句可以在快速跳出循环、避免重复退出上有一定的帮助。Go语言中使用goto语句能简化一些代码的实现过程。 例如双层嵌套的for循环要退出时
  #+BEGIN_SRC go
  func gotoDemo1() {
      var breakFlag bool
      for i := 0; i < 10; i++ {
        for j := 0; j < 10; j++ {
          if j == 2 {
            // 设置退出标签
            breakFlag = true
            break
          }
          fmt.Printf("%v-%v\n", i, j)
        }
        // 外层for循环判断
        if breakFlag {
          break
        }
      }
  }
  // 使用goto语句能简化代码：
  func gotoDemo2() {
      for i := 0; i < 10; i++ {
        for j := 0; j < 10; j++ {
          if j == 2 {
            // 设置退出标签
            goto breakTag
          }
          fmt.Printf("%v-%v\n", i, j)
        }
      }
      return
      // 标签
    breakTag:
      fmt.Println("结束for循环")
  }
  #+END_SRC
**** break(跳出循环)
+ break语句可以结束for、switch和select的代码块
+ break语句还可以在语句后面添加标签，表示退出某个标签对应的代码块，标签要求必须定义在对应的for、switch和 select的代码块上
  #+BEGIN_SRC go
  func breakDemo1() {
  BREAKDEMO1:
      for i := 0; i < 10; i++ {
        for j := 0; j < 10; j++ {
          if j == 2 {
            break BREAKDEMO1
          }
          fmt.Printf("%v-%v\n", i, j)
        }
      }
      fmt.Println("...")
  }
  #+END_SRC
**** continue(继续下次循环)
+ continue语句可以结束当前循环，开始下一次的循环迭代过程，仅限在for循环内使用。
+ 在 continue语句后添加标签时，表示开始标签对应的循环
  #+BEGIN_SRC go
  func continueDemo() {
  forloop1:
      for i := 0; i < 5; i++ {
        // forloop2:
        for j := 0; j < 5; j++ {
          if i == 2 && j == 2 {
            continue forloop1
          }
          fmt.Printf("%v-%v\n", i, j)
        }
      }
  }
  #+END_SRC
*** 函数
**** go函数特点
+ Go语言中支持函数、匿名函数和闭包，并且函数在Go语言中属于“一等公民”
+ 无需声明原型、支持不定长度变参、多返回值、命名返回值参数、匿名函数、闭包
+ 不支持嵌套、重载和默认参数
+ 函数也可以作为一种类型使用
**** 定义
+ 定义函数使用func关键字
  #+BEGIN_SRC go
  func 函数名(参数)(返回值){
    函数体
  }
  #+END_SRC
+ 函数名：由字母、数字、下划线组成。但函数名的第一个字母不能是数字。在同一个包内，函数名也称不能重名
+ 参数：参数由参数变量和参数变量的类型组成，多个参数之间使用,分隔
+ 返回值：返回值由返回值变量和其变量类型组成，也可以只写返回值的类型，多个返回值必须用()包裹，并用,分隔
+ 函数体：实现指定功能的代码块
+ 函数的参数和返回值都是可选的
+ 示例
  #+BEGIN_SRC go
  func intSum(x int, y int) int {
      return x + y
  }

  func sayHello() {
      fmt.Println("Hello 沙河")
  }
  #+END_SRC
**** 调用
+ 定义了函数之后，我们可以通过函数名()的方式调用函数。 例如我们调用上面定义的两个函数
  #+BEGIN_SRC go
  func main() {
      sayHello()
      ret := intSum(10, 20)
      fmt.Println(ret)
  }
  #+END_SRC
+ 调用有返回值的函数时，可以不接收其返回值
**** 参数
+ 类型简写
  函数的参数中如果相邻变量的类型相同，则可以省略类型
  #+BEGIN_SRC go
  func intSum(x, y int) int {
	    return x + y
  }
  // 上面的代码中，intSum函数有两个参数，这两个参数的类型均为int，因此可以省略x的类型，因为y后面有类型说明，x参数也是该类型
  #+END_SRC
+ 可变参数
  - 可变参数是指函数的参数数量不固定。Go语言中的可变参数通过在参数名后加...来标识
  - 注意：可变参数通常要作为函数的最后一个参数,本质上，函数的可变参数是通过切片来实现的
    #+BEGIN_SRC go
    func intSum2(x ...int) int {
        fmt.Println(x) //x是一个切片
        sum := 0
        for _, v := range x {
          sum = sum + v
        }
        return sum
    }
    // 调用上面的函数
    ret1 := intSum2()
    ret2 := intSum2(10)
    ret3 := intSum2(10, 20)
    ret4 := intSum2(10, 20, 30)
    fmt.Println(ret1, ret2, ret3, ret4) //0 10 30 60
    #+END_SRC  
  - 固定参数搭配可变参数使用时，可变参数要放在固定参数的后面
    #+BEGIN_SRC go
    func intSum3(x int, y ...int) int {
        fmt.Println(x, y)
        sum := x
        for _, v := range y {
          sum = sum + v
        }
        return sum
    }
    // 调用上述函数：
    ret5 := intSum3(100)
    ret6 := intSum3(100, 10)
    ret7 := intSum3(100, 10, 20)
    ret8 := intSum3(100, 10, 20, 30)
    fmt.Println(ret5, ret6, ret7, ret8) //100 110 130 160
    #+END_SRC
**** 返回值
+ 通过return关键字向外输出返回值
+ 多返回值:Go语言中函数支持多返回值，函数如果有多个返回值时必须用()将所有返回值包裹起来
  #+BEGIN_SRC go
  func calc(x, y int) (int, int) {
      sum := x + y
      sub := x - y
      return sum, sub
  }
  #+END_SRC
+ 返回值命名:函数定义时可以给返回值命名，并在函数体中直接使用这些变量，最后通过return关键字返回
  #+BEGIN_SRC go
  func calc(x, y int) (sum, sub int) {
      sum = x + y
      sub = x - y
      return
  }
  #+END_SRC
+ 返回值补充:当我们的一个函数返回值类型为slice时，nil可以看做是一个有效的slice，没必要显示返回一个长度为0的切片
  #+BEGIN_SRC go
  func someFunc(x string) []int {
      if x == "" {
        return nil // 没必要返回[]int{}
      }
      ...
  }
  #+END_SRC
*** 函数进阶
**** 变量作用域
+ 全局变量
  全局变量是定义在函数外部的变量，它在程序整个运行周期内都有效。 在函数中可以访问到全局变量
  #+BEGIN_SRC go
  package main

  import "fmt"

  //定义全局变量num
  var num int64 = 10

  func testGlobalVar() {
      fmt.Printf("num=%d\n", num) //函数中可以访问全局变量num
  }
  func main() {
      testGlobalVar() //num=10
  }
  #+END_SRC

+ 局部变量
  - 函数内定义的变量无法在该函数外使用
    #+BEGIN_SRC go
    func testLocalVar() {
    //定义一个函数局部变量x,仅在该函数内生效
        var x int64 = 100
        fmt.Printf("x=%d\n", x)
    }

    func main() {
        testLocalVar()
        fmt.Println(x) // 此时无法使用变量x
    }
    #+END_SRC
  - 局部变量和全局变量重名，优先访问局部变量
    #+BEGIN_SRC go
    package main
    
    import "fmt"
    
    //定义全局变量num
    var num int64 = 10

    func testNum() {
        num := 100
        fmt.Printf("num=%d\n", num) // 函数中优先使用局部变量
    }
    func main() {
        testNum() // num=100
    }
    #+END_SRC
  - 语句块定义的变量，通常我们会在if条件判断、for循环、switch语句上使用这种定义变量的方式
    #+BEGIN_SRC go
    func testLocalVar2(x, y int) {
        fmt.Println(x, y) //函数的参数也是只在本函数中生效
        if x > 0 {
          z := 100 //变量z只在if语句块生效
          fmt.Println(z)
        }
        //fmt.Println(z)//此处无法使用变量z
    }
    #+END_SRC
**** 函数类型与变量
***** 定义函数类型
+ 可以使用type关键字来定义一个函数类型
  #+BEGIN_SRC go
  type calculation func(int, int) int
  // 上面语句定义了一个calculation类型，它是一种函数类型，这种函数接收两个int类型的参数并且返回一个int类型的返回值
  // 简单来说，凡是满足这个条件的函数都是calculation类型的函数，例如下面的add和sub是calculation类型
  func add(x, y int) int {
	    return x + y
  }

  func sub(x, y int) int {
	    return x - y
  }
  // add和sub都能赋值给calculation类型的变量
  var c calculation
  c = add
  #+END_SRC
***** 函数类型变量
+ 可以声明函数类型的变量并且为该变量赋值
  #+BEGIN_SRC go
  func main() {
      var c calculation               // 声明一个calculation类型的变量c
      c = add                         // 把add赋值给c
      fmt.Printf("type of c:%T\n", c) // type of c:main.calculation
      fmt.Println(c(1, 2))            // 像调用add一样调用c

      f := add                        // 将函数add赋值给变量f
      fmt.Printf("type of f:%T\n", f) // type of f:func(int, int) int
      fmt.Println(f(10, 20))          // 像调用add一样调用f
  }
  #+END_SRC
**** 高阶函数
***** 函数作为参数
+ 函数可以作为参数
  #+BEGIN_SRC go
  func add(x, y int) int {
      return x + y
    }
    func calc(x, y int, op func(int, int) int) int {
      return op(x, y)
    }
    func main() {
      ret2 := calc(10, 20, add)
      fmt.Println(ret2) //30
  }
  #+END_SRC
***** 函数作为返回值
+ 函数也可以作为返回值
  #+BEGIN_SRC go
  func do(s string) (func(int, int) int, error) {
      switch s {
      case "+":
        return add, nil
      case "-":
        return sub, nil
      default:
        err := errors.New("无法识别的操作符")
        return nil, err
      }
  }

  #+END_SRC
**** 匿名函数和闭包
***** 匿名函数
+ 函数当然还可以作为返回值，但是在Go语言中函数内部不能再像之前那样定义函数了，只能定义匿名函数。匿名函数就是没有函数名的函数，多用于实现回调函数和闭包
  #+BEGIN_SRC go
  func(参数)(返回值){
      函数体
  }
  #+END_SRC
+ 匿名函数因为没有函数名，所以没办法像普通函数那样调用，所以匿名函数需要保存到某个变量或者作为立即执行函数
  #+BEGIN_SRC go
  func main() {
      // 将匿名函数保存到变量
      add := func(x, y int) {
        fmt.Println(x + y)
      }
      add(10, 20) // 通过变量调用匿名函数

      //自执行函数：匿名函数定义完加()直接执行
      func(x, y int) {
        fmt.Println(x + y)
      }(10, 20)
  }
  #+END_SRC
+ 匿名函数多用于实现回调函数和闭包
***** 闭包
+ 闭包指的是一个函数和与其相关的引用环境组合而成的实体。简单来说，闭包=函数+引用环境(引用外层的变量)
  #+BEGIN_SRC go
  func adder() func(int) int {
      var x int
      return func(y int) int {
        x += y
        return x
      }
  }
  func main() {
      var f = adder()
      fmt.Println(f(10)) //10
      fmt.Println(f(20)) //30
      fmt.Println(f(30)) //60

      f1 := adder()
      fmt.Println(f1(40)) //40
      fmt.Println(f1(50)) //90
  }
  #+END_SRC

+ 变量f是一个函数并且它引用了其外部作用域中的x变量，此时f就是一个闭包。 在f的生命周期内，变量x也一直有效。 闭包进阶示例1
  #+BEGIN_SRC go
  func adder2(x int) func(int) int {
      return func(y int) int {
        x += y
        return x
      }
  }
  func main() {
      var f = adder2(10)
      fmt.Println(f(10)) //20
      fmt.Println(f(20)) //40
      fmt.Println(f(30)) //70

      f1 := adder2(20)
      fmt.Println(f1(40)) //60
      fmt.Println(f1(50)) //110
  }
  #+END_SRC
+ 闭包进阶示例2
  #+BEGIN_SRC go
  func makeSuffixFunc(suffix string) func(string) string {
      return func(name string) string {
        if !strings.HasSuffix(name, suffix) {
          return name + suffix
        }
        return name
      }
    }

  func main() {
      jpgFunc := makeSuffixFunc(".jpg")
      txtFunc := makeSuffixFunc(".txt")
      fmt.Println(jpgFunc("test")) //test.jpg
      fmt.Println(txtFunc("test")) //test.txt
  }
  #+END_SRC
+ 闭包进阶示例3
  #+BEGIN_SRC go
  func calc(base int) (func(int) int, func(int) int) {
      add := func(i int) int {
        base += i
        return base
      }

      sub := func(i int) int {
        base -= i
        return base
      }
      return add, sub
  }

  func main() {
      f1, f2 := calc(10)
      fmt.Println(f1(1), f2(2)) //11 9
      fmt.Println(f1(3), f2(4)) //12 8
      fmt.Println(f1(5), f2(6)) //13 7
  }
  #+END_SRC
**** defer语句
***** 介绍
+ defer的执行方式类似其他语言中的析构函数，在函数体执行结束后按照调用顺序的相反顺序逐个执行
+ 即使函数发生严重错误也会执行
+ 支持匿名函数的调用
+ 常用于资源清理、文件关闭、解锁以及记录时间等操作
+ 通过与匿名函数配合可以在return之后修改计算结果
+ 如果函数体内某个变量作为defer时匿名函数的参数，则在定义defer时即已获得了拷贝，否则则是引用某个变量的地址
***** 基础
+ Go语言中的defer语句会将其后面跟随的语句进行延迟处理。在defer归属的函数即将返回时，将延迟处理的语句按defer定义的逆序进行执行，也就是说，先被defer的语句最后被执行，最后被defer的语句，最先被执行
  #+BEGIN_SRC go
  func main() {
      fmt.Println("start")
      defer fmt.Println(1)
      defer fmt.Println(2)
      defer fmt.Println(3)
      fmt.Println("end")
  }
  // 输出结果：
  start
  end
  3
  2
  1
  #+END_SRC
+ 由于defer语句延迟调用的特性，所以defer语句能非常方便的处理资源释放问题。比如：资源清理、文件关闭、解锁及记录时间等
***** defer执行时机
+ 在Go语言的函数中return语句在底层并不是原子操作，它分为给返回值赋值和RET指令两步。而defer语句执行的时机就在返回值赋值操作后，RET指令执行前[[file:pic/defer%E6%89%A7%E8%A1%8C%E6%97%B6%E6%9C%BA.png][图例]]
***** defer经典案例
+ 示例
  #+BEGIN_SRC go
  func f1() int {
      x := 5
      defer func() {
        x++
      }()
      return x
  }

  func f2() (x int) {
      defer func() {
        x++
      }()
      return 5
  }

  func f3() (y int) {
      x := 5
      defer func() {
        x++
      }()
      return x
  }
  func f4() (x int) {
      defer func(x int) {
        x++
      }(x)
      return 5
  }
  func main() {
      fmt.Println(f1())
      fmt.Println(f2())
      fmt.Println(f3())
      fmt.Println(f4())
  }
  #+END_SRC
**** 内置函数
+ 常用内置函数
  | 内置函数       | 介绍                                                            |
  |----------------+-----------------------------------------------------------------|
  | close          | 主要用来关闭channel                                             |
  | len            | 用来求长度，比如string、array、slice、map、channel              |
  | new            | 用来分配内存，主要用来分配值类型，比如int、struct。返回的是指针 |
  | make           | 用来分配内存，主要用来分配引用类型，比如chan、map、slice        |
  | append         | 用来追加元素到数组、slice中                                     |
  | panic和recover | 用来做错误处理                                                  |
+ panic/recover
  - Go语言中目前（Go1.12）是没有异常机制，但是使用panic/recover模式来处理错误。 panic可以在任何地方引发，但recover只有在defer调用的函数中有效
    #+BEGIN_SRC go
    func funcA() {
        fmt.Println("func A")
    }

    func funcB() {
        panic("panic in B")
    }

    func funcC() {
        fmt.Println("func C")
    }
    func main() {
        funcA()
        funcB()
        funcC()
    }
    // 输出：
    func A
    panic: panic in B

    goroutine 1 [running]:
    main.funcB(...)
        .../code/func/main.go:12
    main.main()
        .../code/func/main.go:20 +0x98
    #+END_SRC
  - 程序运行期间funcB中引发了panic导致程序崩溃，异常退出了。这个时候我们就可以通过recover将程序恢复回来，继续往后执行
    #+BEGIN_SRC go
    func funcA() {
        fmt.Println("func A")
    }

    func funcB() {
        defer func() {
          err := recover()
          //如果程序出出现了panic错误,可以通过recover恢复过来
          if err != nil {
            fmt.Println("recover in B")
          }
        }()
        panic("panic in B")
    }

    func funcC() {
        fmt.Println("func C")
    }
    func main() {
        funcA()
        funcB()
        funcC()
    }

    #+END_SRC
  - recover()必须搭配defer使用
  - defer一定要在可能引发panic的语句之前定义
*** 包（package）
**** 介绍
+ 在工程化的Go语言开发项目中，Go语言的源码复用是建立在包（package）基础之上的
+ 包（package）是多个Go源码的集合，是一种高级的代码复用方案，Go语言为我们提供了很多内置包，如fmt、os、io等
**** 定义包
+ 可以根据自己的需要创建自己的包。一个包可以简单理解为一个存放.go文件的文件夹。 该文件夹下面的所有go文件都要在代码的第一行添加如下代码，声明该文件归属的包
  #+BEGIN_SRC go
  package 包名
  #+END_SRC
+ 一个文件夹下面直接包含的文件只能归属一个package，同样一个package的文件不能在多个文件夹下
+ 包名可以不和文件夹的名字一样，包名不能包含 - 符号
+ 包名为main的包为应用程序的入口包，这种包编译后会得到一个可执行文件，而编译不包含main包的源代码则不会得到可执行文件
**** 可见性
+ 如果想在一个包中引用另外一个包里的标识符（如变量、常量、类型、函数等）时，该标识符必须是对外可见的（public）。在Go语言中只需要将标识符的首字母大写就可以让标识符对外可见
  #+BEGIN_SRC go
  package pkg2

  import "fmt"

  // 包变量可见性

  var a = 100 // 首字母小写，外部包不可见，只能在当前包内使用

  // 首字母大写外部包可见，可在其他包中使用
  const Mode = 1
  
  type person struct { // 首字母小写，外部包不可见，只能在当前包内使用
      name string
  }

  // 首字母大写，外部包可见，可在其他包中使用
  func Add(x, y int) int {
      return x + y
  }

  func age() { // 首字母小写，外部包不可见，只能在当前包内使用
      var Age = 18 // 函数局部变量，外部包不可见，只能在当前函数内使用
      fmt.Println(Age)
  }

  #+END_SRC

+ 结构体中的字段名和接口中的方法名如果首字母都是大写，外部包可以访问这些字段和方法
  #+BEGIN_SRC go
  type Student struct {
      Name  string //可在包外访问的方法
      class string //仅限包内访问的字段
  }

  type Payer interface {
      init() //仅限包内访问的方法
      Pay()  //可在包外访问的方法
  }

  #+END_SRC
**** 导入
+ 要在代码中引用其他包的内容，需要使用import关键字导入使用的包
  #+BEGIN_SRC go
  import "包的路径"
  #+END_SRC
+ 注意事项
  - import导入语句通常放在文件开头包声明语句的下面
  - 导入的包名需要使用双引号包裹起来
  - 包名是从$GOPATH/src/后开始计算的，使用/进行路径分隔
  - Go语言中禁止循环导入包
+ 单行导入
  #+BEGIN_SRC go
  import "包1"
  import "包2"
  #+END_SRC
+ 多行导入
  #+BEGIN_SRC go
  import (
      "包1"
      "包2"
  )
  #+END_SRC
+ 自定义包名
  - 在导入包名的时候，我们还可以为导入的包设置别名。通常用于导入的包名太长或者导入的包名冲突的情况
    #+BEGIN_SRC go
    import 别名 "包的路径"
    #+END_SRC
  - 单行导入方式定义别名
    #+BEGIN_SRC go
    import "fmt"
    import m "github.com/Q1mi/studygo/pkg_test"

    func main() {
        fmt.Println(m.Add(100, 200))
        fmt.Println(m.Mode)
    }

    #+END_SRC
  - 多行导入方式定义别名
    #+BEGIN_SRC go
    import (
          "fmt"
          m "github.com/Q1mi/studygo/pkg_test"
    )

    func main() {
        fmt.Println(m.Add(100, 200))
        fmt.Println(m.Mode)
    }

    #+END_SRC
+ 匿名导入包
  - 如果只希望导入包，而不使用包内部的数据时，可以使用匿名导入包
    #+BEGIN_SRC go
    import _ "包的路径"
    #+END_SRC
  - 匿名导入的包与其他方式导入的包一样都会被编译到可执行文件中
**** init()初始化函数
+ 介绍
  - 在Go语言程序执行时导入包语句会自动触发包内部init()函数的调用。需要注意的是： init()函数没有参数也没有返回值。 init()函数在程序运行时自动被调用执行，不能在代码中主动调用它
  - 包初始化执行的顺序[[file:pic/%E5%8C%85init%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E6%97%B6%E6%9C%BA.png][图例]]
+ init()函数执行顺序
  - Go语言包会从main包开始检查其导入的所有包，每个包中又可能导入了其他的包。Go编译器由此构建出一个树状的包引用关系，再根据引用顺序决定编译顺序，依次编译这些包的代码
  - 在运行时，被最后导入的包会最先初始化并调用其init()函数[[file:pic/%E5%AF%BC%E5%85%A5%E5%8C%85%E9%A1%BA%E5%BA%8F.png][图例]]
*** 接口（interface）
**** 介绍
+ 接口定义了一个对象的行为规范，只定义规范不实现，由具体的对象来实现规范的细节,关于接口需要注意的是，只有当有两个或两个以上的具体类型必须以相同的方式进行处理时才需要定义接口。不要为了接口而写接口，那样只会增加不必要的抽象，导致不必要的运行时损耗
+ 接口是一个方法或多个方法签名的集合
+ 只要某个类型拥有该接口的所有方法签名，即算实现该接口，无需显示声明实现了哪个接口，这称为Structural Type
+ 接口只有方法声明，没有实现，没有数据字段
+ 接口可以匿名嵌入其他接口，或嵌入到结构体中
+ 将对象赋值给接口时，会发生拷贝，而接口内部存储的是指向这个复制品的指针，即无法修改复制品的状态，也无法获取指针
+ 只有当接口存储的类型和对象都为nil时，接口才等于nil
+ 接口调用不会做receiver的自动转换
+ 接口同样支持匿名字段方法
+ 接口可以实现类似OOP中的多态
+ 空接口可以作为任何类型数据的容器
**** 接口类型
+ 在Go语言中接口（interface）是一种类型，一种抽象的类型
+ 接口是一组method的集合，是duck-type programming的一种体现。接口做的事情就像是定义一个协议（规则），只要一台机器有洗衣服和甩干的功能，我就称它为洗衣机。不关心属性（数据），只关心行为（方法）
**** 为什么要使用接口
+ 下面的代码中定义了猫和狗，然后它们都会叫，你会发现main函数中明显有重复的代码，如果我们后续再加上猪、青蛙等动物的话，我们的代码还会一直重复下去。那我们能不能把它们当成“能叫的动物”来处理呢？比如销售、行政、程序员都能计算月薪，我们能不能把他们当成“员工”来处理呢？
  #+BEGIN_SRC go
  type Cat struct{}

  func (c Cat) Say() string { return "喵喵喵" }
  
  type Dog struct{}

  func (d Dog) Say() string { return "汪汪汪" }

  func main() {
      c := Cat{}
      fmt.Println("猫:", c.Say())
      d := Dog{}
      fmt.Println("狗:", d.Say())
  }
  #+END_SRC
+ Go语言中为了解决类似上面的问题，就设计了接口这个概念。接口区别于我们之前所有的具体类型，接口是一种抽象的类型。当你看到一个接口类型的值时，你不知道它是什么，唯一知道的是通过它的方法能做什么
**** 定义
+ Go语言提倡面向接口编程
+ 每个接口由数个方法组成，接口的定义格式如下
  #+BEGIN_SRC go
  type 接口类型名 interface{
      方法名1( 参数列表1 ) 返回值列表1
      方法名2( 参数列表2 ) 返回值列表2
      …
  }
  #+END_SRC
+ 接口名：使用type将接口定义为自定义的类型名。Go语言的接口在命名时，一般会在单词后面添加er，如有写操作的接口叫Writer，有字符串功能的接口叫Stringer等。接口名最好要能突出该接口的类型含义
+ 方法名：当方法名首字母是大写且这个接口类型名首字母也是大写时，这个方法可以被接口所在的包（package）之外的代码访问
+ 参数列表、返回值列表：参数列表和返回值列表中的参数变量名可以省略
+ 当看到这个接口类型的值时，你不知道它是什么，唯一知道的就是可以通过它的Write方法来做一些事情
  #+BEGIN_SRC go
  type writer interface{
      Write([]byte) error
  }
  #+END_SRC
**** 实现接口的条件
+ 一个对象只要全部实现了接口中的方法，那么就实现了这个接口。换句话说，接口就是一个需要实现的方法列表
+ 例如定义一个Sayer接口
  #+BEGIN_SRC go
  // Sayer 接口
  type Sayer interface {
	    say()
  }
  #+END_SRC
+ 定义dog和cat两个结构体
  #+BEGIN_SRC go
  type dog struct {}

  type cat struct {}
  #+END_SRC
+ 因为Sayer接口里只有一个say方法，所以我们只需要给dog和cat 分别实现say方法就可以实现Sayer接口了
  #+BEGIN_SRC go
  // dog实现了Sayer接口
  func (d dog) say() {
	    fmt.Println("汪汪汪")
  }

  // cat实现了Sayer接口
  func (c cat) say() {
	    fmt.Println("喵喵喵")
  }
  #+END_SRC
**** 接口类型变量
+ 接口类型变量能够存储所有实现了该接口的实例。 例如上面的示例中，Sayer类型的变量能够存储dog和cat类型的变量
  #+BEGIN_SRC go
  func main() {
      var x Sayer // 声明一个Sayer类型的变量x
      a := cat{}  // 实例化一个cat
      b := dog{}  // 实例化一个dog
      x = a       // 可以把cat实例直接赋值给x
      x.say()     // 喵喵喵
      x = b       // 可以把dog实例直接赋值给x
      x.say()     // 汪汪汪
  }
  #+END_SRC
**** 值接收者和指针接收者实现接口的区别
+ 有一个Mover接口和一个dog结构体
  #+BEGIN_SRC go
  type Mover interface {
	    move()
  }

  type dog struct {}
  #+END_SRC
+ 值接收者实现接口
  #+BEGIN_SRC go
  func (d dog) move() {
    	fmt.Println("狗会动")
  }
  // 此时实现接口的是dog类型

  func main() {
    	var x Mover
	    var wangcai = dog{} // 旺财是dog类型
	    x = wangcai         // x可以接收dog类型
	    var fugui = &dog{}  // 富贵是*dog类型
	    x = fugui           // x可以接收*dog类型
	    x.move()
  }
  // 使用值接收者实现接口之后，不管是dog结构体还是结构体指针*dog类型的变量都可以赋值给该接口变量。因为Go语言中有对指针类型变量求值的语法糖，dog指针fugui内部会自动求值*fugui
  #+END_SRC
+ 指针接收者实现接口
  #+BEGIN_SRC go
  func (d *dog) move() {
      fmt.Println("狗会动")
  }
  func main() {
      var x Mover
      var wangcai = dog{} // 旺财是dog类型
      x = wangcai         // x不可以接收dog类型
      var fugui = &dog{}  // 富贵是*dog类型
      x = fugui           // x可以接收*dog类型
  }
  // 此时实现Mover接口的是*dog类型，所以不能给x传入dog类型的wangcai，此时x只能存储*dog类型的值
  #+END_SRC
**** 类型与接口的关系
***** 一个类型实现多个接口
+ 一个类型可以同时实现多个接口，而接口间彼此独立，不知道对方的实现。 例如，狗可以叫，也可以动。我们就分别定义Sayer接口和Mover接口，如下： Mover接口
  #+BEGIN_SRC go
  // Sayer 接口
  type Sayer interface {
      say()
  }

  // Mover 接口
  type Mover interface {
      move()
  }
  
  // dog既可以实现Sayer接口，也可以实现Mover接口
  type dog struct {
	    name string
  }

  // 实现Sayer接口
  func (d dog) say() {
	    fmt.Printf("%s会叫汪汪汪\n", d.name)
  }

  // 实现Mover接口
  func (d dog) move() {
	    fmt.Printf("%s会动\n", d.name)
  }

  func main() {
	    var x Sayer
	    var y Mover

	    var a = dog{name: "旺财"}
	    x = a
	    y = a
	    x.say()
	    y.move()
  }
  #+END_SRC
***** 多个类型实现同一接口
+ Go语言中不同的类型还可以实现同一接口 首先我们定义一个Mover接口，它要求必须由一个move方法
  #+BEGIN_SRC go
  // Mover 接口
  type Mover interface {
	    move()
  }
  
  // 例如狗可以动，汽车也可以动，可以使用如下代码实现这个关系
  type dog struct {
	    name string
  }

  type car struct {
	    brand string
  }

  // dog类型实现Mover接口
  func (d dog) move() {
	    fmt.Printf("%s会跑\n", d.name)
  }

  // car类型实现Mover接口
  func (c car) move() {
	    fmt.Printf("%s速度70迈\n", c.brand)
  }

  // 这个时候我们在代码中就可以把狗和汽车当成一个会动的物体来处理了，不再需要关注它们具体是什么，只需要调用它们的move方法就可以了
  func main() {
	    var x Mover
	    var a = dog{name: "旺财"}
	    var b = car{brand: "保时捷"}
	    x = a
	    x.move()
	    x = b
	    x.move()
  }
  // 输出
  // 旺财会跑
  // 保时捷速度70迈
  #+END_SRC
+ 一个接口的方法，不一定需要由一个类型完全实现，接口的方法可以通过在类型中嵌入其他类型或者结构体来实现
  #+BEGIN_SRC go
  // WashingMachine 洗衣机
  type WashingMachine interface {
      wash()
      dry()
  }

  // 甩干器
  type dryer struct{}

  // 实现WashingMachine接口的dry()方法
  func (d dryer) dry() {
      fmt.Println("甩一甩")
  }

  // 海尔洗衣机
  type haier struct {
      dryer //嵌入甩干器
  }

  // 实现WashingMachine接口的wash()方法
  func (h haier) wash() {
      fmt.Println("洗刷刷")
  }

  #+END_SRC
**** 接口嵌套
+ 接口与接口间可以通过嵌套创造出新的接口
  #+BEGIN_SRC go
  // Sayer 接口
  type Sayer interface {
      say()
  }

  // Mover 接口
  type Mover interface {
      move()
  }

  // 接口嵌套
  type animal interface {
      Sayer
      Mover
  }
  #+END_SRC
+ 嵌套得到的接口的使用与普通接口一样，这里我们让cat实现animal接口
  #+BEGIN_SRC go
  type cat struct {
      name string
  }

  func (c cat) say() {
      fmt.Println("喵喵喵")
  }

  func (c cat) move() {
      fmt.Println("猫会动")
  }

  func main() {
      var x animal
      x = cat{name: "花花"}
      x.move()
      x.say()
  }

  #+END_SRC
**** 空接口
***** 定义
+ 空接口是指没有定义任何方法的接口。因此任何类型都实现了空接口
+ 空接口类型的变量可以存储任意类型的变量
+ 因为空接口可以存储任意类型值的特点，所以空接口在Go语言中的使用十分广泛
  #+BEGIN_SRC go
  func main() {
      // 定义一个空接口x
      var x interface{}
      s := "Hello 沙河"
      x = s
      fmt.Printf("type:%T value:%v\n", x, x)
      i := 100
      x = i
      fmt.Printf("type:%T value:%v\n", x, x)
      b := true
      x = b
      fmt.Printf("type:%T value:%v\n", x, x)
  }
  #+END_SRC
***** 应用
+ 空接口作为函数的参数,使用空接口实现可以接收任意类型的函数参数
  #+BEGIN_SRC go
  // 空接口作为函数参数
  func show(a interface{}) {
	    fmt.Printf("type:%T value:%v\n", a, a)
  }
  #+END_SRC
+ 空接口作为map的值,使用空接口实现可以保存任意值的字典
  #+BEGIN_SRC go
  // 空接口作为map值
	var studentInfo = make(map[string]interface{})
	studentInfo["name"] = "沙河娜扎"
	studentInfo["age"] = 18
	studentInfo["married"] = false
	fmt.Println(studentInfo)
  #+END_SRC
**** 类型断言
空接口可以存储任意类型的值，那我们如何获取其存储的具体数据呢
***** 接口值
+ 一个接口的值（简称接口值）是由一个具体类型和具体类型的值两部分组成的。这两部分分别称为接口的动态类型和动态值
  #+BEGIN_SRC go
  var w io.Writer
  w = os.Stdout
  w = new(bytes.Buffer)
  w = nil
  #+END_SRC
+ 判断空接口中的值这个时候就可以使用类型断言，其语法格式
  #+BEGIN_SRC go
  x.(T)

  // x：表示类型为interface{}的变量
  // T：表示断言x可能是的类型。
  #+END_SRC
+ 该语法返回两个参数，第一个参数是x转化为T类型后的变量，第二个值是一个布尔值，若为true则表示断言成功，为false则表示断言失败
  #+BEGIN_SRC go
  func main() {
      var x interface{}
      x = "Hello 沙河"
      v, ok := x.(string)
      if ok {
        fmt.Println(v)
      } else {
        fmt.Println("类型断言失败")
      }
  }
  #+END_SRC
+ 上面的示例中如果要断言多次就需要写多个if判断，这个时候我们可以使用switch语句来实现
  #+BEGIN_SRC go
  func justifyType(x interface{}) {
      switch v := x.(type) {
      case string:
        fmt.Printf("x is a string，value is %v\n", v)
      case int:
        fmt.Printf("x is a int is %v\n", v)
      case bool:
        fmt.Printf("x is a bool is %v\n", v)
      default:
        fmt.Println("unsupport type！")
      }
  }
  #+END_SRC
*** 反射（reflect）
**** 变量的内在机制
+ Go语言中的变量是分为两部分的
  - 类型信息：预先定义好的元信息
  - 值信息：程序运行过程中可动态变化的
**** 反射介绍
+ 反射是指在程序运行期对程序本身进行访问和修改的能力。程序在编译时，变量被转换为内存地址，变量名不会被编译器写入到可执行部分。在运行程序时，程序无法获取自身的信息
+ 支持反射的语言可以在程序编译期将变量的反射信息，如字段名称、类型信息、结构体信息等整合到可执行文件中，并给程序提供接口访问反射信息，这样就可以在程序运行期获取类型的反射信息，并且有能力修改它们
+ 空接口可以存储任意类型的变量，那我们如何知道这个空接口保存的数据是什么呢？ 反射就是在运行时动态的获取一个变量的类型信息和值信息
**** reflect包
+ 在Go语言的反射机制中，任何接口值都由是一个具体类型和具体类型的值两部分组成的，在Go语言中反射的相关功能由内置的reflect包提供，任意接口值在反射中都可以理解为由reflect.Type和reflect.Value两部分组成，并且reflect包提供了reflect.TypeOf和reflect.ValueOf两个函数来获取任意对象的Value和Type
***** TypeOf
+ 在Go语言中，使用reflect.TypeOf()函数可以获得任意值的类型对象（reflect.Type），程序通过类型对象可以访问任意值的类型信息
  #+BEGIN_SRC go
  package main

    import (
      "fmt"
      "reflect"
    )

    func reflectType(x interface{}) {
      v := reflect.TypeOf(x)
      fmt.Printf("type:%v\n", v)
    }
    func main() {
      var a float32 = 3.14
      reflectType(a) // type:float32
      var b int64 = 100
      reflectType(b) // type:int64
  }
  #+END_SRC
+ type name和type kind
  - 在反射中关于类型还划分为两种：类型（Type）和种类（Kind）。因为在Go语言中我们可以使用type关键字构造很多自定义类型，而种类（Kind）就是指底层的类型，但在反射中，当需要区分指针、结构体等大品种的类型时，就会用到种类（Kind）。 举个例子，我们定义了两个指针类型和两个结构体类型，通过反射查看它们的类型和种类，Go语言的反射中像数组、切片、Map、指针等类型的变量，它们的.Name()都是返回空
    #+BEGIN_SRC go
    package main

    import (
        "fmt"
        "reflect"
    )

    type myInt int64

    func reflectType(x interface{}) {
        t := reflect.TypeOf(x)
        fmt.Printf("type:%v kind:%v\n", t.Name(), t.Kind())
    }

    func main() {
        var a *float32 // 指针
        var b myInt    // 自定义类型
        var c rune     // 类型别名
        reflectType(a) // type: kind:ptr
        reflectType(b) // type:myInt kind:int64
        reflectType(c) // type:int32 kind:int32

        type person struct {
          name string
          age  int
        }
        type book struct{ title string }
        var d = person{
          name: "沙河小王子",
          age:  18,
        }
        var e = book{title: "《跟小王子学Go语言》"}
        reflectType(d) // type:person kind:struct
        reflectType(e) // type:book kind:struct
    }

    #+END_SRC
  - 在reflect包中定义的Kind类型如下
    #+BEGIN_SRC go
    type Kind uint
      const (
          Invalid Kind = iota  // 非法类型
          Bool                 // 布尔型
          Int                  // 有符号整型
          Int8                 // 有符号8位整型
          Int16                // 有符号16位整型
          Int32                // 有符号32位整型
          Int64                // 有符号64位整型
          Uint                 // 无符号整型
          Uint8                // 无符号8位整型
          Uint16               // 无符号16位整型
          Uint32               // 无符号32位整型
          Uint64               // 无符号64位整型
          Uintptr              // 指针
          Float32              // 单精度浮点数
          Float64              // 双精度浮点数
          Complex64            // 64位复数类型
          Complex128           // 128位复数类型
          Array                // 数组
          Chan                 // 通道
          Func                 // 函数
          Interface            // 接口
          Map                  // 映射
          Ptr                  // 指针
          Slice                // 切片
          String               // 字符串
          Struct               // 结构体
          UnsafePointer        // 底层指针
    )
    #+END_SRC
***** ValueOf
+ reflect.ValueOf()返回的是reflect.Value类型，其中包含了原始值的值信息。reflect.Value与原始值之间可以互相转换
+ reflect.Value类型提供的获取原始值的方法如下
  | 方法                     | 说明                                                                            |
  |--------------------------+---------------------------------------------------------------------------------|
  | Interface() interface {} | 将值以 interface{} 类型返回，可以通过类型断言转换为指定类型                     |
  | Int() int64              | 将值以 int 类型返回，所有有符号整型均可以此方式返回                             |
  | Uint() uint64            | 将值以 uint 类型返回，所有无符号整型均可以此方式返回                            |
  | Float() float64          | 将值以双精度（float64）类型返回，所有浮点数（float32、float64）均可以此方式返回 |
  | Bool() bool              | 将值以 bool 类型返回                                                            |
  | Bytes() []bytes          | 将值以字节数组 []bytes 类型返回                                                 |
  | String() string          | 将值以字符串类型返回                                                            |
**** 通过反射获取值
#+BEGIN_SRC go
func reflectValue(x interface{}) {
    v := reflect.ValueOf(x)
    k := v.Kind()
    switch k {
    case reflect.Int64:
      // v.Int()从反射中获取整型的原始值，然后通过int64()强制类型转换
      fmt.Printf("type is int64, value is %d\n", int64(v.Int()))
    case reflect.Float32:
      // v.Float()从反射中获取浮点型的原始值，然后通过float32()强制类型转换
      fmt.Printf("type is float32, value is %f\n", float32(v.Float()))
    case reflect.Float64:
      // v.Float()从反射中获取浮点型的原始值，然后通过float64()强制类型转换
      fmt.Printf("type is float64, value is %f\n", float64(v.Float()))
    }
}
func main() {
    var a float32 = 3.14
    var b int64 = 100
    reflectValue(a) // type is float32, value is 3.140000
    reflectValue(b) // type is int64, value is 100
    // 将int类型的原始值转换为reflect.Value类型
    c := reflect.ValueOf(10)
    fmt.Printf("type c :%T\n", c) // type c :reflect.Value
}
#+END_SRC
**** 通过反射设置变量的值
+ 想要在函数中通过反射修改变量的值，需要注意函数参数传递的是值拷贝，必须传递变量地址才能修改变量值。而反射中使用专有的Elem()方法来获取指针对应的值
  #+BEGIN_SRC go
  package main

  import (
      "fmt"
      "reflect"
  )

  func reflectSetValue1(x interface{}) {
      v := reflect.ValueOf(x)
      if v.Kind() == reflect.Int64 {
        v.SetInt(200) //修改的是副本，reflect包会引发panic
      }
  }
  func reflectSetValue2(x interface{}) {
      v := reflect.ValueOf(x)
      // 反射中使用 Elem()方法获取指针对应的值
      if v.Elem().Kind() == reflect.Int64 {
        v.Elem().SetInt(200)
      }
  }
  func main() {
      var a int64 = 100
      // reflectSetValue1(a) //panic: reflect: reflect.Value.SetInt using unaddressable value
      reflectSetValue2(&a)
      fmt.Println(a)
  }
  #+END_SRC
**** isNil()和isValid()
***** isNil()
IsNil()报告v持有的值是否为nil。v持有的值的分类必须是通道、函数、接口、映射、指针、切片之一；否则IsNil函数会导致panic。
#+BEGIN_SRC go
func (v Value) IsNil() bool
#+END_SRC
***** isValid()
IsValid()返回v是否持有一个值。如果v是Value零值会返回假，此时v除了IsValid、String、Kind之外的方法都会导致panic
#+BEGIN_SRC go
func (v Value) IsValid() bool
#+END_SRC
***** 示例
+ IsNil()常被用于判断指针是否为空；IsValid()常被用于判定返回值是否有效。
  #+BEGIN_SRC go
  func main() {
      // *int类型空指针
      var a *int
      fmt.Println("var a *int IsNil:", reflect.ValueOf(a).IsNil())
      // nil值
      fmt.Println("nil IsValid:", reflect.ValueOf(nil).IsValid())
      // 实例化一个匿名结构体
      b := struct{}{}
      // 尝试从结构体中查找"abc"字段
      fmt.Println("不存在的结构体成员:", reflect.ValueOf(b).FieldByName("abc").IsValid())
      // 尝试从结构体中查找"abc"方法
      fmt.Println("不存在的结构体方法:", reflect.ValueOf(b).MethodByName("abc").IsValid())
      // map
      c := map[string]int{}
      // 尝试从map中查找一个不存在的键
      fmt.Println("map中不存在的键：", reflect.ValueOf(c).MapIndex(reflect.ValueOf("娜扎")).IsValid())
  }
  #+END_SRC
**** 结构体反射
***** 与结构体相关的方法
+ 任意值通过reflect.TypeOf()获得反射对象信息后，如果它的类型是结构体，可以通过反射值对象（reflect.Type）的NumField()和Field()方法获得结构体成员的详细信息
+ reflect.Type中与获取结构体成员相关的的方法如下表所示
  | 方法                                                        | 说明                                                                  |
  |-------------------------------------------------------------+-----------------------------------------------------------------------|
  | Field(i int) StructField                                    | 根据索引，返回索引对应的结构体字段的信息                              |
  | NumField() int                                              | 返回结构体成员字段数量                                                |
  | FieldByName(name string) (StructField, bool)                | 根据给定字符串返回字符串对应的结构体字段的信息                        |
  | FieldByIndex(index []int) StructField                       | 多层成员访问时，根据 []int 提供的每个结构体的字段索引，返回字段的信息 |
  | FieldByNameFunc(match func(string) bool) (StructField,bool) | 根据传入的匹配函数匹配需要的字段                                      |
  | NumMethod() int                                             | 返回该类型的方法集中方法的数目                                        |
  | Method(int) Method                                          | 返回该类型方法集中的第i个方法                                         |
  | MethodByName(string)(Method, bool)                          | 根据方法名返回该类型方法集中的方法                                    |
***** StructField类型
+ StructField类型用来描述结构体中的一个字段的信息
  #+BEGIN_SRC go
  type StructField struct {
        // Name是字段的名字。PkgPath是非导出字段的包路径，对导出字段该字段为""。
        // 参见http://golang.org/ref/spec#Uniqueness_of_identifiers
        Name    string
        PkgPath string
        Type      Type      // 字段的类型
        Tag       StructTag // 字段的标签
        Offset    uintptr   // 字段在结构体中的字节偏移量
        Index     []int     // 用于Type.FieldByIndex时的索引切片
        Anonymous bool      // 是否匿名字段
  }
  #+END_SRC
***** 结构体反射示例
+ 当我们使用反射得到一个结构体数据之后可以通过索引依次获取其字段信息，也可以通过字段名去获取指定的字段信息
  #+BEGIN_SRC go
  type student struct {
      Name  string `json:"name"`
      Score int    `json:"score"`
  }

  func main() {
      stu1 := student{
        Name:  "小王子",
        Score: 90,
      }

      t := reflect.TypeOf(stu1)
      fmt.Println(t.Name(), t.Kind()) // student struct
      // 通过for循环遍历结构体的所有字段信息
      for i := 0; i < t.NumField(); i++ {
        field := t.Field(i)
        fmt.Printf("name:%s index:%d type:%v json tag:%v\n", field.Name, field.Index, field.Type, field.Tag.Get("json"))
      }

      // 通过字段名获取指定结构体字段信息
      if scoreField, ok := t.FieldByName("Score"); ok {
        fmt.Printf("name:%s index:%d type:%v json tag:%v\n", scoreField.Name, scoreField.Index, scoreField.Type, scoreField.Tag.Get("json"))
      }
  }
  // 接下来编写一个函数printMethod(s interface{})来遍历打印s包含的方法
  // 给student添加两个方法 Study和Sleep(注意首字母大写)
  func (s student) Study() string {
	    msg := "好好学习，天天向上。"
	    fmt.Println(msg)
	    return msg
  }

  func (s student) Sleep() string {
	    msg := "好好睡觉，快快长大。"
	    fmt.Println(msg)
	    return msg
  }

  func printMethod(x interface{}) {
	    t := reflect.TypeOf(x)
	    v := reflect.ValueOf(x)

	    fmt.Println(t.NumMethod())
	    for i := 0; i < v.NumMethod(); i++ {
		      methodType := v.Method(i).Type()
		      fmt.Printf("method name:%s\n", t.Method(i).Name)
		      fmt.Printf("method:%s\n", methodType)
		      // 通过反射调用方法传递的参数必须是 []reflect.Value 类型
		      var args = []reflect.Value{}
		      v.Method(i).Call(args)
	    }
  }
  #+END_SRC
**** 反射是把双刃剑
+ 反射是一个强大并富有表现力的工具，能让我们写出更灵活的代码。但是反射不应该被滥用，原因有以下三个
  - 基于反射的代码是极其脆弱的，反射中的类型错误会在真正运行的时候才会引发panic，那很可能是在代码写完的很长时间之后
  - 大量使用反射的代码通常难以理解
  - 反射的性能低下，基于反射实现的代码通常比正常代码运行速度慢一到两个数量级
*** 并发
**** 并发与并行
+ 并发：同一时间段内执行多个任务（你在用微信和两个女朋友聊天）
+ 并行：同一时刻执行多个任务（你和你朋友都在用微信和女朋友聊天）
+ Go语言的并发通过goroutine实现。goroutine类似于线程，属于用户态的线程，我们可以根据需要创建成千上万个goroutine并发工作。goroutine是由Go语言的运行时（runtime）调度完成，而线程是由操作系统调度完成
+ Go语言还提供channel在多个goroutine间进行通信。goroutine和channel是 Go 语言秉承的 CSP（Communicating Sequential Process）并发模式的重要实现基础
**** goroutine
+ Go语言中的goroutine就是这样一种机制，goroutine的概念类似于线程，但 goroutine是由Go的运行时（runtime）调度和管理的。Go程序会智能地将 goroutine 中的任务合理地分配给每个CPU。Go语言之所以被称为现代化的编程语言，就是因为它在语言层面已经内置了调度和上下文切换的机制
+ 在Go语言编程中你不需要去自己写进程、线程、协程，你的技能包里只有一个技能–goroutine，当你需要让某个任务并发执行的时候，你只需要把这个任务包装成一个函数，开启一个goroutine去执行这个函数就可以
**** 使用goroutine
+ Go语言中使用goroutine非常简单，只需要在调用函数的时候在前面加上go关键字，就可以为一个函数创建一个goroutine
+ 一个goroutine必定对应一个函数，可以创建多个goroutine去执行相同的函数
**** 启动单个goroutine
+ 启动goroutine的方式非常简单，只需要在调用的函数（普通函数和匿名函数）前面加上一个go关键字
  #+BEGIN_SRC go
  func hello() {
      fmt.Println("Hello Goroutine!")
  }
  func main() {
      hello()
      fmt.Println("main goroutine done!")
  }
  // 这个示例中hello函数和下面的语句是串行的，执行的结果是打印完Hello Goroutine!后打印main goroutine done!
  // 接下来我们在调用hello函数前面加上关键字go，也就是启动一个goroutine去执行hello这个函数
  func main() {
    	go hello() // 启动另外一个goroutine去执行hello函数
	    fmt.Println("main goroutine done!")
  }
  // 这一次的执行结果只打印了main goroutine done!，并没有打印Hello Goroutine!。为什么呢？
  #+END_SRC
+ 在程序启动时，Go程序就会为main()函数创建一个默认的goroutine,当main()函数返回的时候该goroutine就结束了，所有在main()函数中启动的goroutine会一同结束
**** 启动多个goroutine
+ 在Go语言中实现并发就是这样简单，我们还可以启动多个goroutine。让我们再来一个例子： （这里使用了sync.WaitGroup来实现goroutine的同步）
  #+BEGIN_SRC go
  var wg sync.WaitGroup

  func hello(i int) {
      defer wg.Done() // goroutine结束就登记-1
      fmt.Println("Hello Goroutine!", i)
  }
  func main() {

      for i := 0; i < 10; i++ {
        wg.Add(1) // 启动一个goroutine就登记+1
        go hello(i)
      }
      wg.Wait() // 等待所有登记的goroutine都结束
  }
  #+END_SRC
+ 多次执行上面的代码，会发现每次打印的数字的顺序都不一致。这是因为10个goroutine是并发执行的，而goroutine的调度是随机的
**** goroutine与线程
***** 可增长的栈
+ OS线程（操作系统线程）一般都有固定的栈内存（通常为2MB）,一个goroutine的栈在其生命周期开始时只有很小的栈（典型情况下2KB），goroutine的栈不是固定的，他可以按需增大和缩小，goroutine的栈大小限制可以达到1GB，虽然极少会用到这个大。所以在Go语言中一次创建十万左右的goroutine也是可以的
***** goroutine调度
+ GPM是Go语言运行时（runtime）层面的实现，是go语言自己实现的一套调度系统。区别于操作系统调度OS线程
+ G很好理解，就是个goroutine的，里面除了存放本goroutine信息外 还有与所在P的绑定等信息。
+ P管理着一组goroutine队列，P里面会存储当前goroutine运行的上下文环境（函数指针，堆栈地址及地址边界），P会对自己管理的goroutine队列做一些调度（比如把占用CPU时间较长的goroutine暂停、运行后续的goroutine等等）当自己的队列消费完了就去全局队列里取，如果全局队列里也消费完了会去其他P的队列里抢任务。
+ M（machine）是Go运行时（runtime）对操作系统内核线程的虚拟， M与内核线程一般是一一映射的关系， 一个groutine最终是要放到M上执行的
+ P与M一般也是一一对应的。他们关系是： P管理着一组G挂载在M上运行。当一个G长久阻塞在一个M上时，runtime会新建一个M，阻塞G所在的P会把其他的G 挂载在新建的M上。当旧的G阻塞完成或者认为其已经死掉时 回收旧的M
+ P的个数是通过runtime.GOMAXPROCS设定（最大256），Go1.5版本之后默认为物理线程数。 在并发量大的时候会增加一些P和M，但不会太多，切换太频繁的话得不偿失
+ 单从线程调度讲，Go语言相比起其他语言的优势在于OS线程是由OS内核来调度的，goroutine则是由Go运行时（runtime）自己的调度器调度的，这个调度器使用一个称为m:n调度的技术（复用/调度m个goroutine到n个OS线程）。 其一大特点是goroutine的调度是在用户态下完成的， 不涉及内核态与用户态之间的频繁切换，包括内存的分配与释放，都是在用户态维护着一块大的内存池， 不直接调用系统的malloc函数（除非内存池需要改变），成本比调度OS线程低很多。 另一方面充分利用了多核的硬件资源，近似的把若干goroutine均分在物理线程上， 再加上本身goroutine的超轻量，以上种种保证了go调度方面的性能
**** GOMAXPROCS
+ Go运行时的调度器使用GOMAXPROCS参数来确定需要使用多少个OS线程来同时执行Go代码。默认值是机器上的CPU核心数。例如在一个8核心的机器上，调度器会把Go代码同时调度到8个OS线程上（GOMAXPROCS是m:n调度中的n）
+ Go语言中可以通过runtime.GOMAXPROCS()函数设置当前程序并发时占用的CPU逻辑核心数
+ 可以通过将任务分配到不同的CPU逻辑核心上实现并行的效果
  #+BEGIN_SRC go
  func a() {
      for i := 1; i < 10; i++ {
        fmt.Println("A:", i)
      }
  }

  func b() {
      for i := 1; i < 10; i++ {
        fmt.Println("B:", i)
      }
  }

  func main() {
      runtime.GOMAXPROCS(1)
      go a()
      go b()
      time.Sleep(time.Second)
  }
  #+END_SRC
+ 两个任务只有一个逻辑核心，此时是做完一个任务再做另一个任务。 将逻辑核心数设为2，此时两个任务并行执行
  #+BEGIN_SRC go
  func a() {
      for i := 1; i < 10; i++ {
        fmt.Println("A:", i)
      }
  }

  func b() {
      for i := 1; i < 10; i++ {
        fmt.Println("B:", i)
      }
  }

  func main() {
      runtime.GOMAXPROCS(2)
      go a()
      go b()
      time.Sleep(time.Second)
  }
  #+END_SRC
+ Go语言中的操作系统线程和goroutine的关系
  - 一个操作系统线程对应用户态多个goroutine。
  - go程序可以同时使用多个操作系统线程。
  - goroutine和OS线程是多对多的关系，即m:n。
**** channel
***** 介绍
+ 单纯地将函数并发执行是没有意义的。函数与函数间需要交换数据才能体现并发执行函数的意义
+ 虽然可以使用共享内存进行数据交换，但是共享内存在不同的goroutine中容易发生竞态问题。为了保证数据交换的正确性，必须使用互斥量对内存进行加锁，这种做法势必造成性能问题
+ Go语言的并发模型是CSP（Communicating Sequential Processes），提倡通过通信共享内存而不是通过共享内存而实现通信
+ 如果说goroutine是Go程序并发的执行体，channel就是它们之间的连接。channel是可以让一个goroutine发送特定值到另一个goroutine的通信机制
+ Go 语言中的通道（channel）是一种特殊的类型。通道像一个传送带或者队列，总是遵循先入先出（First In First Out）的规则，保证收发数据的顺序。每一个通道都是一个具体类型的导管，也就是声明channel的时候需要为其指定元素类型
***** channel类型
+ channel是一种类型，一种引用类型。声明通道类型的格式如下
  #+BEGIN_SRC go
  var 变量 chan 元素类型

  // 示例
  var ch1 chan int   // 声明一个传递整型的通道
  var ch2 chan bool  // 声明一个传递布尔型的通道
  var ch3 chan []int // 声明一个传递int切片的通道
  #+END_SRC
***** 创建channel
+ 通道是引用类型，通道类型的空值是nil
  #+BEGIN_SRC go
  var ch chan int
  fmt.Println(ch) // <nil>
  #+END_SRC
+ 声明的通道后需要使用make函数初始化之后才能使用
  #+BEGIN_SRC go
  make(chan 元素类型, [缓冲大小])
  #+END_SRC
+ channel的缓冲大小是可选的
  #+BEGIN_SRC go
  ch4 := make(chan int)
  ch5 := make(chan bool)
  ch6 := make(chan []int)
  #+END_SRC
***** channel操作
+ 通道有发送（send）、接收(receive）和关闭（close）三种操作
+ 发送和接收都使用<-符号
  #+BEGIN_SRC go
  // 定义一个通道
  ch := make(chan int)
  // 将一个值发送到通道中
  ch <- 10 // 把10发送到ch中
  // 从一个通道中接收值。
  x := <- ch // 从ch中接收值并赋值给变量x
  <-ch       // 从ch中接收值，忽略结果
  // 通过调用内置的close函数来关闭通道
  close(ch)
  #+END_SRC
+ 关闭通道需要注意的事情是，只有在通知接收方goroutine所有的数据都发送完毕的时候才需要关闭通道。通道是可以被垃圾回收机制回收的，它和关闭文件是不一样的，在结束操作之后关闭文件是必须要做的，但关闭通道不是必须的
+ 关闭后的通道有以下特点
  - 对一个关闭的通道再发送值就会导致panic。
  - 对一个关闭的通道进行接收会一直获取值直到通道为空。
  - 对一个关闭的并且没有值的通道执行接收操作会得到对应类型的零值。
  - 关闭一个已经关闭的通道会导致panic。
***** 无缓冲的通道
+ 无缓冲的通道又称为阻塞的通道,无缓冲的通道必须有接收才能发送
+ 使用无缓冲通道进行通信将导致发送和接收的goroutine同步化。因此，无缓冲通道也被称为同步通道
***** 有缓冲的通道
+ 解决上面问题的方法还有一种就是使用有缓冲区的通道。我们可以在使用make函数初始化通道的时候为其指定通道的容量
  #+BEGIN_SRC go
  func main() {
      ch := make(chan int, 1) // 创建一个容量为1的有缓冲区通道
      ch <- 10
      fmt.Println("发送成功")
  }

  #+END_SRC
+ 只要通道的容量大于零，那么该通道就是有缓冲的通道，通道的容量表示通道中能存放元素的数量。就像你小区的快递柜只有那么个多格子，格子满了就装不下了，就阻塞了，等到别人取走一个快递员就能往里面放一个
+ 可以使用内置的len函数获取通道内元素的数量，使用cap函数获取通道的容量，虽然我们很少会这么做
***** for range从通道循环取值
+ 当向通道中发送完数据时，我们可以通过close函数来关闭通道。当通道被关闭时，再往该通道发送值会引发panic，从该通道取值的操作会先取完通道中的值，再然后取到的值一直都是对应类型的零值。那如何判断一个通道是否被关闭了呢
  #+BEGIN_SRC go
  // channel 练习
  func main() {
      ch1 := make(chan int)
      ch2 := make(chan int)
      // 开启goroutine将0~100的数发送到ch1中
      go func() {
        for i := 0; i < 100; i++ {
          ch1 <- i
        }
        close(ch1)
      }()
      // 开启goroutine从ch1中接收值，并将该值的平方发送到ch2中
      go func() {
        for {
          i, ok := <-ch1 // 通道关闭后再取值ok=false
          if !ok {
            break
          }
          ch2 <- i * i
        }
        close(ch2)
      }()
      // 在主goroutine中从ch2中接收值打印
      for i := range ch2 { // 通道关闭后会退出for range循环
        fmt.Println(i)
      }
  }

  #+END_SRC
+ 从上面的例子中我们看到有两种方式在接收值的时候判断该通道是否被关闭，不过我们通常使用的是for range的方式。使用for range遍历通道，当通道被关闭的时候就会退出for range
***** 单向通道
+ 有的时候我们会将通道作为参数在多个任务函数间传递，很多时候我们在不同的任务函数中使用通道都会对其进行限制，比如限制通道在函数中只能发送或只能接收
+ Go语言中提供了单向通道来处理这种情况
  #+BEGIN_SRC go
  func counter(out chan<- int) {
      for i := 0; i < 100; i++ {
        out <- i
      }
      close(out)
  }
  
  func squarer(out chan<- int, in <-chan int) {
      for i := range in {
        out <- i * i
      }
      close(out)
  }
  func printer(in <-chan int) {
      for i := range in {
        fmt.Println(i)
      }
  }

  func main() {
      ch1 := make(chan int)
      ch2 := make(chan int)
      go counter(ch1)
      go squarer(ch2, ch1)
      printer(ch2)
  }

  #+END_SRC
+ 在函数传参及任何赋值操作中可以将双向通道转换为单向通道，但反过来是不可以的
**** worker pool（goroutine池）
+ 在工作中我们通常会使用可以指定启动的goroutine数量–worker pool模式，控制goroutine的数量，防止goroutine泄漏和暴涨
  #+BEGIN_SRC go
  func worker(id int, jobs <-chan int, results chan<- int) {
      for j := range jobs {
        fmt.Printf("worker:%d start job:%d\n", id, j)
        time.Sleep(time.Second)
        fmt.Printf("worker:%d end job:%d\n", id, j)
        results <- j * 2
      }
  }


  func main() {
      jobs := make(chan int, 100)
      results := make(chan int, 100)
      // 开启3个goroutine
      for w := 1; w <= 3; w++ {
        go worker(w, jobs, results)
      }
      // 5个任务
      for j := 1; j <= 5; j++ {
        jobs <- j
      }
      close(jobs)
      // 输出结果
      for a := 1; a <= 5; a++ {
        <-results
      }
  }
  #+END_SRC
**** select多路复用
+ 在某些场景下我们需要同时从多个通道接收数据,为了应对这种场景，Go内置了select关键字，可以同时响应多个通道的操作
+ select的使用类似于switch语句，它有一系列case分支和一个默认的分支。每个case会对应一个通道的通信（接收或发送）过程。select会一直等待，直到某个case的通信操作完成时，就会执行case分支对应的语句
  #+BEGIN_SRC go
  select{
        case <-ch1:
            ...
        case data := <-ch2:
            ...
        case ch3<-data:
            ...
        default:
            默认操作
  }
  // 示例
  func main() {
	    ch := make(chan int, 1)
	    for i := 0; i < 10; i++ {
		      select {
		      case x := <-ch:
			    fmt.Println(x)
		      case ch <- i:
		      }
	    }
  }
  #+END_SRC
+ 使用select语句能提高代码的可读性
  - 可处理一个或多个channel的发送/接收操作。
  - 如果多个case同时满足，select会随机选择一个。
  - 对于没有case的select{}会一直等待，可用于阻塞main函数
**** 并发安全和锁
+ 有时候在Go代码中可能会存在多个goroutine同时操作一个资源（临界区），这种情况会发生竞态问题（数据竞态）
***** 互斥锁
+ 互斥锁是一种常用的控制共享资源访问的方法，它能够保证同时只有一个goroutine可以访问共享资源。Go语言中使用sync包的Mutex类型来实现互斥锁
  #+BEGIN_SRC go
  var x int64
  var wg sync.WaitGroup
  var lock sync.Mutex

  func add() {
      for i := 0; i < 5000; i++ {
        lock.Lock() // 加锁
        x = x + 1
        lock.Unlock() // 解锁
      }
      wg.Done()
  }
  func main() {
      wg.Add(2)
      go add()
      go add()
      wg.Wait()
      fmt.Println(x)
  }

  #+END_SRC
+ 使用互斥锁能够保证同一时间有且只有一个goroutine进入临界区，其他的goroutine则在等待锁；当互斥锁释放后，等待的goroutine才可以获取锁进入临界区，多个goroutine同时等待一个锁时，唤醒的策略是随机的
***** 读写互斥锁
+ 互斥锁是完全互斥的，但是有很多实际的场景下是读多写少的，当我们并发的去读取一个资源不涉及资源修改的时候是没有必要加锁的，这种场景下使用读写锁是更好的一种选择。读写锁在Go语言中使用sync包中的RWMutex类型
+ 读写锁分为两种：读锁和写锁。当一个goroutine获取读锁之后，其他的goroutine如果是获取读锁会继续获得锁，如果是获取写锁就会等待；当一个goroutine获取写锁之后，其他的goroutine无论是获取读锁还是写锁都会等待
+ 需要注意的是读写锁非常适合读多写少的场景，如果读和写的操作差别不大，读写锁的优势就发挥不出来
  #+BEGIN_SRC go
  var (
      x      int64
      wg     sync.WaitGroup
      lock   sync.Mutex
      rwlock sync.RWMutex
  )

  func write() {
      // lock.Lock()   // 加互斥锁
      rwlock.Lock() // 加写锁
      x = x + 1
      time.Sleep(10 * time.Millisecond) // 假设读操作耗时10毫秒
      rwlock.Unlock()                   // 解写锁
      // lock.Unlock()                     // 解互斥锁
      wg.Done()
  }

  func read() {
      // lock.Lock()                  // 加互斥锁
      rwlock.RLock()               // 加读锁
      time.Sleep(time.Millisecond) // 假设读操作耗时1毫秒
      rwlock.RUnlock()             // 解读锁
      // lock.Unlock()                // 解互斥锁
      wg.Done()
  }

  func main() {
      start := time.Now()
      for i := 0; i < 10; i++ {
        wg.Add(1)
        go write()
      }

      for i := 0; i < 1000; i++ {
        wg.Add(1)
        go read()
      }

      wg.Wait()
      end := time.Now()
      fmt.Println(end.Sub(start))
  }
  #+END_SRC
**** sync.WaitGroup
+ 在代码中生硬的使用time.Sleep肯定是不合适的，Go语言中可以使用sync.WaitGroup来实现并发任务的同步。 sync.WaitGroup有以下几个方法
  | 方法名                          | 功能                |
  |---------------------------------+---------------------|
  | (wg * WaitGroup) Add(delta int) | 计数器+delta        |
  | (wg *WaitGroup) Done()          | 计数器-1            |
  | (wg *WaitGroup) Wait()          | 阻塞直到计数器变为0 |
+ sync.WaitGroup内部维护着一个计数器，计数器的值可以增加和减少。例如当我们启动了N 个并发任务时，就将计数器值增加N。每个任务完成时通过调用Done()方法将计数器减1。通过调用Wait()来等待并发任务执行完，当计数器值为0时，表示所有并发任务已经完成
+ 需要注意sync.WaitGroup是一个结构体，传递的时候要传递指针
**** sync.Once
+ 在编程的很多场景下我们需要确保某些操作在高并发的场景下只执行一次，例如只加载一次配置文件、只关闭一次通道等
+ Go语言中的sync包中提供了一个针对只执行一次场景的解决方案–sync.Once
+ sync.Once只有一个Do方法，其签名如下
  #+BEGIN_SRC go
  func (o *Once) Do(f func()) {}
  #+END_SRC
+ 如果要执行的函数f需要传递参数就需要搭配闭包来使用
**** 加载配置文件示例
+ 延迟一个开销很大的初始化操作到真正用到它的时候再执行是一个很好的实践。因为预先初始化一个变量（比如在init函数中完成初始化）会增加程序的启动耗时，而且有可能实际执行过程中这个变量没有用上，那么这个初始化操作就不是必须要做的
  #+BEGIN_SRC go
  var icons map[string]image.Image

  func loadIcons() {
      icons = map[string]image.Image{
        "left":  loadIcon("left.png"),
        "up":    loadIcon("up.png"),
        "right": loadIcon("right.png"),
        "down":  loadIcon("down.png"),
      }
  }

  // Icon 被多个goroutine调用时不是并发安全的
  func Icon(name string) image.Image {
      if icons == nil {
        loadIcons()
      }
      return icons[name]
  }

  #+END_SRC
+ 多个goroutine并发调用Icon函数时不是并发安全的，现代的编译器和CPU可能会在保证每个goroutine都满足串行一致的基础上自由地重排访问内存的顺序。loadIcons函数可能会被重排为以下结果
  #+BEGIN_SRC go
  func loadIcons() {
      icons = make(map[string]image.Image)
      icons["left"] = loadIcon("left.png")
      icons["up"] = loadIcon("up.png")
      icons["right"] = loadIcon("right.png")
      icons["down"] = loadIcon("down.png")
  }

  #+END_SRC
+ 在这种情况下就会出现即使判断了icons不是nil也不意味着变量初始化完成了。考虑到这种情况，我们能想到的办法就是添加互斥锁，保证初始化icons的时候不会被其他的goroutine操作，但是这样做又会引发性能问题,使用sync.Once改造的示例代码如下
  #+BEGIN_SRC go
  var icons map[string]image.Image

  var loadIconsOnce sync.Once

  func loadIcons() {
      icons = map[string]image.Image{
        "left":  loadIcon("left.png"),
        "up":    loadIcon("up.png"),
        "right": loadIcon("right.png"),
        "down":  loadIcon("down.png"),
      }
  }

  // Icon 是并发安全的
  func Icon(name string) image.Image {
      loadIconsOnce.Do(loadIcons)
      return icons[name]
  }

  #+END_SRC
**** 并发安全的单例模式
+ 下面是借助sync.Once实现的并发安全的单例模式
+ sync.Once其实内部包含一个互斥锁和一个布尔值，互斥锁保证布尔值和数据的安全，而布尔值用来记录初始化是否完成。这样设计就能保证初始化操作的时候是并发安全的并且初始化操作也不会被执行多次
  #+BEGIN_SRC go
  package singleton

  import (
        "sync"
  )

  type singleton struct {}

  var instance *singleton
  var once sync.Once

  func GetInstance() *singleton {
        once.Do(func() {
            instance = &singleton{}
        })
        return instance
  }

  #+END_SRC
**** sync.Map
+ Go语言中内置的map不是并发安全的,当并发多了之后需要为map加锁来保证并发的安全性了，Go语言的sync包中提供了一个开箱即用的并发安全版map–sync.Map。开箱即用表示不用像内置的map一样使用make函数初始化就能直接使用。同时sync.Map内置了诸如Store、Load、LoadOrStore、Delete、Range等操作方法
  #+BEGIN_SRC go
  var m = sync.Map{}

  func main() {
      wg := sync.WaitGroup{}
      for i := 0; i < 20; i++ {
        wg.Add(1)
        go func(n int) {
          key := strconv.Itoa(n)
          m.Store(key, n)
          value, _ := m.Load(key)
          fmt.Printf("k=:%v,v:=%v\n", key, value)
          wg.Done()
        }(i)
      }
      wg.Wait()
  }

  #+END_SRC
**** 原子操作
+ 代码中的加锁操作因为涉及内核态的上下文切换会比较耗时、代价比较高。针对基本数据类型我们还可以使用原子操作来保证并发安全，因为原子操作是Go语言提供的方法它在用户态就可以完成，因此性能比加锁操作更好。Go语言中原子操作由内置的标准库sync/atomic提供
***** atomic包
| 方法                                                                                     | 解释           |
|------------------------------------------------------------------------------------------+----------------|
| func LoadInt32(addr *int32) (val int32)                                                  | 读取操作       |
| func LoadInt64(addr *int64) (val int64)                                                  |                |
| func LoadUint32(addr *uint32) (val uint32)                                               |                |
| func LoadUint64(addr *uint64) (val uint64)                                               |                |
| func LoadUintptr(addr *uintptr) (val uintptr)                                            |                |
| func LoadPointer(addr *unsafe.Pointer) (val unsafe.Pointer)                              |                |
|------------------------------------------------------------------------------------------+----------------|
| func StoreInt32(addr *int32, val int32)                                                  | 写入操作       |
| func StoreInt64(addr *int64, val int64)                                                  |                |
| func StoreUint32(addr *uint32, val uint32)                                               |                |
| func StoreUint64(addr *uint64, val uint64)                                               |                |
| func StoreUintptr(addr *uintptr, val uintptr)                                            |                |
| func StorePointer(addr *unsafe.Pointer, val unsafe.Pointer)                              |                |
|------------------------------------------------------------------------------------------+----------------|
| func AddInt32(addr *int32, delta int32) (new int32)                                      | 修改操作       |
| func AddInt64(addr *int64, delta int64) (new int64)                                      |                |
| func AddUint32(addr *uint32, delta uint32) (new uint32)                                  |                |
| func AddUint64(addr *uint64, delta uint64) (new uint64)                                  |                |
| func AddUintptr(addr *uintptr, delta uintptr) (new uintptr)                              |                |
|------------------------------------------------------------------------------------------+----------------|
| func SwapInt32(addr *int32, new int32) (old int32)                                       | 交换操作       |
| func SwapInt64(addr *int64, new int64) (old int64)                                       |                |
| func SwapUint32(addr *uint32, new uint32) (old uint32)                                   |                |
| func SwapUint64(addr *uint64, new uint64) (old uint64)                                   |                |
| func SwapUintptr(addr *uintptr, new uintptr) (old uintptr)                               |                |
| func SwapPointer(addr *unsafe.Pointer, new unsafe.Pointer) (old unsafe.Pointer)          |                |
|------------------------------------------------------------------------------------------+----------------|
| func CompareAndSwapInt32(addr *int32, old, new int32) (swapped bool)                     | 比较并交换操作 |
| func CompareAndSwapInt64(addr *int64, old, new int64) (swapped bool)                     |                |
| func CompareAndSwapUint32(addr *uint32, old, new uint32) (swapped bool)                  |                |
| func CompareAndSwapUint64(addr *uint64, old, new uint64) (swapped bool)                  |                |
| func CompareAndSwapUintptr(addr *uintptr, old, new uintptr) (swapped bool)               |                |
| func CompareAndSwapPointer(addr *unsafe.Pointer, old, new unsafe.Pointer) (swapped bool) |                |
+ 示例来比较下互斥锁和原子操作的性能
  #+BEGIN_SRC go
  package main

  import (
      "fmt"
      "sync"
      "sync/atomic"
      "time"
  )

  type Counter interface {
      Inc()
      Load() int64
  }

  // 普通版
  type CommonCounter struct {
      counter int64
  }

  func (c CommonCounter) Inc() {
      c.counter++
  }

  func (c CommonCounter) Load() int64 {
      return c.counter
  }

  // 互斥锁版
  type MutexCounter struct {
      counter int64
      lock    sync.Mutex
  }

  func (m *MutexCounter) Inc() {
      m.lock.Lock()
      defer m.lock.Unlock()
      m.counter++
  }

  func (m *MutexCounter) Load() int64 {
      m.lock.Lock()
      defer m.lock.Unlock()
      return m.counter
  }

  // 原子操作版
  type AtomicCounter struct {
      counter int64
  }

  func (a *AtomicCounter) Inc() {
      atomic.AddInt64(&a.counter, 1)
  }

  func (a *AtomicCounter) Load() int64 {
      return atomic.LoadInt64(&a.counter)
  }

  func test(c Counter) {
      var wg sync.WaitGroup
      start := time.Now()
      for i := 0; i < 1000; i++ {
        wg.Add(1)
        go func() {
          c.Inc()
          wg.Done()
        }()
      }
      wg.Wait()
      end := time.Now()
      fmt.Println(c.Load(), end.Sub(start))
  }

  func main() {
      c1 := CommonCounter{} // 非并发安全
      test(c1)
      c2 := MutexCounter{} // 使用互斥锁实现并发安全
      test(&c2)
      c3 := AtomicCounter{} // 并发安全且比互斥锁效率更高
      test(&c3)
  }

  #+END_SRC
*** 网络编程
**** socket编程
+ Socket是BSD UNIX的进程通信机制，通常也称作”套接字”，用于描述IP地址和端口，是一个通信链的句柄。Socket可以理解为TCP/IP网络的API，它定义了许多函数或例程，程序员可以用它们来开发TCP/IP网络上的应用程序。电脑上运行的应用程序通常通过”套接字”向网络发出请求或者应答网络请求
*** 单元测试
**** go test工具
**** 测试函数
***** 测试函数的格式
***** 测试函数示例
***** 测试组
***** 子测试
***** 测试覆盖率
**** 基准测试
***** 基准测试函数格式
***** 基准测试示例
***** 性能比较函数
***** 重置时间
***** 并行测试
**** Setup与TearDown
***** TestMain
***** 子测试的Setup与Teardown
**** 示例函数
***** 示例函数的格式
***** 示例函数示例
** 依赖管理
*** package
+ 软件是由代码组成的。为了复用代码，代码的组织出现了不同层次的抽象和实现，如 Module（模块），包（Package）
+ golang 的所有文件都需要指定其所在的包（package），包有两种类型，一种是 main 包，使用 package main 在代码的最前面声明。另外一种就是 非main 包，使用 package + 包名
**** main包
+ main 包的可以有唯一的一个 main 函数，这个函数也是程序的入口。也只有 main 包可以编译成可执行的文件
+ 虽然 main 包的文件名也是 main.go，其实包名和文件名没有直接关系
**** 自定义 package
+ 在项目中自定义package时，可以建立多个子目录存放.go文件
+ 但在同一目录中所有的自定义package的.go文件中package name必须是一致的，在main包中调用时，使用package name即"str.func()"可以调用此目录中所有.go文件中定义的函数和属性
+ package name与.go文件的名字无关，调用时只关心package name
+ 如果引用了第三方模块，应该使用go mod init package_name定义引用？？？不确定
**** 导入规则
+ 本地包在导入时，需要使用别名的形式，后面的路径中第一级别为项目根目录的模块名即go.mod中的module name
  #+BEGIN_SRC go
  import (
    	num "testgo/api/num"
	    str "testgo/api/string"
  )
  #+END_SRC
+ import 语句内，通过相对路径导入了包。对于*nix系统，相对路径 . 通常是可以省略的
*** go module
go module是Go1.11版本之后官方推出的版本管理工具，并且从Go1.13版本开始，go module将是Go语言默认的依赖管理工具
**** GO111MODULE
+ 要启用go module支持首先要设置环境变量GO111MODULE，通过它可以开启或关闭模块支持，它有三个可选值：off、on、auto，默认值是auto
+ GO111MODULE=off禁用模块支持，编译时会从GOPATH和vendor文件夹中查找包。
+ GO111MODULE=on启用模块支持，编译时会忽略GOPATH和vendor文件夹，只根据 go.mod下载依赖。
+ GO111MODULE=auto，当项目在$GOPATH/src外且项目根目录有go.mod文件时，开启模块支持
+ 设置GO111MODULE=on之后就可以使用go module了，以后就没有必要在GOPATH中创建项目了，并且还能够很好的管理项目依赖的第三方包信息
+ 使用 go module 管理依赖后会在项目根目录下生成两个文件go.mod和go.sum
**** GOPROXY
+ Go1.11之后设置GOPROXY命令为
  #+BEGIN_SRC shell
  export GOPROXY=https://goproxy.cn
  #+END_SRC
+ Go1.13之后GOPROXY默认值为https://proxy.golang.org，在国内是无法访问的，所以十分建议大家设置GOPROXY，这里我推荐使用goproxy.cn
  #+BEGIN_SRC shell
  go env -w GOPROXY=https://goproxy.cn,direct
  #+END_SRC
**** go mod命令
常用的go mod命令
+ go mod download    下载依赖的module到本地cache（默认为$GOPATH/pkg/mod目录）
+ go mod edit        编辑go.mod文件
+ go mod graph       打印模块依赖图
+ go mod init        初始化当前文件夹, 创建go.mod文件
+ go mod tidy        增加缺少的module，删除无用的module
+ go mod vendor      将依赖复制到vendor下
+ go mod verify      校验依赖
+ go mod why         解释为什么需要依赖
**** go.mod
+ go.mod文件记录了项目所有的依赖信息，其结构大致如下
  #+BEGIN_SRC go
  module github.com/Q1mi/studygo/blogger

  go 1.12

  require (
      github.com/DeanThompson/ginpprof v0.0.0-20190408063150-3be636683586
      github.com/gin-gonic/gin v1.4.0
      github.com/go-sql-driver/mysql v1.4.1
      github.com/jmoiron/sqlx v1.2.0
      github.com/satori/go.uuid v1.2.0
      google.golang.org/appengine v1.6.1 // indirect
  )
  
  // module用来定义包名
  // require用来定义依赖包及版本
  // indirect表示间接引用
  #+END_SRC
**** 依赖的版本
+ go mod支持语义化版本号，比如go get foo@v1.2.3，也可以跟git的分支或tag，比如go get foo@master，当然也可以跟git提交哈希，比如go get foo@e3702bed2。关于依赖的版本支持以下几种格式
  #+BEGIN_SRC go
  gopkg.in/tomb.v1 v1.0.0-20141024135613-dd632973f1e7
  gopkg.in/vmihailenco/msgpack.v2 v2.9.1
  gopkg.in/yaml.v2 <=v2.2.1
  github.com/tatsushid/go-fastping v0.0.0-20160109021039-d7bb493dee3e
  latest
  #+END_SRC
**** replace
+ 在国内访问golang.org/x的各个包都需要翻墙，你可以在go.mod中使用replace替换成github上对应的库
  #+BEGIN_SRC go
  replace (
      golang.org/x/crypto v0.0.0-20180820150726-614d502a4dac => github.com/golang/crypto v0.0.0-20180820150726-614d502a4dac
      golang.org/x/net v0.0.0-20180821023952-922f4815f713 => github.com/golang/net v0.0.0-20180826012351-8a410e7b638d
      golang.org/x/text v0.3.0 => github.com/golang/text v0.3.0
  )

  #+END_SRC
**** go get
+ 在项目中执行go get命令可以下载依赖包，并且还可以指定下载的版本
+ 运行go get -u将会升级到最新的次要版本或者修订版本(x.y.z, z是修订版本号， y是次要版本号)
+ 运行go get -u=patch将会升级到最新的修订版本
+ 运行go get package@version将会升级到指定的版本号version
+ 如果下载所有依赖可以使用go mod download命令
**** 整理依赖
+ 我们在代码中删除依赖代码后，相关的依赖库并不会在go.mod文件中自动移除。这种情况下我们可以使用go mod tidy命令更新go.mod中的依赖关系
**** go mod edit
+ 格式化
  因为我们可以手动修改go.mod文件，所以有些时候需要格式化该文件
  #+BEGIN_SRC shell
  go mod edit -fmt
  #+END_SRC
+ 添加依赖项
  #+BEGIN_SRC shell
  go mod edit -require=golang.org/x/text
  #+END_SRC
+ 移除依赖项
  如果只是想修改go.mod文件中的内容，那么可以运行go mod edit -droprequire=package path，比如要在go.mod中移除golang.org/x/text包，可以使用如下命令
  #+BEGIN_SRC shell
  go mod edit -droprequire=golang.org/x/text
  #+END_SRC
**** 在项目中使用go module
+ 既有项目
  如果需要对一个已经存在的项目启用go module，可以按照以下步骤操作
  - 在项目目录下执行go mod init，生成一个go.mod文件
  - 执行go get，查找并记录当前项目的依赖，同时生成一个go.sum记录每个依赖库的版本和哈希值
+ 新项目
  对于一个新创建的项目，我们可以在项目文件夹下按照以下步骤操作
  - 执行go mod init 项目名命令，在当前项目文件夹下创建一个go.mod文件
  - 动编辑go.mod中的require依赖项或执行go get自动发现、维护依赖
**** 使用go module导入本地包
***** 注意导入路径使用的是package定义的名称，而不是目录名称
***** 在同一个项目下
+ 在一个项目（project）可以定义多个包（package）
+ 目录结构
  moduledemo
  ├── go.mod
  ├── main.go
  └── mypackage
      └── mypackage.go
+ 导入包
  #+BEGIN_SRC go
  package main

  import (
      "fmt"
      "moduledemo/mypackage"  // 导入同一项目下的mypackage包
  )
  func main() {
      mypackage.New()
      fmt.Println("main")
  }

  #+END_SRC
***** 不在同一个项目下
+ 目录结构
  ├── moduledemo
  │   ├── go.mod
  │   └── main.go
  └── mypackage
      ├── go.mod
      └── mypackage.go
+ 导入包
  - 这个时候，mypackage也需要进行module初始化，即拥有一个属于自己的go.mod文件，内容如下
    #+BEGIN_SRC go
    module mypackage

    go 1.14
    #+END_SRC

  - 在moduledemo/main.go中按如下方式导入
    #+BEGIN_SRC go
    import (
        "fmt"
        "mypackage"
    )
    func main() {
        mypackage.New()
        fmt.Println("main")
    }

    #+END_SRC
  - 因为这两个包不在同一个项目路径下，你想要导入本地包，并且这些包也没有发布到远程的github或其他代码仓库地址。这个时候我们就需要在go.mod文件中使用replace指令
  - 在调用方也就是packagedemo/go.mod中按如下方式指定使用相对路径来寻找mypackage这个包
    #+BEGIN_SRC go
    module moduledemo

    go 1.14

    require "mypackage" v0.0.0
    replace "mypackage" => "../mypackage"

    #+END_SRC
* 库
** 标准库
*** fmt
fmt包实现了类似C语言printf和scanf的格式化I/O。主要分为向外输出内容和获取输入内容两大部分
**** 向外输出
***** Print
+ Print系列函数会将内容输出到系统的标准输出，区别在于Print函数直接输出内容，Printf函数支持格式化输出字符串，Println函数会在输出内容的结尾添加一个换行符
  #+BEGIN_SRC go
  func Print(a ...interface{}) (n int, err error)
  func Printf(format string, a ...interface{}) (n int, err error)
  func Println(a ...interface{}) (n int, err error)

  func main() {
	    fmt.Print("在终端打印该信息。")
	    name := "沙河小王子"
	    fmt.Printf("我是：%s\n", name)
	    fmt.Println("在终端打印单独一行显示")
  }
  #+END_SRC
***** Fprint
+ Fprint系列函数会将内容输出到一个io.Writer接口类型的变量w中，我们通常用这个函数往文件中写入内容,只要满足io.Writer接口的类型都支持写入
  #+BEGIN_SRC go
  func Fprint(w io.Writer, a ...interface{}) (n int, err error)
  func Fprintf(w io.Writer, format string, a ...interface{}) (n int, err error)
  func Fprintln(w io.Writer, a ...interface{}) (n int, err error)

  // 向标准输出写入内容
  fmt.Fprintln(os.Stdout, "向标准输出写入内容")
  fileObj, err := os.OpenFile("./xx.txt", os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0644)
  if err != nil {
	    fmt.Println("打开文件出错，err:", err)
	    return
  }
  name := "沙河小王子"
  // 向打开的文件句柄中写入内容
  fmt.Fprintf(fileObj, "往文件中写如信息：%s", name)
  #+END_SRC
***** Sprint
+ Sprint系列函数会把传入的数据生成并返回一个字符串
  #+BEGIN_SRC go
  func Sprint(a ...interface{}) string
  func Sprintf(format string, a ...interface{}) string
  func Sprintln(a ...interface{}) string

  s1 := fmt.Sprint("沙河小王子")
  name := "沙河小王子"
  age := 18
  s2 := fmt.Sprintf("name:%s,age:%d", name, age)
  s3 := fmt.Sprintln("沙河小王子")
  fmt.Println(s1, s2, s3)
  #+END_SRC
***** Errorf
+ Errorf函数根据format参数生成格式化字符串并返回一个包含该字符串的错误
  #+BEGIN_SRC go
  func Errorf(format string, a ...interface{}) error
  #+END_SRC
+ 通常使用这种方式来自定义错误类型
  #+BEGIN_SRC go
  err := fmt.Errorf("这是一个错误")
  #+END_SRC
+ Go1.13版本为fmt.Errorf函数新加了一个%w占位符用来生成一个可以包裹Error的Wrapping Error
  #+BEGIN_SRC go
  e := errors.New("原始错误e")
  w := fmt.Errorf("Wrap了一个错误%w", e)
  #+END_SRC
***** 格式化占位符
*printf系列函数都支持format格式化参数，在这里我们按照占位符将被替换的变量类型划分，方便查询和记忆
+ 通用占位符
  | 占位符 | 说明                               |
  |--------+------------------------------------|
  | %v     | 值的默认格式表示                   |
  | %+v    | 类似%v，但输出结构体时会添加字段名 |
  | %#v    | 值的Go语法表示                     |
  | %T     | 打印值的类型                       |
  | %%     | 百分号                             |
  #+BEGIN_SRC go
  fmt.Printf("%v\n", 100)
  fmt.Printf("%v\n", false)
  o := struct{ name string }{"小王子"}
  fmt.Printf("%v\n", o)
  fmt.Printf("%#v\n", o)
  fmt.Printf("%T\n", o)
  fmt.Printf("100%%\n")

  // 输出
  100
  false
  {小王子}
  struct { name string }{name:"小王子"}
  struct { name string }
  100%
  #+END_SRC
+ 布尔型
  | 占位符 | 说明        |
  |--------+-------------|
  | %t     | true或false |
+ 整型
  | 占位符 | 说明                                                                 |
  |--------+----------------------------------------------------------------------|
  | %b     | 表示为二进制                                                         |
  | %c     | 该值对应的unicode码值                                                |
  | %d     | 表示为十进制                                                         |
  | %o     | 表示为八进制                                                         |
  | %x     | 表示为十六进制，使用a-f                                              |
  | %X     | 表示为十六进制，使用A-F                                              |
  | %U     | 表示为Unicode格式：U+1234，等价于”U+%04X”                          |
  | %q     | 该值对应的单引号括起来的go语法字符字面值，必要时会采用安全的转义表示 |
  #+BEGIN_SRC go
  n := 65
  fmt.Printf("%b\n", n)
  fmt.Printf("%c\n", n)
  fmt.Printf("%d\n", n)
  fmt.Printf("%o\n", n)
  fmt.Printf("%x\n", n)
  fmt.Printf("%X\n", n)

  // 输出
  1000001
  A
  65
  101
  41
  41
  #+END_SRC
+ 浮点数与复数
  | 占位符 | 说明                                                     |
  |--------+----------------------------------------------------------|
  | %b     | 无小数部分、二进制指数的科学计数法，如-123456p-78        |
  | %e     | 科学计数法，如-1234.456e+78                              |
  | %E     | 科学计数法，如-1234.456E+78                              |
  | %f     | 有小数部分但无指数部分，如123.456                        |
  | %F     | 等价于%f                                                 |
  | %g     | 	根据实际情况采用%e或%f格式（以获得更简洁、准确的输出） |
  | %G     | 根据实际情况采用%E或%F格式（以获得更简洁、准确的输出）   |
  #+BEGIN_SRC go
  f := 12.34
  fmt.Printf("%b\n", f)
  fmt.Printf("%e\n", f)
  fmt.Printf("%E\n", f)
  fmt.Printf("%f\n", f)
  fmt.Printf("%g\n", f)
  fmt.Printf("%G\n", f)

  // 输出
  6946802425218990p-49
  1.234000e+01
  1.234000E+01
  12.340000
  12.34
  12.34
  #+END_SRC
+ 字符串和[]byte
  | 占位符 | 说明                                                                   |
  |--------+------------------------------------------------------------------------|
  | %s     | 直接输出字符串或者[]byte                                               |
  | %q     | 该值对应的双引号括起来的go语法字符串字面值，必要时会采用安全的转义表示 |
  | %x     | 每个字节用两字符十六进制数表示（使用a-f）                              |
  | %X     | 每个字节用两字符十六进制数表示（使用A-F）                              |
  #+BEGIN_SRC go
  s := "小王子"
  fmt.Printf("%s\n", s)
  fmt.Printf("%q\n", s)
  fmt.Printf("%x\n", s)
  fmt.Printf("%X\n", s)
  
  // 输出
  小王子
  "小王子"
  e5b08fe78e8be5ad90
  E5B08FE78E8BE5AD90
  #+END_SRC
+ 指针
  | 占位符 | 说明                           |
  |--------+--------------------------------|
  | %p     | 表示为十六进制，并加上前导的0x |
  #+BEGIN_SRC go
  a := 10
  fmt.Printf("%p\n", &a)
  fmt.Printf("%#p\n", &a)

  // 输出
  0xc000094000
  c000094000
  #+END_SRC
+ 宽度标识符
  宽度通过一个紧跟在百分号后面的十进制数指定，如果未指定宽度，则表示值时除必需之外不作填充。精度通过（可选的）宽度后跟点号后跟的十进制数指定。如果未指定精度，会使用默认精度；如果点号后没有跟数字，表示精度为0
  | 占位符 | 说明               |
  |--------+--------------------|
  | %f     | 默认宽度，默认精度 |
  | %9f    | 宽度9，默认精度    |
  | %.2f   | 默认宽度，精度2    |
  | %9.2f  | 宽度9，精度2       |
  | %9.f   | 宽度9，精度0       |
  #+BEGIN_SRC go
  n := 12.34
  fmt.Printf("%f\n", n)
  fmt.Printf("%9f\n", n)
  fmt.Printf("%.2f\n", n)
  fmt.Printf("%9.2f\n", n)
  fmt.Printf("%9.f\n", n)
  
  // 输出
  12.340000
  12.340000
  12.34
      12.34
         12
  #+END_SRC
+ 其他
  | 占位符  | 说明                                                                                                                                        |
  |---------+---------------------------------------------------------------------------------------------------------------------------------------------|
  | ’+’   | 总是输出数值的正负号；对%q（%+q）会生成全部是ASCII字符的输出（通过转义）                                                                    |
  | ’ ‘   | 对数值，正数前加空格而负数前加负号；对字符串采用%x或%X时（% x或% X）会给各打印的字节之间加空格                                              |
  | ’-’   | 在输出右边填充空白而不是默认的左边（即从默认的右对齐切换为左对齐）                                                                          |
  | ’#’   | 八进制数前加0（%#o），十六进制数前加0x（%#x）或0X（%#X），指针去掉前面的0x（%#p）对%q（%#q），对%U（%#U）会输出空格和单引号括起来的go字面值 |
  | ‘0’	 | 使用0而不是空格填充，对于数值类型会把填充的0放在正负号后面                                                                                  |
  #+BEGIN_SRC go
  s := "小王子"
  fmt.Printf("%s\n", s)
  fmt.Printf("%5s\n", s)
  fmt.Printf("%-5s\n", s)
  fmt.Printf("%5.7s\n", s)
  fmt.Printf("%-5.7s\n", s)
  fmt.Printf("%5.2s\n", s)
  fmt.Printf("%05s\n", s)

  // 输出
  小王子
    小王子
  小王子  
    小王子
  小王子  
    小王
  00小王子
  #+END_SRC
**** 获取输入
***** fmt.Scan
+ 语法
  #+BEGIN_SRC go
  func Scan(a ...interface{}) (n int, err error)
  #+END_SRC
+ Scan从标准输入扫描文本，读取由空白符分隔的值保存到传递给本函数的参数中，换行符视为空白符。
+ 本函数返回成功扫描的数据个数和遇到的任何错误。如果读取的数据个数比提供的参数少，会返回一个错误报告原因
+ fmt.Scan从标准输入中扫描用户输入的数据，将以空白符分隔的数据分别存入指定的参数
  #+BEGIN_SRC go
  func main() {
      var (
        name    string
        age     int
        married bool
      )
      fmt.Scan(&name, &age, &married)
      fmt.Printf("扫描结果 name:%s age:%d married:%t \n", name, age, married)
  }

  // 将上面的代码编译后在终端执行，在终端依次输入小王子、28和false使用空格分隔
  $ ./scan_demo 
  小王子 28 false
  扫描结果 name:小王子 age:28 married:false 
  #+END_SRC
***** fmt.Scanf
+ 语法
  #+BEGIN_SRC go
  func Scanf(format string, a ...interface{}) (n int, err error)
  #+END_SRC
+ Scanf从标准输入扫描文本，根据format参数指定的格式去读取由空白符分隔的值保存到传递给本函数的参数中。
+ 本函数返回成功扫描的数据个数和遇到的任何错误
+ fmt.Scanf不同于fmt.Scan简单的以空格作为输入数据的分隔符，fmt.Scanf为输入数据指定了具体的输入内容格式，只有按照格式输入数据才会被扫描并存入对应变量
  #+BEGIN_SRC go
  func main() {
      var (
        name    string
        age     int
        married bool
      )
      fmt.Scanf("1:%s 2:%d 3:%t", &name, &age, &married)
      fmt.Printf("扫描结果 name:%s age:%d married:%t \n", name, age, married)
  }
  
  // 将上面的代码编译后在终端执行，在终端按照指定的格式依次输入小王子、28和false
  $ ./scan_demo 
  1:小王子 2:28 3:false
  扫描结果 name:小王子 age:28 married:false 
  #+END_SRC
***** fmt.Scanln
+ 语法
  #+BEGIN_SRC go
  func Scanln(a ...interface{}) (n int, err error)
  #+END_SRC
+ Scanln类似Scan，它在遇到换行时才停止扫描。最后一个数据后面必须有换行或者到达结束位置。
+ 本函数返回成功扫描的数据个数和遇到的任何错误
+ fmt.Scanln遇到回车就结束扫描了，这个比较常用
  #+BEGIN_SRC go
  func main() {
      var (
        name    string
        age     int
        married bool
      )
      fmt.Scanln(&name, &age, &married)
      fmt.Printf("扫描结果 name:%s age:%d married:%t \n", name, age, married)
  }
  
  // 将上面的代码编译后在终端执行，在终端依次输入小王子、28和false使用空格分隔
  $ ./scan_demo 
  小王子 28 false
  扫描结果 name:小王子 age:28 married:false 
  #+END_SRC
***** bufio.NewReader
+ 有时候我们想完整获取输入的内容，而输入的内容可能包含空格，这种情况下可以使用bufio包来实现。示例代码如下
  #+BEGIN_SRC go
  func bufioDemo() {
      reader := bufio.NewReader(os.Stdin) // 从标准输入生成读对象
      fmt.Print("请输入内容：")
      text, _ := reader.ReadString('\n') // 读到换行
      text = strings.TrimSpace(text)
      fmt.Printf("%#v\n", text)
  }
  #+END_SRC
***** Fscan系列
+ 这几个函数功能分别类似于fmt.Scan、fmt.Scanf、fmt.Scanln三个函数，只不过它们不是从标准输入中读取数据而是从io.Reader中读取数据
  #+BEGIN_SRC go
  func Fscan(r io.Reader, a ...interface{}) (n int, err error)
  func Fscanln(r io.Reader, a ...interface{}) (n int, err error)
  func Fscanf(r io.Reader, format string, a ...interface{}) (n int, err error)
  #+END_SRC
***** Sscan系列
+ 这几个函数功能分别类似于fmt.Scan、fmt.Scanf、fmt.Scanln三个函数，只不过它们不是从标准输入中读取数据而是从指定字符串中读取数据
  #+BEGIN_SRC go
  func Sscan(str string, a ...interface{}) (n int, err error)
  func Sscanln(str string, a ...interface{}) (n int, err error)
  func Sscanf(str string, format string, a ...interface{}) (n int, err error)
  #+END_SRC
*** time
time包提供了时间的显示和测量用的函数。日历的计算采用的是公历
**** 时间类型
+ time.Time类型表示时间。我们可以通过time.Now()函数获取当前的时间对象，然后获取时间对象的年月日时分秒等信息
  #+BEGIN_SRC go
  func timeDemo() {
      now := time.Now() //获取当前时间
      fmt.Printf("current time:%v\n", now)

      year := now.Year()     //年
      month := now.Month()   //月
      day := now.Day()       //日
      hour := now.Hour()     //小时
      minute := now.Minute() //分钟
      second := now.Second() //秒
      fmt.Printf("%d-%02d-%02d %02d:%02d:%02d\n", year, month, day, hour, minute, second)
  }

  #+END_SRC
**** 时间戳
+ 时间戳是自1970年1月1日（08:00:00GMT）至当前时间的总毫秒数。它也被称为Unix时间戳（UnixTimestamp）。基于时间对象获取时间戳的示例代码如下
  #+BEGIN_SRC go
  func timestampDemo() {
      now := time.Now()            //获取当前时间
      timestamp1 := now.Unix()     //时间戳
      timestamp2 := now.UnixNano() //纳秒时间戳
      fmt.Printf("current timestamp1:%v\n", timestamp1)
      fmt.Printf("current timestamp2:%v\n", timestamp2)
  }
  #+END_SRC
+ 使用time.Unix()函数可以将时间戳转为时间格式
  #+BEGIN_SRC go
  func timestampDemo2(timestamp int64) {
      timeObj := time.Unix(timestamp, 0) //将时间戳转为时间格式
      fmt.Println(timeObj)
      year := timeObj.Year()     //年
      month := timeObj.Month()   //月
      day := timeObj.Day()       //日
      hour := timeObj.Hour()     //小时
      minute := timeObj.Minute() //分钟
      second := timeObj.Second() //秒
      fmt.Printf("%d-%02d-%02d %02d:%02d:%02d\n", year, month, day, hour, minute, second)
  }
  #+END_SRC
**** 时间间隔
+ time.Duration是time包定义的一个类型，它代表两个时间点之间经过的时间，以纳秒为单位。time.Duration表示一段时间间隔，可表示的最长时间段大约290年
+ time包中定义的时间间隔类型的常量如下
  #+BEGIN_SRC go
  const (
    Nanosecond  Duration = 1
    Microsecond          = 1000 * Nanosecond
    Millisecond          = 1000 * Microsecond
    Second               = 1000 * Millisecond
    Minute               = 60 * Second
    Hour                 = 60 * Minute
  )
  // 例如：time.Duration表示1纳秒，time.Second表示1秒
  #+END_SRC
**** 时区(Location)
+ 示例
  #+BEGIN_SRC go
  // 默认UTC    
  loc, err := time.LoadLocation("") 
  // 服务器设定的时区，一般为CST
  loc, err := time.LoadLocation("Local")
  // 美国洛杉矶PDT
  loc, err := time.LoadLocation("America/Los_Angeles")
  // 获取指定时区的时间点
  local, _ := time.LoadLocation("America/Los_Angeles")
  fmt.Println(time.Date(2018,1,1,12,0,0,0, local))

  #+END_SRC
+ go语言的time.Now()返回的是当地时区时间
  #+BEGIN_SRC go
  time.Now().Format("2006-01-02 15:04:05")
  #+END_SRC
+ go语言并没有全局设置时区这么一个东西，每次输出时间都需要调用一个In()函数改变时区
  #+BEGIN_SRC go
  var cstSh, _ = time.LoadLocation("Asia/Shanghai") //上海
  fmt.Println("SH : ", time.Now().In(cstSh).Format("2006-01-02 15:04:05"))
  #+END_SRC
+ 在windows系统上，没有安装go语言环境的情况下，time.LoadLocation会加载失败,最好的办法是用time.FixedZone
  #+BEGIN_SRC go
  var cstZone = time.FixedZone("CST", 8*3600)       // 东八
  fmt.Println("SH : ", time.Now().In(cstZone).Format("2006-01-02 15:04:05"))
  #+END_SRC
**** 时间操作
***** Add
+ 我们在日常的编码过程中可能会遇到要求时间+时间间隔的需求，Go语言的时间对象有提供Add方法如下
  #+BEGIN_SRC go
  func (t Time) Add(d Duration) Time
  
  // 例子，求一个小时之后的时间
  func main() {
	    now := time.Now()
	    later := now.Add(time.Hour) // 当前时间加1小时后的时间
	    fmt.Println(later)
  }
  #+END_SRC
***** Sub
+ 求两个时间之间的差值
+ 返回一个时间段t-u。如果结果超出了Duration可以表示的最大值/最小值，将返回最大值/最小值。要获取时间点t-d（d为Duration），可以使用t.Add(-d)
  #+BEGIN_SRC go
  func (t Time) Sub(u Time) Duration
  #+END_SRC
***** Equal
+ 判断两个时间是否相同，会考虑时区的影响，因此不同时区标准的时间也可以正确比较。本方法和用t==u不同，这种方法还会比较地点和时区信息
  #+BEGIN_SRC go
  func (t Time) Equal(u Time) bool
  #+END_SRC
***** Before
+ 如果t代表的时间点在u之前，返回真；否则返回假
  #+BEGIN_SRC go
  func (t Time) Before(u Time) bool
  #+END_SRC
***** After
+ 如果t代表的时间点在u之后，返回真；否则返回假
  #+BEGIN_SRC go
  func (t Time) After(u Time) bool
  #+END_SRC
***** 定时器
+ 使用time.Tick(时间间隔)来设置定时器，定时器的本质上是一个通道（channel）
  #+BEGIN_SRC go
  func tickDemo() {
      ticker := time.Tick(time.Second) //定义一个1秒间隔的定时器
      for i := range ticker {
        fmt.Println(i)//每秒都会执行的任务
      }
  }

  #+END_SRC
***** 时间格式化
+ 时间类型有一个自带的方法Format进行格式化，需要注意的是Go语言中格式化时间模板不是常见的Y-m-d H:M:S而是使用Go的诞生时间2006年1月2号15点04分
+ 格式化为12小时方式，需指定PM
  #+BEGIN_SRC go
  func formatDemo() {
      now := time.Now()
      // 格式化的模板为Go的出生时间2006年1月2号15点04分 Mon Jan
      // 24小时制
      fmt.Println(now.Format("2006-01-02 15:04:05.000 Mon Jan"))
      // 12小时制
      fmt.Println(now.Format("2006-01-02 03:04:05.000 PM Mon Jan"))
      fmt.Println(now.Format("2006/01/02 15:04"))
      fmt.Println(now.Format("15:04 2006/01/02"))
      fmt.Println(now.Format("2006/01/02"))
  }

  #+END_SRC
***** 解析字符串格式的时间
+ 示例
  #+BEGIN_SRC go
  now := time.Now()
  fmt.Println(now)
  // 加载时区
  loc, err := time.LoadLocation("Asia/Shanghai")
  if err != nil {
      fmt.Println(err)
      return
  }
  // 按照指定时区和指定格式解析字符串时间
  timeObj, err := time.ParseInLocation("2006/01/02 15:04:05", "2019/08/04 14:15:20", loc)
  if err != nil {
      fmt.Println(err)
      return
  }
  fmt.Println(timeObj)
  fmt.Println(timeObj.Sub(now))

  #+END_SRC
*** flag
flag包实现了命令行参数的解析，flag包使得开发命令行工具更为简单
**** flag参数类型
+ flag包支持的命令行参数类型有bool、int、int64、uint、uint64、float float64、string、duration
  | flag参数     | 有效值                                                                                                                     |
  |--------------+----------------------------------------------------------------------------------------------------------------------------|
  | 字符串flag   | 合法字符串                                                                                                                 |
  | 整数flag     | 1234、0664、0x1234等类型，也可以是负数                                                                                     |
  | 浮点数flag   | 合法浮点数                                                                                                                 |
  | bool类型flag | 1, 0, t, f, T, F, true, false, TRUE, FALSE, True, False                                                                    |
  | 时间段flag   | 任何合法的时间段字符串。如”300ms”、”-1.5h”、”2h45m”。合法的单位有”ns”、”us” /“µs”、”ms”、”s”、”m”、”h” |
**** 定义命令行flag参数
+ flag.Type()
  - 语法
    #+BEGIN_SRC go
    flag.Type(flag名, 默认值, 帮助信息)*Type

    // 例如我们要定义姓名、年龄、婚否三个命令行参数，我们可以按如下方式定义
    name := flag.String("name", "张三", "姓名")
    age := flag.Int("age", 18, "年龄")
    married := flag.Bool("married", false, "婚否")
    delay := flag.Duration("d", 0, "时间间隔")
    #+END_SRC
  - 需要注意的是，此时name、age、married、delay均为对应类型的指针
+ flag.TypeVar()
  - 语法
    #+BEGIN_SRC go
    flag.TypeVar(Type指针, flag名, 默认值, 帮助信息)
    
    // 例如我们要定义姓名、年龄、婚否三个命令行参数
    var name string
    var age int
    var married bool
    var delay time.Duration
    flag.StringVar(&name, "name", "张三", "姓名")
    flag.IntVar(&age, "age", 18, "年龄")
    flag.BoolVar(&married, "married", false, "婚否")
    flag.DurationVar(&delay, "d", 0, "时间间隔")
    #+END_SRC
**** flag.Parse()
+ 通过以上两种方法定义好命令行flag参数后，需要通过调用flag.Parse()来对命令行参数进行解析
+ 支持的命令行参数格式有以下几种
  -flag xxx （使用空格，一个-符号）
  --flag xxx （使用空格，两个-符号）
  -flag=xxx （使用等号，一个-符号）
  --flag=xxx （使用等号，两个-符号）
+ 其中，布尔类型的参数必须使用等号的方式指定
+ Flag解析在第一个非flag参数（单个”-“不是flag参数）之前停止，或者在终止符”–“之后停止
**** flag其他函数
flag.Args()  ////返回命令行参数后的其他参数，以[]string类型
flag.NArg()  //返回命令行参数后的其他参数个数
flag.NFlag() //返回使用的命令行参数个数
*** log
Go语言内置的log包实现了简单的日志服务
**** 使用Logger
+ log包定义了Logger类型，该类型提供了一些格式化输出的方法。本包也提供了一个预定义的“标准”logger，可以通过调用函数Print系列(Print|Printf|Println）、Fatal系列（Fatal|Fatalf|Fatalln）、和Panic系列（Panic|Panicf|Panicln）来使用，比自行创建一个logger对象更容易使用
+ 例如，我们可以像下面的代码一样直接通过log包来调用上面提到的方法，默认它们会将日志信息打印到终端界面
  #+BEGIN_SRC go
  package main

  import (
      "log"
  )

  func main() {
      log.Println("这是一条很普通的日志。")
      v := "很普通的"
      log.Printf("这是一条%s日志。\n", v)
      log.Fatalln("这是一条会触发fatal的日志。")
      log.Panicln("这是一条会触发panic的日志。")
  }
  
  // 编译并执行上面的代码会得到如下输出
  2017/06/19 14:04:17 这是一条很普通的日志。
  2017/06/19 14:04:17 这是一条很普通的日志。
  2017/06/19 14:04:17 这是一条会触发fatal的日志。
  #+END_SRC
+ logger会打印每条日志信息的日期、时间，默认输出到系统的标准错误。Fatal系列函数会在写入日志信息后调用os.Exit(1)。Panic系列函数会在写入日志信息后panic
**** 配置logger
***** 标准logger的配置
+ 默认情况下的logger只会提供日志的时间信息，但是很多情况下我们希望得到更多信息，比如记录该日志的文件名和行号等。log标准库中为我们提供了定制这些设置的方法
+ log标准库中的Flags函数会返回标准logger的输出配置，而SetFlags函数用来设置标准logger的输出配置
  #+BEGIN_SRC go
  func Flags() int
  func SetFlags(flag int)
  #+END_SRC
***** flag选项
+ log标准库提供了如下的flag选项，它们是一系列定义好的常量
  #+BEGIN_SRC go
  const (
    // 控制输出日志信息的细节，不能控制输出的顺序和格式。
    // 输出的日志在每一项后会有一个冒号分隔：例如2009/01/23 01:23:23.123123 /a/b/c/d.go:23: message
    Ldate         = 1 << iota     // 日期：2009/01/23
    Ltime                         // 时间：01:23:23
    Lmicroseconds                 // 微秒级别的时间：01:23:23.123123（用于增强Ltime位）
    Llongfile                     // 文件全路径名+行号： /a/b/c/d.go:23
    Lshortfile                    // 文件名+行号：d.go:23（会覆盖掉Llongfile）
    LUTC                          // 使用UTC时间
    LstdFlags     = Ldate | Ltime // 标准logger的初始值
  )
  #+END_SRC
+ 示例
  #+BEGIN_SRC go
  func main() {
    	log.SetFlags(log.Llongfile | log.Lmicroseconds | log.Ldate)
	    log.Println("这是一条很普通的日志。")
  }

  // 输出
  2017/06/19 14:05:17.494943 .../log_demo/main.go:11: 这是一条很普通的日志。
  #+END_SRC
***** 配置日志前缀
+ log标准库中还提供了关于日志信息前缀的两个方法
  #+BEGIN_SRC go
  func Prefix() string
  func SetPrefix(prefix string)
  #+END_SRC
+ 其中Prefix函数用来查看标准logger的输出前缀，SetPrefix函数用来设置输出前缀
  #+BEGIN_SRC go
  func main() {
      log.SetFlags(log.Llongfile | log.Lmicroseconds | log.Ldate)
      log.Println("这是一条很普通的日志。")
      log.SetPrefix("[小王子]")
      log.Println("这是一条很普通的日志。")
  }

  // 输出
  [小王子]2017/06/19 14:05:57.940542 .../log_demo/main.go:13: 这是一条很普通的日志。
  #+END_SRC
***** 配置日志输出位置
+ SetOutput函数用来设置标准logger的输出目的地，默认是标准错误输出
  #+BEGIN_SRC go
  func SetOutput(w io.Writer)
  #+END_SRC
+ 例如，下面的代码会把日志输出到同目录下的xx.log文件中
  #+BEGIN_SRC go
  func main() {
      logFile, err := os.OpenFile("./xx.log", os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0644)
      if err != nil {
        fmt.Println("open log file failed, err:", err)
        return
      }
      log.SetOutput(logFile)
      log.SetFlags(log.Llongfile | log.Lmicroseconds | log.Ldate)
      log.Println("这是一条很普通的日志。")
      log.SetPrefix("[小王子]")
      log.Println("这是一条很普通的日志。")
  }
  #+END_SRC
+ 如果你要使用标准的logger，我们通常会把上面的配置操作写到init函数中
  #+BEGIN_SRC go
  func init() {
      logFile, err := os.OpenFile("./xx.log", os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0644)
      if err != nil {
        fmt.Println("open log file failed, err:", err)
        return
      }
      log.SetOutput(logFile)
      log.SetFlags(log.Llongfile | log.Lmicroseconds | log.Ldate)
  }
  #+END_SRC
**** 创建logger
+ log标准库中还提供了一个创建新logger对象的构造函数–New，支持我们创建自己的logger示例
  #+BEGIN_SRC go
  func New(out io.Writer, prefix string, flag int) *Logger
  #+END_SRC
+ New创建一个Logger对象。其中，参数out设置日志信息写入的目的地。参数prefix会添加到生成的每一条日志前面。参数flag定义日志的属性（时间、文件等等）
  #+BEGIN_SRC go
  func main() {
      logger := log.New(os.Stdout, "<New>", log.Lshortfile|log.Ldate|log.Ltime)
      logger.Println("这是自定义的logger记录的日志。")
  }

  // 输出
  <New>2017/06/19 14:06:51 main.go:34: 这是自定义的logger记录的日志。
  #+END_SRC
*** 文件操作
**** 打开和关闭文件
+ os.Open()函数能够打开一个文件，返回一个*File和一个err。对得到的文件实例调用close()方法能够关闭文件
+ 为了防止文件忘记关闭，我们通常使用defer注册文件关闭语句
  #+BEGIN_SRC go
  package main

  import (
      "fmt"
      "os"
  )

  func main() {
      // 只读方式打开当前目录下的main.go文件
      file, err := os.Open("./main.go")
      if err != nil {
        fmt.Println("open file failed!, err:", err)
        return
      }
      // 关闭文件
      file.Close()
  }

  #+END_SRC
**** 读取文件
***** file.Read()
****** 基本使用
+ Read方法定义如下
  #+BEGIN_SRC go
  func (f *File) Read(b []byte) (n int, err error)
  #+END_SRC
+ 它接收一个字节切片，返回读取的字节数和可能的具体错误，读到文件末尾时会返回0和io.EOF
  #+BEGIN_SRC go
  func main() {
      // 只读方式打开当前目录下的main.go文件
      file, err := os.Open("./main.go")
      if err != nil {
        fmt.Println("open file failed!, err:", err)
        return
      }
      defer file.Close()
      // 使用Read方法读取数据
      var tmp = make([]byte, 128)
      n, err := file.Read(tmp)
      if err == io.EOF {
        fmt.Println("文件读完了")
        return
      }
      if err != nil {
        fmt.Println("read file failed, err:", err)
        return
      }
      fmt.Printf("读取了%d字节数据\n", n)
      fmt.Println(string(tmp[:n]))
  }
  #+END_SRC
****** 循环读取
+ 使用for循环读取文件中的所有数据
  #+BEGIN_SRC go
  func main() {
      // 只读方式打开当前目录下的main.go文件
      file, err := os.Open("./main.go")
      if err != nil {
        fmt.Println("open file failed!, err:", err)
        return
      }
      defer file.Close()
      // 循环读取文件
      var content []byte
      var tmp = make([]byte, 128)
      for {
        n, err := file.Read(tmp)
        if err == io.EOF {
          fmt.Println("文件读完了")
          break
        }
        if err != nil {
          fmt.Println("read file failed, err:", err)
          return
        }
        content = append(content, tmp[:n]...)
      }
      fmt.Println(string(content))
  }

  #+END_SRC
****** bufio读取文件
+ bufio是在file的基础上封装了一层API，支持更多的功能
  #+BEGIN_SRC go
  package main

  import (
      "bufio"
      "fmt"
      "io"
      "os"
  )

  // bufio按行读取示例
  func main() {
      file, err := os.Open("./xx.txt")
      if err != nil {
        fmt.Println("open file failed, err:", err)
        return
      }
      defer file.Close()
      reader := bufio.NewReader(file)
      for {
        line, err := reader.ReadString('\n') //注意是字符
        if err == io.EOF {
          if len(line) != 0 {
            fmt.Println(line)
          }
          fmt.Println("文件读完了")
          break
        }
        if err != nil {
          fmt.Println("read file failed, err:", err)
          return
        }
        fmt.Print(line)
      }
  }

  #+END_SRC
****** ioutil读取整个文件
+ io/ioutil包的ReadFile方法能够读取完整的文件，只需要将文件名作为参数传入
  #+BEGIN_SRC go
  package main

  import (
      "fmt"
      "io/ioutil"
  )

  // ioutil.ReadFile读取整个文件
  func main() {
      content, err := ioutil.ReadFile("./main.go")
      if err != nil {
        fmt.Println("read file failed, err:", err)
        return
      }
      fmt.Println(string(content))
  }
  
  #+END_SRC
**** 文件写入操作
***** 打开文件
+ os.OpenFile()函数能够以指定模式打开文件，从而实现文件写入相关功能
  #+BEGIN_SRC go
  func OpenFile(name string, flag int, perm FileMode) (*File, error) {
	...
  }
  #+END_SRC
+ 其中：name：要打开的文件名 flag：打开文件的模式。 模式有以下几种
  | 模式        | 含义     |
  |-------------+----------|
  | os.O_WRONLY | 只写     |
  | os.O_CREATE | 创建文件 |
  | os.O_RDONLY | 只读     |
  | os.O_RDWR   | 读写     |
  | os.O_TRUNC  | 清空     |
  | os.O_APPEND | 追加     |
+ perm：文件权限，一个八进制数。r（读）04，w（写）02，x（执行）01
***** Write和WriteString
+ 示例
  #+BEGIN_SRC go
  func main() {
      file, err := os.OpenFile("xx.txt", os.O_CREATE|os.O_TRUNC|os.O_WRONLY, 0666)
      if err != nil {
        fmt.Println("open file failed, err:", err)
        return
      }
      defer file.Close()
      str := "hello 沙河"
      file.Write([]byte(str))       //写入字节切片数据
      file.WriteString("hello 小王子") //直接写入字符串数据
  }
  #+END_SRC
***** bufio.NewWriter
+ 示例
  #+BEGIN_SRC go
  func main() {
      file, err := os.OpenFile("xx.txt", os.O_CREATE|os.O_TRUNC|os.O_WRONLY, 0666)
      if err != nil {
        fmt.Println("open file failed, err:", err)
        return
      }
      defer file.Close()
      writer := bufio.NewWriter(file)
      for i := 0; i < 10; i++ {
        writer.WriteString("hello沙河\n") //将数据先写入缓存
      }
      writer.Flush() //将缓存中的内容写入文件
  }

  #+END_SRC
***** ioutil.WriteFile
+ 示例
  #+BEGIN_SRC go
  func main() {
      str := "hello 沙河"
      err := ioutil.WriteFile("./xx.txt", []byte(str), 0666)
      if err != nil {
        fmt.Println("write file failed, err:", err)
        return
      }
  }

  #+END_SRC
***** 范例
+ 拷贝文件函数
  #+BEGIN_SRC go
  // CopyFile 拷贝文件函数
  func CopyFile(dstName, srcName string) (written int64, err error) {
      // 以读方式打开源文件
      src, err := os.Open(srcName)
      if err != nil {
        fmt.Printf("open %s failed, err:%v.\n", srcName, err)
        return
      }
      defer src.Close()
      // 以写|创建的方式打开目标文件
      dst, err := os.OpenFile(dstName, os.O_WRONLY|os.O_CREATE, 0644)
      if err != nil {
        fmt.Printf("open %s failed, err:%v.\n", dstName, err)
        return
      }
      defer dst.Close()
      return io.Copy(dst, src) //调用io.Copy()拷贝内容
  }
  func main() {
      _, err := CopyFile("dst.txt", "src.txt")
      if err != nil {
        fmt.Println("copy file failed, err:", err)
        return
      }
      fmt.Println("copy done!")
  }

  #+END_SRC

+ 实现一个cat命令
  #+BEGIN_SRC go
  package main

  import (
      "bufio"
      "flag"
      "fmt"
      "io"
      "os"
  )

  // cat命令实现
  func cat(r *bufio.Reader) {
      for {
        buf, err := r.ReadBytes('\n') //注意是字符
        if err == io.EOF {
          break
        }
        fmt.Fprintf(os.Stdout, "%s", buf)
      }
  }

  func main() {
      flag.Parse() // 解析命令行参数
      if flag.NArg() == 0 {
        // 如果没有参数默认从标准输入读取内容
        cat(bufio.NewReader(os.Stdin))
      }
      // 依次读取每个指定文件的内容并打印到终端
      for i := 0; i < flag.NArg(); i++ {
        f, err := os.Open(flag.Arg(i))
        if err != nil {
          fmt.Fprintf(os.Stdout, "reading from %s failed, err:%v\n", flag.Arg(i), err)
          continue
        }
        cat(bufio.NewReader(f))
      }
  }

  #+END_SRC
*** strconv
strconv包实现了基本数据类型和其字符串表示的相互转换
**** string与int类型转换
+ Atoi()
  - Atoi()函数用于将字符串类型的整数转换为int类型
    #+BEGIN_SRC go
    func Atoi(s string) (i int, err error)
    #+END_SRC
  - 如果传入的字符串参数无法转换为int类型，就会返回错误
    #+BEGIN_SRC go
    s1 := "100"
    i1, err := strconv.Atoi(s1)
    if err != nil {
    fmt.Println("can't convert to int")
    } else {
        fmt.Printf("type:%T value:%#v\n", i1, i1) //type:int value:100
    }
    #+END_SRC
+ Itoa()
  Itoa()函数用于将int类型数据转换为对应的字符串表示
  #+BEGIN_SRC go
  func Itoa(i int) string

  i2 := 200
  s2 := strconv.Itoa(i2)
  fmt.Printf("type:%T value:%#v\n", s2, s2) //type:string value:"200"
  #+END_SRC
**** Parse系列函数
Parse类函数用于转换字符串为给定类型的值：ParseBool()、ParseFloat()、ParseInt()、ParseUint()
+ ParseBool()
  #+BEGIN_SRC go
  func ParseBool(str string) (value bool, err error)
  // 返回字符串表示的bool值。它接受1、0、t、f、T、F、true、false、True、False、TRUE、FALSE；否则返回错误
  #+END_SRC
+ ParseInt()
  #+BEGIN_SRC go
  func ParseInt(s string, base int, bitSize int) (i int64, err error)
  
  // 返回字符串表示的整数值，接受正负号。
  // base指定进制（2到36），如果base为0，则会从字符串前置判断，”0x”是16进制，”0”是8进制，否则是10进制；
  // bitSize指定结果必须能无溢出赋值的整数类型，0、8、16、32、64 分别代表 int、int8、int16、int32、int64；
  // 返回的err是*NumErr类型的，如果语法有误，err.Error = ErrSyntax；如果结果超出类型范围err.Error = ErrRange。
  #+END_SRC
+ ParseUnit()
  #+BEGIN_SRC go
  func ParseUint(s string, base int, bitSize int) (n uint64, err error)
  
  // ParseUint类似ParseInt但不接受正负号，用于无符号整型
  #+END_SRC
+ ParseFloat()
  #+BEGIN_SRC go
  func ParseFloat(s string, bitSize int) (f float64, err error)

  // 解析一个表示浮点数的字符串并返回其值。
  // 如果s合乎语法规则，函数会返回最为接近s表示值的一个浮点数（使用IEEE754规范舍入）。
  // bitSize指定了期望的接收类型，32是float32（返回值可以不改变精确值的赋值给float32），64是float64；
  // 返回值err是*NumErr类型的，语法有误的，err.Error=ErrSyntax；结果超出表示范围的，返回值f为±Inf，err.Error= ErrRange。

  b, err := strconv.ParseBool("true")
  f, err := strconv.ParseFloat("3.1415", 64)
  i, err := strconv.ParseInt("-2", 10, 64)
  u, err := strconv.ParseUint("2", 10, 64)
  // 这些函数都有两个返回值，第一个返回值是转换后的值，第二个返回值为转化失败的错误信息
  #+END_SRC
**** Format系列函数
Format系列函数实现了将给定类型数据格式化为string类型数据的功能
+ FormatBool()
  #+BEGIN_SRC go
  func FormatBool(b bool) string
  // 根据b的值返回”true”或”false”。
  #+END_SRC
+ FormatInt()
  #+BEGIN_SRC go
  func FormatInt(i int64, base int) string

  // 返回i的base进制的字符串表示。base 必须在2到36之间，结果中会使用小写字母’a’到’z’表示大于10的数字
  #+END_SRC
+ FormatUint()
  #+BEGIN_SRC go
  func FormatUint(i uint64, base int) string
  // 是FormatInt的无符号整数版本
  #+END_SRC
+ FormatFloat()
  #+BEGIN_SRC go
  func FormatFloat(f float64, fmt byte, prec, bitSize int) string
  // 函数将浮点数表示为字符串并返回。
  // bitSize表示f的来源类型（32：float32、64：float64），会据此进行舍入。
  // fmt表示格式：’f’（-ddd.dddd）、’b’（-ddddp±ddd，指数为二进制）、’e’（-d.dddde±dd，十进制指数）、’E’（-d.ddddE±dd，十进制指数）、’g’（指数很大时用’e’格式，否则’f’格式）、’G’（指数很大时用’E’格式，否则’f’格式）。
  // prec控制精度（排除指数部分）：对’f’、’e’、’E’，它表示小数点后的数字个数；对’g’、’G’，它控制总的数字个数。如果prec 为-1，则代表使用最少数量的、但又必需的数字来表示f
  s1 := strconv.FormatBool(true)
  s2 := strconv.FormatFloat(3.1415, 'E', -1, 64)
  s3 := strconv.FormatInt(-2, 16)
  s4 := strconv.FormatUint(2, 16)
  #+END_SRC
**** 其他
+ isPrint()
  #+BEGIN_SRC go
  func IsPrint(r rune) bool
  // 返回一个字符是否是可打印的，和unicode.IsPrint一样，r必须是：字母（广义）、数字、标点、符号、ASCII空格
  #+END_SRC
+ CanBackquote()
  #+BEGIN_SRC go
  func CanBackquote(s string) bool
  // 返回字符串s是否可以不被修改的表示为一个单行的、没有空格和tab之外控制字符的反引号字符串
  #+END_SRC
*** net/http
Go语言内置的net/http包十分的优秀，提供了HTTP客户端和服务端的实现
**** HTTP客户端
***** 基本的HTTP/HTTPS请求
+ Get、Head、Post和PostForm函数发出HTTP/HTTPS请求
  #+BEGIN_SRC go
  resp, err := http.Get("http://example.com/")
  ...
  resp, err := http.Post("http://example.com/upload", "image/jpeg", &buf)
  ...
  resp, err := http.PostForm("http://example.com/form",
	    url.Values{"key": {"Value"}, "id": {"123"}})
  #+END_SRC
+ 程序在使用完response后必须关闭回复的主体
  #+BEGIN_SRC go
  resp, err := http.Get("http://example.com/")
    if err != nil {
      // handle error
  }
  defer resp.Body.Close()
  body, err := ioutil.ReadAll(resp.Body)
  // ...

  #+END_SRC
***** GET请求示例
+ 使用net/http包编写一个简单的发送HTTP请求的Client端，代码如下
  #+BEGIN_SRC go
  package main

  import (
      "fmt"
      "io/ioutil"
      "net/http"
  )

  func main() {
      resp, err := http.Get("https://www.liwenzhou.com/")
      if err != nil {
        fmt.Println("get failed, err:", err)
        return
      }
      defer resp.Body.Close()
      body, err := ioutil.ReadAll(resp.Body)
      if err != nil {
        fmt.Println("read from resp.Body failed,err:", err)
        return
      }
      fmt.Print(string(body))
  }
  // 将上面的代码保存之后编译成可执行文件，执行之后就能在终端打印liwenzhou.com网站首页的内容了，我们的浏览器其实就是一个发送和接收HTTP协议数据的客户端，我们平时通过浏览器访问网页其实就是从网站的服务器接收HTTP数据，然后浏览器会按照HTML、CSS等规则将网页渲染展示出来
  #+END_SRC
***** 带参数的GET请求示例
+ 关于GET请求的参数需要使用Go语言内置的net/url这个标准库来处理
  #+BEGIN_SRC go
  func main() {
      apiUrl := "http://127.0.0.1:9090/get"
      // URL param
      data := url.Values{}
      data.Set("name", "小王子")
      data.Set("age", "18")
      u, err := url.ParseRequestURI(apiUrl)
      if err != nil {
        fmt.Printf("parse url requestUrl failed,err:%v\n", err)
      }
      u.RawQuery = data.Encode() // URL encode
      fmt.Println(u.String())
      resp, err := http.Get(u.String())
      if err != nil {
        fmt.Println("post failed, err:%v\n", err)
        return
      }
      defer resp.Body.Close()
      b, err := ioutil.ReadAll(resp.Body)
      if err != nil {
        fmt.Println("get resp failed,err:%v\n", err)
        return
      }
      fmt.Println(string(b))
  }

  #+END_SRC
+ 对应的Server端HandlerFunc如下
  #+BEGIN_SRC go
  func getHandler(w http.ResponseWriter, r *http.Request) {
      defer r.Body.Close()
      data := r.URL.Query()
      fmt.Println(data.Get("name"))
      fmt.Println(data.Get("age"))
      answer := `{"status": "ok"}`
      w.Write([]byte(answer))
  }
  #+END_SRC
***** Post请求示例
+ 发送POST请求的示例代码如下
  #+BEGIN_SRC go
  package main

  import (
      "fmt"
      "io/ioutil"
      "net/http"
      "strings"
  )

  // net/http post demo

  func main() {
      url := "http://127.0.0.1:9090/post"
      // 表单数据
      //contentType := "application/x-www-form-urlencoded"
      //data := "name=小王子&age=18"
      // json
      contentType := "application/json"
      data := `{"name":"小王子","age":18}`
      resp, err := http.Post(url, contentType, strings.NewReader(data))
      if err != nil {
        fmt.Println("post failed, err:%v\n", err)
        return
      }
      defer resp.Body.Close()
      b, err := ioutil.ReadAll(resp.Body)
      if err != nil {
        fmt.Println("get resp failed,err:%v\n", err)
        return
      }
      fmt.Println(string(b))
  }

  #+END_SRC
+ 对应的Server端HandlerFunc如下
  #+BEGIN_SRC go
  func postHandler(w http.ResponseWriter, r *http.Request) {
      defer r.Body.Close()
      // 1. 请求类型是application/x-www-form-urlencoded时解析form数据
      r.ParseForm()
      fmt.Println(r.PostForm) // 打印form数据
      fmt.Println(r.PostForm.Get("name"), r.PostForm.Get("age"))
      // 2. 请求类型是application/json时从r.Body读取数据
      b, err := ioutil.ReadAll(r.Body)
      if err != nil {
        fmt.Println("read request.Body failed, err:%v\n", err)
        return
      }
      fmt.Println(string(b))
      answer := `{"status": "ok"}`
      w.Write([]byte(answer))
  }

  #+END_SRC
***** 自定义Client
+ 要管理HTTP客户端的头域、重定向策略和其他设置，创建一个Client
  #+BEGIN_SRC go
  client := &http.Client{
      CheckRedirect: redirectPolicyFunc,
  }
  resp, err := client.Get("http://example.com")
  // ...
  req, err := http.NewRequest("GET", "http://example.com", nil)
  // ...
  req.Header.Add("If-None-Match", `W/"wyzzy"`)
  resp, err := client.Do(req)
  // ...

  #+END_SRC
***** 自定义Transport
+ 要管理代理、TLS配置、keep-alive、压缩和其他设置，创建一个Transport
  #+BEGIN_SRC go
  tr := &http.Transport{
      TLSClientConfig:    &tls.Config{RootCAs: pool},
      DisableCompression: true,
  }
  client := &http.Client{Transport: tr}
  resp, err := client.Get("https://example.com")
  // Client和Transport类型都可以安全的被多个goroutine同时使用。出于效率考虑，应该一次建立、尽量重用
  #+END_SRC
**** 服务端
***** 默认的Server
+ ListenAndServe使用指定的监听地址和处理器启动一个HTTP服务端。处理器参数通常是nil，这表示采用包变量DefaultServeMux作为处理器
+ Handle和HandleFunc函数可以向DefaultServeMux添加处理器
  #+BEGIN_SRC go
  http.Handle("/foo", fooHandler)
  http.HandleFunc("/bar", func(w http.ResponseWriter, r *http.Request) {
      fmt.Fprintf(w, "Hello, %q", html.EscapeString(r.URL.Path))
  })
  log.Fatal(http.ListenAndServe(":8080", nil))

  #+END_SRC
***** 默认的Server示例
+ 使用Go语言中的net/http包来编写一个简单的接收HTTP请求的Server端示例，net/http包是对net包的进一步封装，专门用来处理HTTP协议的数据。具体的代码如下
  #+BEGIN_SRC go
  // http server

  func sayHello(w http.ResponseWriter, r *http.Request) {
      fmt.Fprintln(w, "Hello 沙河！")
  }

  func main() {
      http.HandleFunc("/", sayHello)
      err := http.ListenAndServe(":9090", nil)
      if err != nil {
        fmt.Printf("http server failed, err:%v\n", err)
        return
      }
  }

  #+END_SRC
***** 自定义Server
+ 要管理服务端的行为，可以创建一个自定义的Server
  #+BEGIN_SRC go
  s := &http.Server{
      Addr:           ":8080",
      Handler:        myHandler,
      ReadTimeout:    10 * time.Second,
      WriteTimeout:   10 * time.Second,
      MaxHeaderBytes: 1 << 20,
  }
  log.Fatal(s.ListenAndServe())

  #+END_SRC
*** Context
**** 介绍
+ Go1.7加入了一个新的标准库context，它定义了Context类型，专门用来简化 对于处理单个请求的多个 goroutine 之间与请求域的数据、取消信号、截止时间等相关操作，这些操作可能涉及多个 API 调用
+ 对服务器传入的请求应该创建上下文，而对服务器的传出调用应该接受上下文。它们之间的函数调用链必须传递上下文，或者可以使用WithCancel、WithDeadline、WithTimeout或WithValue创建的派生上下文。当一个上下文被取消时，它派生的所有上下文也被取消
**** 接口
+ context.Context是一个接口，该接口定义了四个需要实现的方法。具体签名如下
  #+BEGIN_SRC go
  type Context interface {
    Deadline() (deadline time.Time, ok bool)
    Done() <-chan struct{}
    Err() error
    Value(key interface{}) interface{}
  }
  #+END_SRC
+ Deadline方法需要返回当前Context被取消的时间，也就是完成工作的截止时间（deadline）；
+ Done方法需要返回一个Channel，这个Channel会在当前工作完成或者上下文被取消之后关闭，多次调用Done方法会返回同一个Channel；
+ Err方法会返回当前Context结束的原因，它只会在Done返回的Channel被关闭时才会返回非空的值；
+ 如果当前Context被取消就会返回Canceled错误；
+ 如果当前Context超时就会返回DeadlineExceeded错误；
+ Value方法会从Context中返回键对应的值，对于同一个上下文来说，多次调用Value 并传入相同的Key会返回相同的结果，该方法仅用于传递跨API和进程间跟请求域的数据
**** Background()和TODO()
+ Go内置两个函数：Background()和TODO()，这两个函数分别返回一个实现了Context接口的background和todo。我们代码中最开始都是以这两个内置的上下文对象作为最顶层的partent context，衍生出更多的子上下文对象
+ Background()主要用于main函数、初始化以及测试代码中，作为Context这个树结构的最顶层的Context，也就是根Context
+ TODO()，它目前还不知道具体的使用场景，如果我们不知道该使用什么Context的时候，可以使用这个
+ background和todo本质上都是emptyCtx结构体类型，是一个不可取消，没有设置截止时间，没有携带任何值的Context
**** With系列函数
***** WithCancel
+ WithCancel的函数签名如下
  #+BEGIN_SRC go
  func WithCancel(parent Context) (ctx Context, cancel CancelFunc)
  #+END_SRC
+ WithCancel返回带有新Done通道的父节点的副本。当调用返回的cancel函数或当关闭父上下文的Done通道时，将关闭返回上下文的Done通道，无论先发生什么情况
+ 取消此上下文将释放与其关联的资源，因此代码应该在此上下文中运行的操作完成后立即调用cancel
  #+BEGIN_SRC go
  func gen(ctx context.Context) <-chan int {
        dst := make(chan int)
        n := 1
        go func() {
          for {
            select {
            case <-ctx.Done():
              return // return结束该goroutine，防止泄露
            case dst <- n:
              n++
            }
          }
        }()
        return dst
  }
  func main() {
      ctx, cancel := context.WithCancel(context.Background())
      defer cancel() // 当我们取完需要的整数后调用cancel

      for n := range gen(ctx) {
        fmt.Println(n)
        if n == 5 {
          break
        }
      }
  }
  // 上面的示例代码中，gen函数在单独的goroutine中生成整数并将它们发送到返回的通道。 gen的调用者在使用生成的整数之后需要取消上下文，以免gen启动的内部goroutine发生泄漏
  #+END_SRC
***** WithDeadline
+ WithDeadline的函数签名如下
  #+BEGIN_SRC go
  func WithDeadline(parent Context, deadline time.Time) (Context, CancelFunc)
  #+END_SRC
+ 返回父上下文的副本，并将deadline调整为不迟于d。如果父上下文的deadline已经早于d，则WithDeadline(parent, d)在语义上等同于父上下文。当截止日过期时，当调用返回的cancel函数时，或者当父上下文的Done通道关闭时，返回上下文的Done通道将被关闭，以最先发生的情况为准
+ 取消此上下文将释放与其关联的资源，因此代码应该在此上下文中运行的操作完成后立即调用cancel
  #+BEGIN_SRC go
  func main() {
      d := time.Now().Add(50 * time.Millisecond)
      ctx, cancel := context.WithDeadline(context.Background(), d)

      // 尽管ctx会过期，但在任何情况下调用它的cancel函数都是很好的实践。
      // 如果不这样做，可能会使上下文及其父类存活的时间超过必要的时间。
      defer cancel()

      select {
      case <-time.After(1 * time.Second):
        fmt.Println("overslept")
      case <-ctx.Done():
        fmt.Println(ctx.Err())
      }
  }
  
  #+END_SRC
+ 上面的代码中，定义了一个50毫秒之后过期的deadline，然后我们调用context.WithDeadline(context.Background(), d)得到一个上下文（ctx）和一个取消函数（cancel），然后使用一个select让主程序陷入等待：等待1秒后打印overslept退出或者等待ctx过期后退出。 因为ctx50秒后就过期，所以ctx.Done()会先接收到值，上面的代码会打印ctx.Err()取消原因
***** WithTimeout
+ WithTimeout的函数签名如下
  #+BEGIN_SRC go
  func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc)
  #+END_SRC
+ WithTimeout返回WithDeadline(parent, time.Now().Add(timeout))
+ 取消此上下文将释放与其相关的资源，因此代码应该在此上下文中运行的操作完成后立即调用cancel，通常用于数据库或者网络连接的超时控制。具体示例如下
  #+BEGIN_SRC go
  package main

  import (
      "context"
      "fmt"
      "sync"

      "time"
  )

  // context.WithTimeout
  
  var wg sync.WaitGroup
  
  func worker(ctx context.Context) {
    LOOP:
      for {
        fmt.Println("db connecting ...")
        time.Sleep(time.Millisecond * 10) // 假设正常连接数据库耗时10毫秒
        select {
        case <-ctx.Done(): // 50毫秒后自动调用
          break LOOP
        default:
        }
      }
      fmt.Println("worker done!")
      wg.Done()
  }

  func main() {
      // 设置一个50毫秒的超时
      ctx, cancel := context.WithTimeout(context.Background(), time.Millisecond*50)
      wg.Add(1)
      go worker(ctx)
      time.Sleep(time.Second * 5)
      cancel() // 通知子goroutine结束
      wg.Wait()
      fmt.Println("over")
  }

  #+END_SRC
***** WithValue
+ WithValue函数能够将请求作用域的数据与 Context 对象建立关系。声明如下：
  #+BEGIN_SRC go
  func WithValue(parent Context, key, val interface{}) Context
  #+END_SRC
+ WithValue返回父节点的副本，其中与key关联的值为val
+ 仅对API和进程间传递请求域的数据使用上下文值，而不是使用它来传递可选参数给函数
+ 所提供的键必须是可比较的，并且不应该是string类型或任何其他内置类型，以避免使用上下文在包之间发生冲突。WithValue的用户应该为键定义自己的类型。为了避免在分配给interface{}时进行分配，上下文键通常具有具体类型struct{}。或者，导出的上下文关键变量的静态类型应该是指针或接口
  #+BEGIN_SRC go
  package main

  import (
      "context"
      "fmt"
      "sync"

      "time"
  )

  // context.WithValue
  
  type TraceCode string

  var wg sync.WaitGroup

  func worker(ctx context.Context) {
      key := TraceCode("TRACE_CODE")
      traceCode, ok := ctx.Value(key).(string) // 在子goroutine中获取trace code
      if !ok {
        fmt.Println("invalid trace code")
      }
    LOOP:
      for {
        fmt.Printf("worker, trace code:%s\n", traceCode)
        time.Sleep(time.Millisecond * 10) // 假设正常连接数据库耗时10毫秒
        select {
        case <-ctx.Done(): // 50毫秒后自动调用
          break LOOP
        default:
        }
      }
      fmt.Println("worker done!")
      wg.Done()
  }

  func main() {
      // 设置一个50毫秒的超时
      ctx, cancel := context.WithTimeout(context.Background(), time.Millisecond*50)
      // 在系统的入口中设置trace code传递给后续启动的goroutine实现日志数据聚合
      ctx = context.WithValue(ctx, TraceCode("TRACE_CODE"), "12512312234")
      wg.Add(1)
      go worker(ctx)
      time.Sleep(time.Second * 5)
      cancel() // 通知子goroutine结束
      wg.Wait()
      fmt.Println("over")
  }
  
  #+END_SRC
***** 注意事项
+ 推荐以参数的方式显示传递Context
+ 以Context作为参数的函数方法，应该把Context作为第一个参数。
+ 给一个函数方法传递Context的时候，不要传递nil，如果不知道传递什么，就使用context.TODO()
+ Context的Value相关方法应该传递请求域的必要数据，不应该用于传递可选参数
+ Context是线程安全的，可以放心的在多个goroutine中传递
***** 客户端超时取消示例
****** server端
#+BEGIN_SRC go
// context_timeout/server/main.go
package main

import (
    "fmt"
    "math/rand"
    "net/http"

    "time"
)

// server端，随机出现慢响应

func indexHandler(w http.ResponseWriter, r *http.Request) {
    number := rand.Intn(2)
    if number == 0 {
      time.Sleep(time.Second * 10) // 耗时10秒的慢响应
      fmt.Fprintf(w, "slow response")
      return
    }
    fmt.Fprint(w, "quick response")
}

func main() {
    http.HandleFunc("/", indexHandler)
    err := http.ListenAndServe(":8000", nil)
    if err != nil {
      panic(err)
    }
}

#+END_SRC
****** client端
#+BEGIN_SRC go
// context_timeout/client/main.go
package main

import (
    "context"
    "fmt"
    "io/ioutil"
    "net/http"
    "sync"
    "time"
)

// 客户端

type respData struct {
    resp *http.Response
    err  error
}

func doCall(ctx context.Context) {
    transport := http.Transport{
       // 请求频繁可定义全局的client对象并启用长链接
       // 请求不频繁使用短链接
       DisableKeepAlives: true, 	}
    client := http.Client{
      Transport: &transport,
    }

    respChan := make(chan *respData, 1)
    req, err := http.NewRequest("GET", "http://127.0.0.1:8000/", nil)
    if err != nil {
      fmt.Printf("new requestg failed, err:%v\n", err)
      return
    }
    req = req.WithContext(ctx) // 使用带超时的ctx创建一个新的client request
    var wg sync.WaitGroup
    wg.Add(1)
    defer wg.Wait()
    go func() {
      resp, err := client.Do(req)
      fmt.Printf("client.do resp:%v, err:%v\n", resp, err)
      rd := &respData{
        resp: resp,
        err:  err,
      }
      respChan <- rd
      wg.Done()
    }()

    select {
    case <-ctx.Done():
      //transport.CancelRequest(req)
      fmt.Println("call api timeout")
    case result := <-respChan:
      fmt.Println("call server api success")
      if result.err != nil {
        fmt.Printf("call server api failed, err:%v\n", result.err)
        return
      }
      defer result.resp.Body.Close()
      data, _ := ioutil.ReadAll(result.resp.Body)
      fmt.Printf("resp:%v\n", string(data))
    }
}

func main() {
    // 定义一个100毫秒的超时
    ctx, cancel := context.WithTimeout(context.Background(), time.Millisecond*100)
    defer cancel() // 调用cancel释放子goroutine资源
    doCall(ctx)
}

#+END_SRC
** 第三方库
*** execl
**** wps常用函数
***** 路径相关
+ CELL("filename",A1)
  显示文件的绝对路径及文件名
+ LEFT(CELL("filename",A1),FIND("[",CELL("filename",A1))-1)
  显示文件的绝对路径
  例如：INDIRECT("'"&LEFT(CELL("filename",A1),FIND("汇总数据\2020",CELL("filename",A1))-1)&"data\2020\04\"&"[b.xlsx]Sheet1'!$A$1")
**** Excelize
***** 安装
+ 安装更新
  #+BEGIN_SRC shell
  # 安装命令
  go get github.com/360EntSecGroup-Skylar/excelize
  如果您使用 Go Modules 管理软件包，请使用下面的命令来安装最新版本。
  go get github.com/360EntSecGroup-Skylar/excelize/v2@v2.1.0
  # 更新命令
  go get -u github.com/360EntSecGroup-Skylar/excelize
  #+END_SRC
***** 导入
+ v2
  #+BEGIN_SRC go
  import (
	"fmt"

	"github.com/360EntSecGroup-Skylar/excelize/v2"
  )

  #+END_SRC
***** 简单示例
+ 创建 Excel 文档
  #+BEGIN_SRC go
  package main

  import "github.com/360EntSecGroup-Skylar/excelize"

  func main() {
        f := excelize.NewFile()
        // 创建一个工作表
        index := f.NewSheet("Sheet2")
        // 设置单元格的值
        f.SetCellValue("Sheet2", "A2", "Hello world.")
        f.SetCellValue("Sheet1", "B2", 100)
        // 设置工作簿的默认工作表
        f.SetActiveSheet(index)
        // 根据指定路径保存文件
        if err := f.SaveAs("Book1.xlsx"); err != nil {
            println(err.Error())
        }
  }

  #+END_SRC
+ 读取 Excel 文档
  #+BEGIN_SRC go
  package main

  import "github.com/360EntSecGroup-Skylar/excelize"

  func main() {
        f, err := excelize.OpenFile("Book1.xlsx")
        if err != nil {
            println(err.Error())
            return
        }
        // 获取工作表中指定单元格的值
        cell, err := f.GetCellValue("Sheet1", "B2")
        if err != nil {
            println(err.Error())
            return
        }
        println(cell)
        // 获取 Sheet1 上所有单元格
        rows, err := f.GetRows("Sheet1")
        for _, row := range rows {
            for _, colCell := range row {
                print(colCell, "\t")
            }
            println()
        }
  }

  #+END_SRC
***** 工作簿
****** 创建工作簿
+ 使用 NewFile 新建 Excel 工作薄，新创建的工作簿中会默认包含一个名为 Sheet1 的工作表
  #+BEGIN_SRC go
  func NewFile() *File
  #+END_SRC
****** 打开工作簿
+ 使用 OpenFile 打开已有 Excel 文档
  #+BEGIN_SRC go
  func OpenFile(filename string) (*File, error)
  #+END_SRC
****** 保存工作簿
+ 使用 Save 保存对 Excel 文档的编辑
  #+BEGIN_SRC go
  func (f *File) Save() error
  #+END_SRC
****** 另存为
+ 使用 SaveAs 保存 Excel 文档为指定文件
  #+BEGIN_SRC go
  func (f *File) SaveAs(name string) error
  #+END_SRC
****** 新建工作表
+ 根据给定的工作表名称添加新的工作表，并返回工作表索引。新创建的工作簿将会包含一个名为 Sheet1 的默认工作簿
  #+BEGIN_SRC go
  func (f *File) NewSheet(name string) int
  #+END_SRC
****** 删除工作表
+ 根据给定的工作表名称删除指定工作表，谨慎使用此方法，这将会影响到与被删除工作表相关联的公式、引用、图表等元素。如果有其他组件引用了被删除工作表上的值，将会引发错误提示，甚至将会导致打开工作簿失败。当工作簿中仅包含一个工作表时，调用此方法无效
  #+BEGIN_SRC go
  func (f *File) DeleteSheet(name string)
  #+END_SRC
****** 复制工作表
+ 根据给定的被复制工作表与目标工作表索引复制工作表，目标工作表索引需要开发者自行确认是否已经存在。目前支持仅包含单元格值和公式的工作表间的复制，不支持包含表格、图片、图表和透视表等元素的工作表之间的复制
  #+BEGIN_SRC go
  func (f *File) CopySheet(from, to int) error

  // 名称为 Sheet1 的工作表已经存在 ...
  index := f.NewSheet("Sheet2")
  err := f.CopySheet(1, index)
  return err
  #+END_SRC
****** 设置默认工作表
+ 根据给定的索引值设置默认工作表，索引的值应该大于 0 且小于工作簿所包含的累积工作表总数
  #+BEGIN_SRC go
  func (f *File) SetActiveSheet(index int)
  #+END_SRC
****** 获取默认工作表索引
+ 获取默认工作表的索引，如果没有找到默认工作表将返回 0
  #+BEGIN_SRC go
  func (f *File) GetActiveSheetIndex() int
  #+END_SRC
****** 设置工作表可见性
+ 根据给定的工作表名称和可见性参数设置工作表的可见性。一个工作簿中至少包含一个可见工作表。如果给定的工作表为默认工作表，则对其可见性设置无效。工作表可见性状态可参考工作表状态枚举
  #+BEGIN_SRC go
  func (f *File) SetSheetVisible(name string, visible bool) error

  // 例如，隐藏名为 Sheet1 的工作表:
  err := f.SetSheetVisible("Sheet1", false)
  #+END_SRC
+ 工作表状态枚举
  visible
  hidden
  veryHidden
****** 获取工作表可见性
+ 根据给定的工作表名称获取工作表可见性设置。例如，获取名为 Sheet1 的工作表可见性设置
  #+BEGIN_SRC go
  func (f *File) GetSheetVisible(name string) bool

  f.GetSheetVisible("Sheet1")
  #+END_SRC
****** 设置工作表视图属性
+ 根据给定的工作表名称、视图索引和视图参数设置工作表视图属性，viewIndex 可以是负数，如果是这样，则向后计数（-1 代表最后一个视图）
  #+BEGIN_SRC go
  func (f *File) SetSheetViewOptions(name string, viewIndex int, opts ...SheetViewOption) error

  // 例1:
  err = f.SetSheetViewOptions("Sheet1", -1, ShowGridLines(false))
  // 例2:
  f := excelize.NewFile()
  const sheet = "Sheet1"

  if err := f.SetSheetViewOptions(sheet, 0,
      excelize.DefaultGridColor(false),
      excelize.RightToLeft(false),
      excelize.ShowFormulas(true),
      excelize.ShowGridLines(true),
      excelize.ShowRowColHeaders(true),
      excelize.ZoomScale(80),
      excelize.TopLeftCell("C3"),
  ); err != nil {
      println(err.Error())
  }

  var zoomScale excelize.ZoomScale
  fmt.Println("Default:")
  fmt.Println("- zoomScale: 80")

  if err := f.SetSheetViewOptions(sheet, 0, excelize.ZoomScale(500)); err != nil {
      println(err.Error())
  }
  
  if err := f.GetSheetViewOptions(sheet, 0, &zoomScale); err != nil {
      println(err.Error())
  }

  fmt.Println("Used out of range value:")
  fmt.Println("- zoomScale:", zoomScale)

  if err := f.SetSheetViewOptions(sheet, 0, excelize.ZoomScale(123)); err != nil {
      println(err.Error())
  }

  if err := f.GetSheetViewOptions(sheet, 0, &zoomScale); err != nil {
      println(err.Error())
  }

  fmt.Println("Used correct value:")
  fmt.Println("- zoomScale:", zoomScale)

  // 得到输出：
  Default:
  - zoomScale: 80
  Used out of range value:
  - zoomScale: 80
  Used correct value:
  - zoomScale: 123
  #+END_SRC
+ 可选视图参数
  | 可选视图参数      | 类型    |
  |-------------------+---------|
  | DefaultGridColor  | bool    |
  | RightToLeft       | bool    |
  | ShowFormulas      | bool    |
  | ShowGridLines     | bool    |
  | ShowRowColHeaders | bool    |
  | ZoomScale         | float64 |
  | TopLeftCell       | string  |
****** 获取工作表视图属性
+ 根据给定的工作表名称、视图索引和视图参数获取工作表视图属性，viewIndex 可以是负数，如果是这样，则向后计数（-1 代表最后一个视图）
  #+BEGIN_SRC go
  func (f *File) GetSheetViewOptions(name string, viewIndex int, opts ...SheetViewOptionPtr) error
  #+END_SRC
****** 设置页眉和页脚
+ 根据给定的工作表名称和控制字符设置工作表的页眉和页脚
  #+BEGIN_SRC go
  func (f *File) SetHeaderFooter(sheet string, settings *FormatHeaderFooter) error
  #+END_SRC
+ 页眉和页脚包含如下字段
  | 字段             | 描述                           |
  |------------------+--------------------------------|
  | AlignWithMargins | 设定页眉页脚页边距与页边距对齐 |
  | DifferentFirst   | 设定第一页页眉和页脚           |
  | DifferentOddEven | 设定奇数和偶数页页眉和页脚     |
  | ScaleWithDoc     | 设定页眉和页脚跟随文档缩放     |
  | OddFooter        | 奇数页页脚控制字符             |
  | OddHeader        | 奇数页页眉控制字符             |
  | EvenFooter       | 偶数页页脚控制字符             |
  | EvenHeader       | 偶数页页眉控制字符             |
  | FirstFooter      | 首页页脚控制字符               |
  | FirstHeader      | 首页页眉控制字符               |
+ 下表中的格式代码可用于 6 个字符串类型字段: OddHeader, OddFooter, EvenHeader, EvenFooter, FirstFooter, FirstHeader
  | 格式代码               | 描述                                                                                                                               |
  |------------------------+------------------------------------------------------------------------------------------------------------------------------------|
  | &&                     | 字符 "&"                                                                                                                           |
  | &font-size             | 文本字体的大小, 其中字体大小为以磅为单位的十进制字体大小                                                                           |
  | &"font name,font type" | 文本字体名字符串、字体名称和文本字体类型字符串、字体类型                                                                           |
  | &"-,Regular"           | 常规文本格式。关闭粗体和斜体模式                                                                                                   |
  | &A                     | 当前工作表名称                                                                                                                     |
  | &B or &"-,Bold"        | 粗体文本格式, 关闭或打开，默认关闭                                                                                                 |
  | &D                     | 当前日期                                                                                                                           |
  | &C                     | 中间部分                                                                                                                           |
  | &E                     | 对文本使用双下划线                                                                                                                 |
  | &F                     | 当前工作簿文件名称                                                                                                                 |
  | &G                     | 将指定对象做为背景                                                                                                                 |
  | &H                     | 文字阴影                                                                                                                           |
  | &I or &"-,Italic"      | 文字倾斜                                                                                                                           |
  | &K                     | 字体颜色 格式为 RRGGBB 的 RGB 颜色 主题颜色被指定为 TTSNNN, 其中 TT 是主题颜色 id, S 是色调或阴影的 "+" 或者 "-", 是色调或阴影的值 |
  | &L                     | 左侧部分                                                                                                                           |
  | &N                     | 总页数                                                                                                                             |
  | &O                     | 大纲文本格式                                                                                                                       |
  | &R                     | 右侧部分                                                                                                                           |
  | &S                     | 文本删除线                                                                                                                         |
  | &T                     | 当前时间                                                                                                                           |
  | &U                     | 为文本添加单下划线。默认模式处于关闭状态                                                                                           |
  | &X                     | 上标格式                                                                                                                           |
  | &Y                     | 下标格式                                                                                                                           |
  | &Z                     | 当前工作簿文件路径                                                                                                                 |
  + 示例
    #+BEGIN_SRC go
    err := f.SetHeaderFooter("Sheet1", &excelize.FormatHeaderFooter{
          DifferentFirst:   true,
          DifferentOddEven: true,
          OddHeader:        "&R&P",
          OddFooter:        "&C&F",
          EvenHeader:       "&L&P",
          EvenFooter:       "&L&D&R&T",
          FirstHeader:      `&CCenter &"-,Bold"Bold&"-,Regular"HeaderU+000A&D`,
    })
    // 上面的例子蕴含如下格式
    // 第一页有自己的页眉和页脚
    // 奇数和偶数页具有不同的页眉和页脚
    // 奇数页标题右侧部分为当前页码
    // 奇数页页脚中心部分为当前工作簿的文件名
    // 偶数页标题左侧部分为当前页码
    // 左侧部分为当前日期，偶数页页脚右侧部分为当前时间
    // 第一页中心部分的第一行上的文本为“Center Bold Header”, 第二行为日期
    // 第一页上没有页脚
    #+END_SRC
****** 设置名称
+ 根据给定的名称和作范围设置名称，默认范围是工作簿
  #+BEGIN_SRC go
  func (f *File) SetDefinedName(definedName *DefinedName) error
  
  f.SetDefinedName(&excelize.DefinedName{
        Name:     "Amount",
        RefersTo: "Sheet1!$A$2:$D$5",
        Comment:  "defined name comment",
        Scope:    "Sheet2",
  })

  #+END_SRC
****** 获取名称
+ 获取作用范围内的工作簿和工作表的名称列表
  #+BEGIN_SRC go
  func (f *File) GetDefinedName() []DefinedName
  #+END_SRC
****** 删除名称
+ 根据给定的名称和名称作用范围删除已定义的名称，默认名称的作用范围为工作簿
  #+BEGIN_SRC go
  func (f *File) DeleteDefinedName(definedName *DefinedName) error

  f.DeleteDefinedName(&excelize.DefinedName{
        Name:     "Amount",
        Scope:    "Sheet2",
  })

  #+END_SRC
****** 设置工作簿属性
+ 设置工作簿的核心属性
  #+BEGIN_SRC go
  func (f *File) SetDocProps(docProperties *DocProperties) error
  #+END_SRC
+ 可以设置的属性包括
  | 属性           | 描述                                                            |
  |----------------+-----------------------------------------------------------------|
  | Title          | 文档标题                                                        |
  | Subject        | 文档主题                                                        |
  | Creator        | 创作者                                                          |
  | Keywords       | 文档关键词                                                      |
  | Description    | 资源内容的说明                                                  |
  | LastModifiedBy | 执行上次修改的用户                                              |
  | Language       | 文档内容的主要语言                                              |
  | Identifier     | 对给定上下文中的资源的明确引用                                  |
  | Revision       | 文档修订版本                                                    |
  | ContentStatus  | 文档内容的状态。例如: 值可能包括 "Draft"、"Reviewed" 和 "Final" |
  | Category       | 文档内容的分类                                                  |
  | Version        | 版本号，该值由用户或应用程序设置                                |
+ 示例
  #+BEGIN_SRC go
  err := f.SetDocProps(&excelize.DocProperties{
        Category:       "category",
        ContentStatus:  "Draft",
        Created:        "2019-06-04T22:00:10Z",
        Creator:        "Go Excelize",
        Description:    "This file created by Go Excelize",
        Identifier:     "xlsx",
        Keywords:       "Spreadsheet",
        LastModifiedBy: "Go Author",
        Modified:       "2019-06-04T22:00:10Z",
        Revision:       "0",
        Subject:        "Test Subject",
        Title:          "Test Title",
        Language:       "en-US",
        Version:        "1.0.0",
  })

  #+END_SRC
****** 获取工作簿属性
+ 获取工作簿的核心属性
  #+BEGIN_SRC go
  func (f *File) GetDocProps() (*DocProperties, error)
  #+END_SRC
***** 工作表
****** 设置列可见性
+ 根据给定的工作表名称（大小写敏感）和列名称设置列可见性
  #+BEGIN_SRC go
  func (f *File) SetColVisible(sheet, col string, visible bool) error

  // 例如隐藏名为 Sheet1 工作表上的 D 列
  err := f.SetColVisible("Sheet1", "D", false)
  // 隐藏名称为 Sheet1 的工作表中的 D 至 F 列
  err := f.SetColVisible("Sheet1", "D:F", false)
  #+END_SRC
****** 设置列宽度
+ 根据给定的工作表名称（大小写敏感）、列范围和宽度值设置单个或多个列的宽度
  #+BEGIN_SRC go
  func (f *File) SetColWidth(sheet, startcol, endcol string, width float64) error
  // 例如设置名为 Sheet1 工作表上 A 到 H 列的宽度为 20
  f := excelize.NewFile()
  err := f.SetColWidth("Sheet1", "A", "H", 20)
  #+END_SRC
****** 设置行高度
+ 根据给定的工作表名称（大小写敏感）、行号和高度值设置单行高度
  #+BEGIN_SRC go
  func (f *File) SetRowHeight(sheet string, row int, height float64) error
  // 例如设置名为 Sheet1 工作表首行的高度为 50
  err := f.SetRowHeight("Sheet1", 1, 50)
  #+END_SRC
****** 设置行可见性
+ 根据给定的工作表名称（大小写敏感）和行号设置行可见性
  #+BEGIN_SRC go
  func (f *File) SetRowVisible(sheet string, row int, visible bool) error
  // 例如隐藏名为 Sheet1 工作表上第二行
  err := f.SetRowVisible("Sheet1", 2, false)
  #+END_SRC
****** 获取工作表名
+ 根据给定的工作表索引获取工作表名称，如果工作表不存在将返回空字符
  #+BEGIN_SRC go
  func (f *File) GetSheetName(index int) string
  #+END_SRC
****** 获取列可见性
+ 根据给定的工作表名称（大小写敏感）和列名获取工作表中指定列的可见性，可见返回值为 true，否则为 false
  #+BEGIN_SRC go
  func (f *File) GetColVisible(sheet, column string) (bool, error)
  // 获取名为 Sheet1 的工作表上 D 列的可见性
  visible, err := f.GetColVisible("Sheet1", "D")
  #+END_SRC
****** 获取列宽度
+ 根据给定的工作表名称（大小写敏感）和行号获取工作表中指定行的高度
  #+BEGIN_SRC go
  func (f *File) GetRowHeight(sheet string, row int) (float64, error)
  // 例如，获取名为 Sheet1 的工作表首行的高度
  height, err := f.GetRowHeight("Sheet1", 1)
  #+END_SRC
****** 获取行可见性
+ 根据给定的工作表名称（大小写敏感）和行号获取工作表中指定行的可见性
  #+BEGIN_SRC go
  func (f *File) GetRowVisible(sheet string, row int) (bool, error)
  // 例如，获取名为 Sheet1 的工作表第 2 行的可见性
  err := f.GetRowVisible("Sheet1", 2)
  #+END_SRC
****** 获取工作表索引
+ 根据给定的工作表名称（大小写敏感）获取该工作表的索引，如果工作表不存在将返回 0。获取到的索引可以在设置工作簿默认工作表时，作为调用 SetActiveSheet() 函数的参数使用
  #+BEGIN_SRC go
  func (f *File) GetSheetIndex(name string) int
  #+END_SRC
****** 获取工作表列表
+ 获取工作簿中以名称和索引构成的全部工作表和图表工作表列表
  #+BEGIN_SRC go
  func (f *File) GetSheetMap() map[int]string

  f, err := excelize.OpenFile("./Book1.xlsx")
  if err != nil {
        return
  }
  for index, name := range f.GetSheetMap() {
        fmt.Println(index, name)
  }

  #+END_SRC
****** 设置工作表名称
+ 根据给定的新旧工作表名称（大小写敏感）重命名工作表。工作表名称最多允许使用 31 个字符，此功能仅更改工作表的名称，而不会更新与单元格关联的公式或引用中的工作表名称。因此使用此功能重命名工作表后可能导致公式错误或参考引用问题
  #+BEGIN_SRC go
  func (f *File) SetSheetName(oldName, newName string)
  #+END_SRC
****** 设置工作表属性
+ 根据给定的工作表名称（大小写敏感）和筛选项设置工作表属性
  #+BEGIN_SRC go
  func (f *File) SetSheetPrOptions(name string, opts ...SheetPrOption) error
  #+END_SRC
+ 可选属性列表
  | 可选属性                          | 类型   |
  |-----------------------------------+--------|
  | CodeName                          | string |
  | EnableFormatConditionsCalculation | bool   |
  | Published                         | bool   |
  | FitToPage                         | bool   |
  | AutoPageBreaks                    | bool   |
  | OutlineSummaryBelow               | bool   |
+ 示例
  #+BEGIN_SRC go
  f := excelize.NewFile()
  const sheet = "Sheet1"

  if err := f.SetSheetPrOptions(sheet,
        excelize.CodeName("code"),
        excelize.EnableFormatConditionsCalculation(false),
        excelize.Published(false),
        excelize.FitToPage(true),
        excelize.AutoPageBreaks(true),
        excelize.OutlineSummaryBelow(false),
  ); err != nil {
        panic(err)
  }

  #+END_SRC
****** 获取工作表属性
+ 根据给定的工作表名称（大小写敏感）和筛选项获取工作表属性
  #+BEGIN_SRC go
  func (f *File) GetSheetPrOptions(name string, opts ...SheetPrOptionPtr) error
  #+END_SRC
+ 示例
  #+BEGIN_SRC go
  f := excelize.NewFile()
  const sheet = "Sheet1"

  var (
        codeName                          excelize.CodeName
        enableFormatConditionsCalculation excelize.EnableFormatConditionsCalculation
        published                         excelize.Published
        fitToPage                         excelize.FitToPage
        autoPageBreaks                    excelize.AutoPageBreaks
        outlineSummaryBelow               excelize.OutlineSummaryBelow
  )

  if err := f.GetSheetPrOptions(sheet,
        &codeName,
        &enableFormatConditionsCalculation,
        &published,
        &fitToPage,
        &autoPageBreaks,
        &outlineSummaryBelow,
  ); err != nil {
        panic(err)
  }
  fmt.Println("Defaults:")
  fmt.Printf("- codeName: %q\n", codeName)
  fmt.Println("- enableFormatConditionsCalculation:", enableFormatConditionsCalculation)
  fmt.Println("- published:", published)
  fmt.Println("- fitToPage:", fitToPage)
  fmt.Println("- autoPageBreaks:", autoPageBreaks)
  fmt.Println("- outlineSummaryBelow:", outlineSummaryBelow)
  // 输出：

  Defaults:
    - codeName: ""
    - enableFormatConditionsCalculation: true
    - published: true
    - fitToPage: false
    - autoPageBreaks: false
    - outlineSummaryBelow: true
  #+END_SRC
****** 插入列
+ 根据给定的工作表名称（大小写敏感）和列名称，在指定列前插入空白列
  #+BEGIN_SRC go
  func (f *File) InsertCol(sheet, column string) error

  // 例如，在名为 Sheet1 的工作表的 C 列前插入空白列
  err := f.InsertCol("Sheet1", "C")
  #+END_SRC
****** 插入行
+ 根据给定的工作表名称（大小写敏感）和行号，在指定行前插入空白行
  #+BEGIN_SRC go
  func (f *File) InsertRow(sheet string, row int) error

  // 例如，在名为 Sheet1 的工作表的第 3 行前插入空白行：
  err := f.InsertRow("Sheet1", 3)
  #+END_SRC
****** 追加复制行
+ 根据给定的工作表名称（大小写敏感）和行号，在该行后追加复制
+ 谨慎使用此方法，这将影响所有对该工作表中原有公式、图表等资源引用的更改。如果该工作表包含任何引用值，在使用此方法后使用 Excel 应用程序打开它时将可能导致文件错误。excelize 目前仅支持对工作表上部分引用的更新
  #+BEGIN_SRC go
  func (f *File) DuplicateRow(sheet string, row int) error
  // 例如，将名为 Sheet1 的工作表的第 2 行复制到第 3 行：
  err := f.DuplicateRow("Sheet1", 2)
  #+END_SRC
****** 复制行
+ 根据给定的工作表名称（大小写敏感）和行号，在指定行后复制该行
+ 谨慎使用此方法，这将影响所有对该工作表中原有公式、图表等资源引用的更改。如果该工作表包含任何引用值，在使用此方法后使用 Excel 应用程序打开它时将可能导致文件错误。excelize 目前仅支持对工作表上部分引用的更新
  #+BEGIN_SRC go
  func (f *File) DuplicateRowTo(sheet string, row, row2 int) error
  // 例如，将名为 Sheet1 的工作表的第 2 行后复制到第 7 行：
  err := f.DuplicateRowTo("Sheet1", 2, 7)
  #+END_SRC
****** 创建行的分级显示
+ 根据给定的工作表名称（大小写敏感）、行号和分级参数创建组
  #+BEGIN_SRC go
  func (f *File) SetRowOutlineLevel(sheet string, row int, level uint8) error
  
  // 例如，在名为 Sheet1 的工作表的第 2 行创建 1 级分组
  err := f.SetRowOutlineLevel("Sheet1", 2, 1)
  #+END_SRC
****** 创建列的分级显示
+ 根据给定的工作表名称（大小写敏感）、列名称和分级参数创建组
  #+BEGIN_SRC go
  func (f *File) SetColOutlineLevel(sheet, col string, level uint8) error
  // 例如，在名为 Sheet1 的工作表的 D 列创建 2 级分组
  err := f.SetColOutlineLevel("Sheet1", "D", 2)
  #+END_SRC
****** 获取行的分级显示
+ 根据给定的工作表名称（大小写敏感）和行号获取分组级别
  #+BEGIN_SRC go
  func (f *File) GetRowOutlineLevel(sheet string, row int) (uint8, error)
  // 例如，获取名为 Sheet1 的工作表第 2 行的分组级别。
  err := f.GetRowOutlineLevel("Sheet1", 2)
  #+END_SRC
****** 获取列的分级显示
+ 根据给定的工作表名称（大小写敏感）和列名称获取分组分级
  #+BEGIN_SRC go
  func (f *File) GetColOutlineLevel(sheet, col string) (uint8, error)
  // 例如，获取名为 Sheet1 的工作表的 D 列的分组级别。
  level, err := f.GetColOutlineLevel("Sheet1", "D")
  #+END_SRC
****** 行迭代器
+ 根据给定的工作表名称（大小写敏感）获取该工作表的行迭代器
  #+BEGIN_SRC go
  func (f *File) Rows(sheet string) (*Rows, error)

  // 使用行迭代器遍历单元格：
  rows, err := f.Rows("Sheet1")
  if err != nil {
        println(err.Error())
        return
  }
  for rows.Next() {
        row, err := rows.Columns()
        if err != nil {
            println(err.Error())
        }
        for _, colCell := range row {
            print(colCell, "\t")
        }
        println()
  }

  #+END_SRC
+ 行迭代器 - 单行操作
  #+BEGIN_SRC go
  // 返回当前行所有列的值
  func (rows *Rows) Columns() ([]string, error)
  #+END_SRC
+ 行迭代器 - 遍历操作
  #+BEGIN_SRC go
  // 如果下一行有值存在将返回 true
  func (rows *Rows) Next() bool
  #+END_SRC
+ 行迭代器 - 错误处理
  #+BEGIN_SRC go
  // 当查找下一行出现错误时将返回 error
  func (rows *Rows) Error() error
  #+END_SRC
****** 在工作表中搜索
+ 根据给定的工作表名称（大小写敏感），单元格值或正则表达式来获取坐标。此函数仅支持字符串和数字的完全匹配，不支持公式计算后的结果、格式化数字和条件搜索。如果搜索结果是合并的单元格，将返回合并区域左上角的坐标
  #+BEGIN_SRC go
  func (f *File) SearchSheet(sheet, value string, reg ...bool) ([]string, error)

  // 例如，在名为 Sheet1 的工作表中搜索值 100 的坐标:
  result, err := f.SearchSheet("Sheet1", "100")
  // 例如，在名为 Sheet1 的工作表中搜索 0-9 范围内数值的坐标:
  result, err := f.SearchSheet("Sheet1", "[0-9]", true)
  #+END_SRC
****** 保护工作表
+ 防止其他用户意外或有意更改、移动或删除工作表中的数据
  #+BEGIN_SRC go
  func (f *File) ProtectSheet(sheet string, settings *FormatSheetProtection) error

  // 例如，将名为 Sheet1 的工作表设置密码保护，但是允许选择锁定的单元格、选择未锁定的单元格、编辑方案
  err := f.ProtectSheet("Sheet1", &excelize.FormatSheetProtection{
    Password:      "password",
    EditScenarios: false,
  })
  #+END_SRC
****** 取消保护工作表
+ 根据给定的工作表名称（大小写敏感）取消保护该工作表
  #+BEGIN_SRC go
  func (f *File) UnprotectSheet(sheet string) error
  #+END_SRC
****** 删除列
+ 根据给定的工作表名称（大小写敏感）和列名称删除指定列
+ 谨慎使用此方法，这将影响所有对该工作表中原有公式、图表等资源引用的更改。如果该工作表包含任何引用值，在使用此方法后使用 Excel 应用程序打开它时将可能导致文件错误。excelize 目前仅支持对工作表上部分引用的更新
  #+BEGIN_SRC go
  func (f *File) RemoveCol(sheet, col string) error

  // 例如，删除名为 Sheet1 的 C 列：
  err := f.RemoveCol("Sheet1", "C")
  #+END_SRC
****** 删除行
+ 根据给定的工作表名称（大小写敏感）和行号删除指定行
+ 谨慎使用此方法，这将影响所有对该工作表中原有公式、图表等资源引用的更改。如果该工作表包含任何引用值，在使用此方法后使用 Excel 应用程序打开它时将可能导致文件错误。excelize 目前仅支持对工作表上部分引用的更新
  #+BEGIN_SRC go
  func (f *File) RemoveRow(sheet string, row int) error
  // 例如，删除名为 Sheet1 的第 3 行：
  err := f.RemoveRow("Sheet1", 3)
  #+END_SRC
****** 按行赋值
+ 根据给定的工作表名称（大小写敏感）、起始坐标和 slice 类型引用按行赋值
  #+BEGIN_SRC go
  func (f *File) SetSheetRow(sheet, axis string, slice interface{}) error
  // 例如，在名为 Sheet1 的工作簿第 6 行上，以 B6 单元格作为起始坐标按行赋值：
  err := f.SetSheetRow("Sheet1", "B6", &[]interface{}{"1", nil, 2})
  #+END_SRC
****** 插入分页符
+ 根据给定的工作表名称和单元格坐标插入分页符。分页符是将工作表分成单独的页面以便打印的分隔线
  #+BEGIN_SRC go
  func (f *File) InsertPageBreak(sheet, cell string) (err error)
  #+END_SRC
****** 删除分页符
+ 根据给定的工作表名称和单元格坐标删除分页符
  #+BEGIN_SRC go
  func (f *File) RemovePageBreak(sheet, cell string) (err error)
  #+END_SRC
***** 单元格
****** 设置单元格的值
+ 根据给定的工作表名和单元格坐标设置单元格的值。指定的坐标不应在表格的第一行范围
  #+BEGIN_SRC go
  func (f *File) SetCellValue(sheet, axis string, value interface{}) error
  #+END_SRC
+ 支持的数据类型
  int
  int8
  int16
  int32
  int64
  uint
  uint8
  uint16
  uint32
  uint64
  float32
  float64
  string
  []byte
  time.Duration
  time.Time
  bool
  nil
****** 设置布尔型值
+ 根据给定的工作表名和单元格坐标设置布尔型单元格的值
  #+BEGIN_SRC go
  func (f *File) SetCellBool(sheet, axis string, value bool) error
  #+END_SRC
****** 设置默认字符型值
+ 根据给定的工作表名和单元格坐标设置字符型单元格的值，字符将不会进行特殊字符过滤
  #+BEGIN_SRC go
  func (f *File) SetCellDefault(sheet, axis, value string) error
  #+END_SRC
****** 设置实数
+ 根据给定的工作表名和单元格坐标设置实数单元格的值。
  #+BEGIN_SRC go
  func (f *File) SetCellInt(sheet, axis string, value int) error
  #+END_SRC
****** 设置字符型值
+ 根据给定的工作表名和单元格坐标设置字符型单元格的值，字符将会进行特殊字符过滤，并且字符串的累计长度应不超过 32767，多余的字符将会被忽略
  #+BEGIN_SRC go
  func (f *File) SetCellStr(sheet, axis, value string) error
  #+END_SRC
****** 设置单元格样式
+ 根据给定的工作表名、单元格坐标区域和样式索引设置单元格的值。样式索引可以通过 NewStyle 函数获取。注意，在同一个坐标区域内的 diagonalDown 和 diagonalUp 需要保持颜色一致
  #+BEGIN_SRC go
  func (f *File) SetCellStyle(sheet, hcell, vcell string, styleID int) error
  
  // 例1，为名为 Sheet1 的工作表 D7 单元格设置边框样式
  style, err := f.NewStyle(`{"border":[{"type":"left","color":"0000FF","style":3},{"type":"top","color":"00FF00","style":4},{"type":"bottom","color":"FFFF00","style":5},{"type":"right","color":"FF0000","style":6},{"type":"diagonalDown","color":"A020F0","style":7},{"type":"diagonalUp","color":"A020F0","style":8}]}`)
  if err != nil {
        println(err.Error())
  }
  err = f.SetCellStyle("Sheet1", "D7", "D7", style)
  
  // 例2，为名为 Sheet1 的工作表 D7 单元格设置渐变样式：
  style, err := f.NewStyle(`{"fill":{"type":"gradient","color":["#FFFFFF","#E0EBF5"],"shading":1}}`)
  if err != nil {
      println(err.Error())
  }
  err = f.SetCellStyle("Sheet1", "D7", "D7", style)

  // 例3，为名为 Sheet1 的工作表 D7 单元格设置纯色填充：
  style, err := f.NewStyle(`{"fill":{"type":"pattern","color":["#E0EBF5"],"pattern":1}}`)
  if err != nil {
      println(err.Error())
  }
  err = f.SetCellStyle("Sheet1", "D7", "D7", style)

  // 例4，为名为 Sheet1 的工作表 D7 单元格设置字符间距与旋转角度：
  f.SetCellValue("Sheet1", "D7", "样式")
  style, err := f.NewStyle(`{"alignment":{"horizontal":"center","ident":1,"justify_last_line":true,"reading_order":0,"relative_indent":1,"shrink_to_fit":true,"text_rotation":45,"vertical":"","wrap_text":true}}`)
  if err != nil {
      println(err.Error())
  }
  err = f.SetCellStyle("Sheet1", "D7", "D7", style)

  // 例5，Excel 中的日期和时间用实数表示，例如 2017/7/4 12:00:00 PM 可以用数字 42920.5 来表示。为名为 Sheet1 的工作表 D7 单元格设置时间格式：
  f.SetCellValue("Sheet1", "D7", 42920.5)
  f.SetColWidth("Sheet1", "D", "D", 13)
  style, err := f.NewStyle(`{"number_format": 22}`)
  if err != nil {
      println(err.Error())
  }
  err = f.SetCellStyle("Sheet1", "D7", "D7", style)

  // 例6，为名为 Sheet1 的工作表 D7 单元格设置字体、字号、颜色和倾斜样式：
  f.SetCellValue("Sheet1", "D7", "Excel")
  style, err := f.NewStyle(`{"font":{"bold":true,"italic":true,"family":"Times New Roman","size":36,"color":"#777777"}}`)
  if err != nil {
      println(err.Error())
  }
  err = f.SetCellStyle("Sheet1", "D7", "D7", style)

  // 例7，锁定并隐藏名为 Sheet1 的工作表 D7 单元格：
  style, err := f.NewStyle(`{"protection":{"hidden":true, "locked":true}}`)
  if err != nil {
      println(err.Error())
  }
  err = f.SetCellStyle("Sheet1", "D7", "D7", style)
  #+END_SRC
****** 设置超链接
+ 根据给定的工作表、单元格坐标、链接资源和资源类型设置单元格的超链接。资源类型分为外部链接地址 External 和工作簿内部位置链接 Location 两种。每个工作表中的包含最大超链接限制为 65530 个
  #+BEGIN_SRC go
  func (f *File) SetCellHyperLink(sheet, axis, link, linkType string) error

  // 例1，为名为 Sheet1 的工作表 A3 单元格添加外部链接：
  err := f.SetCellHyperLink("Sheet1", "A3", "https://github.com/360EntSecGroup-Skylar/excelize", "External")
  // 为单元格设置字体和下划线样式
  style, err := f.NewStyle(`{"font":{"color":"#1265BE","underline":"single"}}`)
  err = f.SetCellStyle("Sheet1", "A3", "A3", style)

  // 例2，为名为 Sheet1 的工作表 A3 单元格添加内部位置链接：
  err := f.SetCellHyperLink("Sheet1", "A3", "Sheet1!A40", "Location")
  #+END_SRC
****** 获取单元格的值
+ 根据给定的工作表和单元格坐标获取单元格的值，返回值将转换为 string 类型。如果可以将单元格格式应用于单元格的值，将返回应用后的值，否则将返回原始值
  #+BEGIN_SRC go
  func (f *File) GetCellValue(sheet, axis string) (string, error)
  #+END_SRC
****** 获取全部单元格的值
+ 根据给定的工作表名（大小写敏感）获取该工作表上全部单元格的值，以二维数组形式返回，其中单元格的值将转换为 string 类型。如果可以将单元格格式应用于单元格的值，将使用应用后的值，否则将使用原始值
  #+BEGIN_SRC go
  func (f *File) GetRows(sheet string) ([][]string, error)

  // 例如，获取并遍历输出名为 Sheet1 的工作表上的所有单元格的值：
  rows, err := f.GetRows("Sheet1")
  for _, row := range rows {
      for _, colCell := range row {
          print(colCell, "\t")
      }
      println()
  }
  #+END_SRC
****** 获取超链接
+ 根据给定的工作表名（大小写敏感）和单元格坐标获取单元格超链接，如果该单元格存在超链接，将返回 true 和链接地址，否则将返回 false 和空的链接地址
  #+BEGIN_SRC go
  func (f *File) GetCellHyperLink(sheet, axis string) (bool, string, error)

  // 例如，获取名为 Sheet1 的工作表上坐标为 H6 单元格的超链接：
  link, target, err := f.GetCellHyperLink("Sheet1", "H6")
  #+END_SRC
****** 获取样式索引
+ 根据给定的工作表名（大小写敏感）和单元格坐标获取单元格样式索引，获取到的索引可以在复制单元格样式时，作为调用 SetCellValue 函数的参数使用
  #+BEGIN_SRC go
  func (f *File) GetCellStyle(sheet, axis string) (int, error)
  #+END_SRC
****** 合并单元格
+ 根据给定的工作表名（大小写敏感）和单元格坐标区域合并单元格,如果给定的单元格坐标区域与已有的其他合并单元格相重叠，已有的合并单元格将会被删除
  #+BEGIN_SRC go
  func (f *File) MergeCell(sheet, hcell, vcell string) error

  // 例如，合并名为 Sheet1 的工作表上 D3:E9 区域内的单元格：
  err := f.MergeCell("Sheet1", "D3", "E9")
  #+END_SRC
****** 取消合并单元格
+ 根据给定的工作表名（大小写敏感）和单元格坐标区域取消合并单元格,如果给定的单元格坐标区域包含多个合并单元格，则全部合并单元格都将被取消合并
  #+BEGIN_SRC go
  func (f *File) UnmergeCell(sheet string, hcell, vcell string) error
  
  // 例如，取消合并名为 Sheet1 的工作表上 D3:E9 区域内的单元格：
  err := f.UnmergeCell("Sheet1", "D3", "E9")
  #+END_SRC
****** 获取合并单元格
+ 根据给定的工作表名（大小写敏感）获取全部合并单元格的坐标区域和值
  #+BEGIN_SRC go
  func (f *File) GetMergeCells(sheet string) ([]MergeCell, error)
  #+END_SRC
****** 添加批注
+ 根据给定的工作表名称、单元格坐标和样式参数（作者与文本信息）添加批注。作者信息最大长度为 255 个字符，最大文本内容长度为 32512 个字符，超出该范围的字符将会被忽略
  #+BEGIN_SRC go
  func (f *File) AddComment(sheet, cell, format string) error
  
  // 例如，为 Sheet1!$A$3 单元格添加批注
  err := f.AddComment("Sheet1", "A3", `{"author":"Excelize: ","text":"This is a comment."}`)
  #+END_SRC
****** 获取批注
+ 通过该方法可以获取全部工作表中的批注
  #+BEGIN_SRC go
  func (f *File) GetComments() (comments map[string][]Comment)
  #+END_SRC
****** 设置公式
+ 根据给定的工作表名（大小写敏感）和单元格坐设置取该单元格上的公式。公式的结果会在工作表被 Office Excel 应用程序打开时计算，Excelize 目前不提供公式计算引擎，所以无法计算公式结果
  #+BEGIN_SRC go
  func (f *File) SetCellFormula(sheet, axis, formula string, opts ...FormulaOpts) error
  #+END_SRC
****** 获取公式
+ 根据给定的工作表名（大小写敏感）和单元格坐标获取该单元格上的公式
  #+BEGIN_SRC go
  func (f *File) GetCellFormula(sheet, axis string) (string, error)
  #+END_SRC
***** 样式
****** 样式设置
+ Alignment 映射单元格对齐样式设置
  #+BEGIN_SRC go
  type Alignment struct {
        Horizontal      string `json:"horizontal"`
        Indent          int    `json:"indent"`
        JustifyLastLine bool   `json:"justify_last_line"`
        ReadingOrder    uint64 `json:"reading_order"`
        RelativeIndent  int    `json:"relative_indent"`
        ShrinkToFit     bool   `json:"shrink_to_fit"`
        TextRotation    int    `json:"text_rotation"`
        Vertical        string `json:"vertical"`
        WrapText        bool   `json:"wrap_text"`
  }
  #+END_SRC
+ Border 映射单元格边框样式设置
  #+BEGIN_SRC go
  type Border struct {
        Type  string `json:"type"`
        Color string `json:"color"`
        Style int    `json:"style"`
  }
  #+END_SRC
+ Font 映射字体样式设置
  #+BEGIN_SRC go
  type Font struct {
        Bold      bool    `json:"bold"`
        Italic    bool    `json:"italic"`
        Underline string  `json:"underline"`
        Family    string  `json:"family"`
        Size      float64 `json:"size"`
        Strike    bool    `json:"strike"`
        Color     string  `json:"color"`
  }

  #+END_SRC
+ Fill 映射单元格样式填充设置
  #+BEGIN_SRC go
  type Fill struct {
        Type    string   `json:"type"`
        Pattern int      `json:"pattern"`
        Color   []string `json:"color"`
        Shading int      `json:"shading"`
  }

  #+END_SRC
+ Protection 映射保护单元格属性设置
  #+BEGIN_SRC go
  type Protection struct {
        Hidden bool `json:"hidden"`
        Locked bool `json:"locked"`
  }

  #+END_SRC
+ Style 映射单元格样式设置
  #+BEGIN_SRC go
  type Style struct {
        Border        []Border    `json:"border"`
        Fill          Fill        `json:"fill"`
        Font          *Font       `json:"font"`
        Alignment     *Alignment  `json:"alignment"`
        Protection    *Protection `json:"protection"`
        NumFmt        int         `json:"number_format"`
        DecimalPlaces int         `json:"decimal_places"`
        CustomNumFmt  *string     `json:"custom_number_format"`
        Lang          string      `json:"lang"`
        NegRed        bool        `json:"negred"`
  }

  #+END_SRC
****** 创建样式
+ 通过给定的样式格式 JSON 或结构体创建样式并返回样式索引。请注意，颜色需要使用 RGB 色域代码表示
  #+BEGIN_SRC go
  func (f *File) NewStyle(style interface{}) (int, error)
  #+END_SRC
****** 边框
+ 下面的表格是 Excelize 中的边框样式索引 type 和对应的边框线条样式
  | 索引 | 线条样式               | 粗细	 | 预览效果                 |
  |------+------------------------+--------+--------------------------|
  |    0 | 无                     |      0 |                          |
  |    1 | 连续线                 |      1 | "连续线"                 |
  |    2 | 连续线                 |      2 | "连续线"                 |
  |    3 | 短线                   |      1 | "短线"                   |
  |    4 | 点线                   |      1 | "点线"                   |
  |    5 | 连续线                 |      3 | "连续线"                 |
  |    6 | 双线                   |      3 | "双线"                   |
  |    7 | 连续线                 |      0 | "连续线"                 |
  |    8 | 短线                   |      2 | "短线"                   |
  |    9 | 短线与点间隔线         |      1 | "短线与点间隔线"         |
  |   10 | 短线与点间隔线         |      2 | "短线与点间隔线"         |
  |   11 | 短线与两个点一组重复线 |      1 | "短线与两个点一组重复线" |
  |   12 | 短线与两个点一组重复线 |      2 | "短线与两个点一组重复线" |
  |   13 | 斜线与点线             |      2 | "斜线与点线"             |
+ Excelize 中的边框样式代码与 Office Excel 应用程序“设置单元格格式” - “边框”对话框中的关系对照
  | 索引 | 预览效果  | 索引 | 预览效果  |
  |------+-----------+------+-----------|
  |    0 |           |   12 | "边框 12" |
  |    7 | "边框 7"  |   13 | "边框 13" |
  |    4 | "边框 4"  |   10 | "边框 19" |
  |   11 | "边框 11" |    8 | "边框 8"  |
  |    9 | "边框 9"  |    2 | "边框 2"  |
  |    3 | "边框 3"  |  	5 | "边框 5"  |
  |    1 | "边框 1"  |    6 | "边框 6"  |
****** 颜色填充
+ 下面的表格是 Excelize 中单元格颜色填充样式和索引 shading 参数的关系对照
  | 索引 | 样式       | 索引 | 样式         |
  |------+------------+------+--------------|
  |    0 | 横向       |    3 | 对角线向下   |
  |    1 | 纵向       |    4 | 从对角线向内 |
  |    2 | 对角线向上 |    5 | 从中心向外   |
****** 图案填充
+ Excelize 中单元格图案填充样式和索引 pattern 参数的关系对照
  | 索引 | 样式         | 索引 | 样式          |
  |------+--------------+------+---------------|
  |    0 | 无           |   10 | "图案填充 10" |
  |    1 | "图案填充 1" |   11 | "图案填充 11" |
  |    2 | "图案填充 2" |   12 | "图案填充 12" |
  |    3 | "图案填充 3" |   13 | "图案填充 13" |
  |    4 | "图案填充 4" |   14 | "图案填充 14" |
  |    5 | "图案填充 5" |   15 | "图案填充 15" |
  |    6 | "图案填充 6" |   16 | "图案填充 16" |
  |    7 | "图案填充 7" |   17 | "图案填充 17" |
  |    8 | "图案填充 8" |   18 | "图案填充 18" |
  |    9 | "图案填充 9" |      |               |
****** 对齐方式
******* 水平对齐方式
+ 下面的表格是 Excelize 中单元格水平对齐方式 horizontal 参数与样式关系对照表
  | 参数             | 样式             |
  |------------------+------------------|
  | left             | 向左（缩进）     |
  | center           | 居中             |
  | right            | 靠右（缩进）     |
  | fill             | 填充             |
  | justify          | 两端对齐         |
  | centerContinuous | 跨列居中         |
  | distributed      | 分散对齐（缩进） |
******* 垂直对齐方式
+ Excelize 中单元格垂直对齐方式 vertical 参数与样式关系对照表
  | 参数        | 样式     |
  |-------------+----------|
  | top         | 顶端对齐 |
  | center      | 居中     |
  | justify     | 两端对齐 |
  | distributed | 分散对齐 |
******* 字体下划线
+ Excelize 中单元格字体下划线 underline 参数与样式关系对照表
  | 参数   | 样式 |
  |--------+------|
  | single | 单线 |
  | double | 双线 |
******* 数字自定义格式
+ Excelize 中支持的索引 number_format 参数与数字自定义格式类型对照表
  索引  类型 
  0	General
  1	0
  2	0.00
  3	#,##0
  4	#,##0.00
  5	($#,##0_);($#,##0)
  6	($#,##0_);[Red]($#,##0)
  7	($#,##0.00_);($#,##0.00)
  8	($#,##0.00_);[Red]($#,##0.00)
  9	0%
  10	0.00%
  11	0.00E+00
  12	# ?/?
  13	# ??/??
  14	m/d/yy
  15	d-mmm-yy
  16	d-mmm
  17	mmm-yy
  18	h:mm AM/PM
  19	h:mm:ss AM/PM
  20	h:mm
  21	h:mm:ss
  22	m/d/yy h:mm
  ...	...
  37	(#,##0_);(#,##0)
  38	(#,##0_);[Red](#,##0)
  39	(#,##0.00_);(#,##0.00)
  40	(#,##0.00_);[Red](#,##0.00)
  41	_(* #,##0_);_(* (#,##0);_(* "-"_);_(@_)
  42	_($* #,##0_);_($* (#,##0);_($* "-"_);_(@_)
  43	_(* #,##0.00_);_(* (#,##0.00);_(* "-"??_);_(@_)
  44	_($* #,##0.00_);_($* (#,##0.00);_($* "-"??_);_(@_)
  45	mm:ss
  46	[h]:mm:ss
  47	mm:ss.0
  48	##0.0E+0
  49	@
******* 简体中文数字自定义格式
+ Excelize 中支持的索引 number_format 参数与简体中文 zh-cn 版本数字自定义格式类型对照表
  索引	类型
  27	yyyy"年"m"月"
  28	m"月"d"日"
  29	m"月"d"日"
  30	m-d-yy
  31	yyyy"年"m"月"d"日"
  32	h"时"mm"分"
  33	h"时"mm"分"ss"秒"
  34	上午/下午 h"时"mm"分"
  35	上午/下午 h"时"mm"分"ss"秒
  36	yyyy"年"m"月
  50	yyyy"年"m"月
  51	m"月"d"日
  52	yyyy"年"m"月
  53	m"月"d"日
  54	m"月"d"日
  55	上午/下午 h"时"mm"分
  56	上午/下午 h"时"mm"分"ss"秒
  57	yyyy"年"m"月
  58	m"月"d"日"
******* Unicode 简体中文字型数字自定义格式
+ Excelize 中支持的索引 number_format 参数与 Unicode 简体中文字型 zh-cn 版本数字自定义格式类型对照表
  索引	类型
  27	yyyy"5E74"m"6708
  28	m"6708"d"65E5
  29	m"6708"d"65E5
  30	m-d-y
  31	yyyy"5E74"m"6708"d"65E5
  32	h"65F6"mm"5206
  33	h"65F6"mm"5206"ss"79D2
  34	4E0A5348/4E0B5348h"65F6"mm"5206
  35	4E0A5348/4E0B5348h"65F6"mm"5206"ss"79D2
  36	yyyy"5E74"m"6708
  50	yyyy"5E74"m"6708
  51	m"6708"d"65E5
  52	yyyy"5E74"m"6708
  53	m"6708"d"65E5
  54	m"6708"d"65E5
  55	4E0A5348/4E0B5348h"65F6"mm"5206
  56	4E0A5348/4E0B5348h"65F6"mm"5206"ss"79D2
  57	yyyy"5E74"m"6708
  58	m"6708"d"65E5"
******* 货币格式
+ Excelize 目前支持的货币格式索引如下表所示，索引号仅用于标记，不在 Office Excel 文件中使用，目前无法通过函数 GetCellValue 获取格式化值后的值
  索引	货币格式
  164	CN¥
  165	$ English (China)
  166	$ Cherokee (United States)
  167	$ Chinese (Singapore)
  168	$ Chinese (Taiwan)
  169	$ English (Australia)
  170	$ English (Belize)
  171	$ English (Canada)
  172	$ English (Jamaica)
  173	$ English (New Zealand)
  174	$ English (Singapore)
  175	$ English (Trinidad & Tobago)
  176	$ English (U.S. Vigin Islands)
  177	$ English (United States)
******* 设置列样式
+ 根据给定的工作表名称、列区域和样式索引设置列样式
  #+BEGIN_SRC go
  func (f *File) SetColStyle(sheet, columns string, styleID int) error

  // 例1，为名称为 Sheet1 的工作表中的 H 列设置样式：
  err = f.SetColStyle("Sheet1", "H", style)
  // 例2，为名称为 Sheet1 的工作表中的 C:F 列设置样式：
  err = f.SetColStyle("Sheet1", "C:F", style)
  #+END_SRC
******* 设置默认字体
+ 根据给定的字体名称为工作簿设置默认字体
  #+BEGIN_SRC go
  func (f *File) SetDefaultFont(fontName string)
  #+END_SRC
***** 数据验证
****** 添加数据验证
+ 根据给定的工作表名和数据验证对象设置数据验证规则，数据验证对象可通过 NewDataValidation 函数创建，数据验证类型和条件参考常量中的定义
  #+BEGIN_SRC go
  func (f *File) AddDataValidation(sheet string, dv *DataValidation)

  // 例1，为 Sheet1!A1:B2 设置包含验证条件为允许介于整数 10 到 20 的数据验证规则，输入无效数据时显示出错警告，标题为: "error title"，错误信息 "error body"
  dvRange := excelize.NewDataValidation(true)
  dvRange.Sqref = "A1:B2"
  dvRange.SetRange(10, 20, excelize.DataValidationTypeWhole, excelize.DataValidationOperatorBetween)
  dvRange.SetError(excelize.DataValidationErrorStyleStop, "error title", "error body")
  f.AddDataValidation("Sheet1", dvRange)

  // 例2，为 Sheet1!A3:B4 设置包含验证条件为允许大于整数 10 的数据验证规则，选定单元格时显示输入信息，输入信息为: "input body"
  dvRange = excelize.NewDataValidation(true)
  dvRange.Sqref = "A3:B4"
  dvRange.SetRange(10, 20, excelize.DataValidationTypeWhole, excelize.DataValidationOperatorGreaterThan)
  dvRange.SetInput("input title", "input body")
  f.AddDataValidation("Sheet1", dvRange)

  // 例3，为 Sheet1!A5:B6 设置验证条件为序列的数据验证规则，忽略空值并提供下拉箭头
  dvRange = excelize.NewDataValidation(true)
  dvRange.Sqref = "A5:B6"
  dvRange.SetDropList([]string{"1", "2", "3"})
  f.AddDataValidation("Sheet1", dvRange)

  // 例4，为 Sheet1!A7:B8 设置以 Sheet1!E1:E3 为来源的验证条件，忽略空值并提供下拉箭头
  dvRange := excelize.NewDataValidation(true)
  dvRange.Sqref = "A7:B8"
  dvRange.SetSqrefDropList("$E$1:$E$3", true)
  f.AddDataValidation("Sheet1", dvRange)
  #+END_SRC
****** 删除数据验证
+ 根据给定的工作表名和数据验证区域删除数据验证规则
  #+BEGIN_SRC go
  func (f *File) DeleteDataValidation(sheet, sqref string) error
  #+END_SRC
***** 工具函数
****** 创建表格
+ 根据给定的工作表名、单元格坐标区域和条件格式创建表格
  #+BEGIN_SRC go
  func (f *File) AddTable(sheet, hcell, vcell, format string) error

  // 例1，在名为 Sheet1 的工作表 A1:D5 区域创建表格
  err := f.AddTable("Sheet1", "A1", "D5", ``)
  // 例2，在名为 Sheet2 的工作表 F2:H6 区域创建带有条件格式的表格
  err := f.AddTable("Sheet2", "F2", "H6", `{"table_name":"table","table_style":"TableStyleMedium2", "show_first_column":true,"show_last_column":true,"show_row_stripes":false,"show_column_stripes":true}`)
  #+END_SRC
+ 注意，表格坐标区域至少需要覆盖两行：字符型的标题行和内容行。每列标题行的字符需保证是唯一的，并且必须在调用 AddTable 函数前设置表格的标题行数据。多个表格的坐标区域不能有交集
+ 可选参数 table_name 用以设置自定义表格名称，同一个工作表内的表格名称应该是唯一的
+ Excelize 支持的表格样式 table_style 参数：
  TableStyleLight1 - TableStyleLight21
  TableStyleMedium1 - TableStyleMedium28
  TableStyleDark1 - TableStyleDark11
****** 自动过滤器
+ 根据给定的工作表名、单元格坐标区域和条件格式创建自动过滤器。Excel 中的自动过滤器可以对一些简单的二维数据数据进行数据筛选
  #+BEGIN_SRC go
  func (f *File) AutoFilter(sheet, hcell, vcell, format string) error
  
  // 例1，在名称为 Sheet1 的工作表 A1:D4 区域创建自动过滤器
  err := f.AutoFilter("Sheet1", "A1", "D4", "")

  // 例2，在名称为 Sheet1 的工作表 A1:D4 区域创建带有格式条件的自动过滤器：
  err := f.AutoFilter("Sheet1", "A1", "D4", `{"column":"B","expression":"x != blanks"}`)
  #+END_SRC
+ 参数 column 指定了自动过滤器在过滤范围内的基准列。 Excelize 暂不支持自动过滤器的计算，在设置过滤条件后，如果需要隐藏任何不符合过滤条件的行，可以使用 SetRowVisible() 设置行的可见性
+ 为列设置过滤条件，参数 expression 用于指定过滤条件运算，支持下列运算符
  ==
  !=
  >
  <
  >=
  <=
  and
  or
+ 一个表达式可以包含一个或两个由 and 和 or 运算符分隔的语句
  x <  2000
  x >  2000
  x == 2000
  x >  2000 and x <  5000
  x == 2000 or  x == 5000
+ 可以通过在表达式中使用空白或非空白值来实现空白或非空白数据的过滤
  x == Blanks
  x == NonBlanks
+ Office Excel 还允许一些简单的字符串匹配操作
  x == b*      // 以 b 开始
  x != b*      // 不以 b 开始
  x == *b      // 以 b 结尾
  x != *b      // 不以 b 结尾
  x == *b*     // 包含 b
  x != *b*     // 不包含 b
+ 可以使用 * 来匹配任何字符或数字，用 ? 匹配任何单个字符或数字。除此之外，Office Excel 的自动过滤器不支持其他正则表达式的关键字。 Excel 的正则表达式字符可以使用 ~ 进行转义
****** 清除单元格缓存
+ Excel 会在保存时将保存带有公式的单元格的计算结果，这会导致在 Office Excel 2007 和 2010 中文档在打开时，即便计算因子已经发生变化，公式的计算结果不会自动更新,此函数会将工作簿中所有缓存结果清除，这样文档在 Office Excel 中被重新打开时会自动计算新的公式结果，但是由于计算后文档发生了变化，在关闭文档时 Office Excel 会提示是否保存工作簿
  #+BEGIN_SRC go
  func (f *File) UpdateLinkedValue() error

  // 清除单元格缓存对工作簿的影响表现为对 <v> 标签的修改，例如，清除前的单元格缓存
  <row r="19" spans="2:2">
    <c r="B19">
        <f>SUM(Sheet2!D2,Sheet2!D11)</f>
        <v>100</v>
     </c>
  </row>
  清除单元格缓存后：

  <row r="19" spans="2:2">
    <c r="B19">
        <f>SUM(Sheet2!D2,Sheet2!D11)</f>
    </c>
  </row>
  #+END_SRC
****** 单元格坐标切分
+ 将工作表的单元格坐标切分为列名和行号
  #+BEGIN_SRC go
  func SplitCellName(cell string) (string, int, error)

  // 例如，将单元格坐标 AK74 切分为 AK 和 74：
  excelize.SplitCellName("AK74") // return "AK", 74, nil
  #+END_SRC
****** 单元格坐标组合
+ 将列名和行号组合成工作表的单元格坐标
  #+BEGIN_SRC go
  func JoinCellName(col string, row int) (string, error)
  #+END_SRC
****** 列名转索引
+ 将工作表的列名（大小写不敏感）转换为索引，对于错误的列名格式将返回错误
  #+BEGIN_SRC go
  func ColumnNameToNumber(name string) (int, error)

  // 例如：
  excelize.ColumnNameToNumber("AK") // returns 37, nil
  #+END_SRC
****** 索引转列名
+ 将数据类型为整型的索引转换为列名
  #+BEGIN_SRC go
  func ColumnNumberToName(num int) (string, error)
  
  // 例如：
  excelize.ColumnNumberToName(37) // returns "AK", nil
  #+END_SRC
****** 单元格坐标转索引
+ 将由字母和数字组合而成的单元格坐标转换为 [X, Y] 形式的行、列索引，或返回错误
  #+BEGIN_SRC go
  func CellNameToCoordinates(cell string) (int, int, error)

  // 例如：
  CellCoordinates("A1") // returns 1, 1, nil
  CellCoordinates("Z3") // returns 26, 3, nil
  #+END_SRC
****** 索引转单元格坐标
+ 将 [X, Y] 形式的行、列索引转换为由字母和数字组合而成的单元格坐标，或返回错误
  #+BEGIN_SRC go
  func CoordinatesToCellName(col, row int) (string, error)
  
  // 例如：
  CoordinatesToCellName(1, 1) // returns "A1", nil
  #+END_SRC
****** 创建条件格式样式
+ 通过给定样式为条件格式创建样式，样式参数与 NewStyle() 函数的相同。请注意，使用 RGB 色域颜色代码时，目前仅支持设置字体、填充、对齐和边框的颜色
  #+BEGIN_SRC go
  func (f *File) NewConditionalStyle(style string) (int, error)
  #+END_SRC
****** 设置条件格式
+ 根据给定的工作表名称、单元格坐标区域和格式参数，为单元格值创建条件格式设置规则。条件格式是 Office Excel 的一项功能，它允许您根据特定条件将格式应用于单元格或一系列单元格
  #+BEGIN_SRC go
  func (f *File) SetConditionalFormat(sheet, area, formatSet string) error
  #+END_SRC
+ 格式参数 type 选项是必需的参数，它没有默认值。允许的类型值及其相关参数是
  类型	参数
  cell	criteria
        value
        minimum
        maximum
  date	criteria
        value
        minimum
        maximum
  time_period	criteria
  text	criteria
        value
  average	criteria
  duplicate	(none)
  unique	(none)
  top	criteria
      value
  bottom	criteria
          value
  blanks	(none)
  no_blanks	(none)
  errors	(none)
  no_errors	(none)
  2_color_scale	min_type
                max_type
                min_value
                max_value
                min_color
                max_color
  3_color_scale	min_type
                mid_type
                max_type
                min_value
                mid_value
                max_value
                min_color
                mid_color
                max_color
  data_bar	min_type
            max_type
            min_value
            max_value
            bar_color
  formula	criteria
+ criteria 参数用于设置单元格数据的条件格式运算符。它没有默认值，同常与 {"type"："cell"} 一起使用，支持的参数为
  文本描述字符	符号表示
  between	
  not between	
  equal to	    ==
  not equal to	!=
  greater than	>
  less than	    <
  greater than or equal to	>=
  less than or equal to	<=
+ .......
****** 删除条件格式
+ 根据给定的工作表名称和单元格坐标区域删除条件格式
  #+BEGIN_SRC go
  func (f *File) UnsetConditionalFormat(sheet, area string) error
  #+END_SRC
****** 设置窗格
+ 通过给定的工作表名称和窗格样式参数设置冻结窗格或拆分窗格
  #+BEGIN_SRC go
  func (f *File) SetPanes(sheet, panes string)
  #+END_SRC
****** 文件 Writer
+ Write 
  该函数提供方法将当前文件内容写入给定的 io.Writer
  #+BEGIN_SRC go
  func (f *File) Write(w io.Writer) error
  #+END_SRC
+ WriteTo
  该函数通过实现 io.WriterTo 以保存文件
  #+BEGIN_SRC go
  func (f *File) WriteTo(w io.Writer) (int64, error)
  #+END_SRC
+ WriteToBuffer
  该函数提供获取当前文件内容 *bytes.Buffer 的方法
  #+BEGIN_SRC go
  func (f *File) WriteToBuffer() (*bytes.Buffer, error)
  #+END_SRC
****** Excel 日期时间转换
+ ExcelDateToTime 将 Excel 中以 float 类型表示的日期转换为 time.Time 类型
  #+BEGIN_SRC go
  func ExcelDateToTime(excelDate float64, use1904Format bool) (time.Time, error)
  #+END_SRC
****** 字符集转码器
+ CharsetTranscoder 为非 UTF-8 编码的电子表格文档设置用户提供指定自定义编码转换器支持
  #+BEGIN_SRC go
  func (f *File) CharsetTranscoder(fn charsetTranscoderFn) *File
  #+END_SRC
***** 常量
#+BEGIN_SRC go
//  以下这些常量定义了当前支持的图表类型：

  const (
      Area                        = "area"
      AreaStacked                 = "areaStacked"
      AreaPercentStacked          = "areaPercentStacked"
      Area3D                      = "area3D"
      Area3DStacked               = "area3DStacked"
      Area3DPercentStacked        = "area3DPercentStacked"
      Bar                         = "bar"
      BarStacked                  = "barStacked"
      BarPercentStacked           = "barPercentStacked"
      Bar3DClustered              = "bar3DClustered"
      Bar3DStacked                = "bar3DStacked"
      Bar3DPercentStacked         = "bar3DPercentStacked"
      Bar3DConeClustered          = "bar3DConeClustered"
      Bar3DConeStacked            = "bar3DConeStacked"
      Bar3DConePercentStacked     = "bar3DConePercentStacked"
      Bar3DPyramidClustered       = "bar3DPyramidClustered"
      Bar3DPyramidStacked         = "bar3DPyramidStacked"
      Bar3DPyramidPercentStacked  = "bar3DPyramidPercentStacked"
      Bar3DCylinderClustered      = "bar3DCylinderClustered"
      Bar3DCylinderStacked        = "bar3DCylinderStacked"
      Bar3DCylinderPercentStacked = "bar3DCylinderPercentStacked"
      Col                         = "col"
      ColStacked                  = "colStacked"
      ColPercentStacked           = "colPercentStacked"
      Col3D                       = "col3D"
      Col3DClustered              = "col3DClustered"
      Col3DStacked                = "col3DStacked"
      Col3DPercentStacked         = "col3DPercentStacked"
      Col3DCone                   = "col3DCone"
      Col3DConeClustered          = "col3DConeClustered"
      Col3DConeStacked            = "col3DConeStacked"
      Col3DConePercentStacked     = "col3DConePercentStacked"
      Col3DPyramid                = "col3DPyramid"
      Col3DPyramidClustered       = "col3DPyramidClustered"
      Col3DPyramidStacked         = "col3DPyramidStacked"
      Col3DPyramidPercentStacked  = "col3DPyramidPercentStacked"
      Col3DCylinder               = "col3DCylinder"
      Col3DCylinderClustered      = "col3DCylinderClustered"
      Col3DCylinderStacked        = "col3DCylinderStacked"
      Col3DCylinderPercentStacked = "col3DCylinderPercentStacked"
      Doughnut                    = "doughnut"
      Line                        = "line"
      Pie                         = "pie"
      Pie3D                       = "pie3D"
      Radar                       = "radar"
      Scatter                     = "scatter"
      Surface3D                   = "surface3D"
      WireframeSurface3D          = "wireframeSurface3D"
      Contour                     = "contour"
      WireframeContour            = "wireframeContour"
      Bubble                      = "bubble"
      Bubble3D                    = "bubble3D"
  )
//  以下这些常量定义了 XML 标签的命名空间：

  const (
      SourceRelationship                           = "http://schemas.openxmlformats.org/officeDocument/2006/relationships"
      SourceRelationshipChart                      = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/chart"
      SourceRelationshipComments                   = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/comments"
      SourceRelationshipImage                      = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/image"
      SourceRelationshipTable                      = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/table"
      SourceRelationshipDrawingML                  = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/drawing"
      SourceRelationshipDrawingVML                 = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/vmlDrawing"
      SourceRelationshipHyperLink                  = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/hyperlink"
      SourceRelationshipWorkSheet                  = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet"
      SourceRelationshipChartsheet                 = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/chartsheet"
      SourceRelationshipPivotTable                 = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/pivotTable"
      SourceRelationshipPivotCache                 = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/pivotCacheDefinition"
      SourceRelationshipVBAProject                 = "http://schemas.microsoft.com/office/2006/relationships/vbaProject"
      SourceRelationshipChart201506                = "http://schemas.microsoft.com/office/drawing/2015/06/chart"
      SourceRelationshipChart20070802              = "http://schemas.microsoft.com/office/drawing/2007/8/2/chart"
      SourceRelationshipChart2014                  = "http://schemas.microsoft.com/office/drawing/2014/chart"
      SourceRelationshipCompatibility              = "http://schemas.openxmlformats.org/markup-compatibility/2006"
      NameSpaceDrawingML                           = "http://schemas.openxmlformats.org/drawingml/2006/main"
      NameSpaceDrawingMLChart                      = "http://schemas.openxmlformats.org/drawingml/2006/chart"
      NameSpaceDrawingMLSpreadSheet                = "http://schemas.openxmlformats.org/drawingml/2006/spreadsheetDrawing"
      NameSpaceSpreadSheet                         = "http://schemas.openxmlformats.org/spreadsheetml/2006/main"
      NameSpaceSpreadSheetX14                      = "http://schemas.microsoft.com/office/spreadsheetml/2009/9/main"
      NameSpaceSpreadSheetX15                      = "http://schemas.microsoft.com/office/spreadsheetml/2010/11/main"
      NameSpaceSpreadSheetExcel2006Main            = "http://schemas.microsoft.com/office/excel/2006/main"
      NameSpaceMacExcel2008Main                    = "http://schemas.microsoft.com/office/mac/excel/2008/main"
      NameSpaceXML                                 = "http://www.w3.org/XML/1998/namespace"
      NameSpaceXMLSchemaInstance                   = "http://www.w3.org/2001/XMLSchema-instance"
      StrictSourceRelationship                     = "http://purl.oclc.org/ooxml/officeDocument/relationships"
      StrictSourceRelationshipChart                = "http://purl.oclc.org/ooxml/officeDocument/relationships/chart"
      StrictSourceRelationshipComments             = "http://purl.oclc.org/ooxml/officeDocument/relationships/comments"
      StrictSourceRelationshipImage                = "http://purl.oclc.org/ooxml/officeDocument/relationships/image"
      StrictNameSpaceSpreadSheet                   = "http://purl.oclc.org/ooxml/spreadsheetml/main"
      NameSpaceDublinCore                          = "http://purl.org/dc/elements/1.1/"
      NameSpaceDublinCoreTerms                     = "http://purl.org/dc/terms/"
      NameSpaceDublinCoreMetadataIntiative         = "http://purl.org/dc/dcmitype/"
      ContentTypeDrawing                           = "application/vnd.openxmlformats-officedocument.drawing+xml"
      ContentTypeDrawingML                         = "application/vnd.openxmlformats-officedocument.drawingml.chart+xml"
      ContentTypeMacro                             = "application/vnd.ms-excel.sheet.macroEnabled.main+xml"
      ContentTypeSpreadSheetMLChartsheet           = "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml"
      ContentTypeSpreadSheetMLComments             = "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml"
      ContentTypeSpreadSheetMLPivotCacheDefinition = "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotCacheDefinition+xml"
      ContentTypeSpreadSheetMLPivotTable           = "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotTable+xml"
      ContentTypeSpreadSheetMLTable                = "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml"
      ContentTypeSpreadSheetMLWorksheet            = "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml"
      ContentTypeVBA                               = "application/vnd.ms-office.vbaProject"
      ContentTypeVML                               = "application/vnd.openxmlformats-officedocument.vmlDrawing"
      // ExtURIConditionalFormattings is the extLst child element
      // ([ISO/IEC29500-1:2016] section 18.2.10) of the worksheet element
      // ([ISO/IEC29500-1:2016] section 18.3.1.99) is extended by the addition of
      // new child ext elements ([ISO/IEC29500-1:2016] section 18.2.7)
      ExtURIConditionalFormattings = "{78C0D931-6437-407D-A8EE-F0AAD7539E65}"
      ExtURIDataValidations        = "{CCE6A557-97BC-4B89-ADB6-D9C93CAAB3DF}"
      ExtURISparklineGroups        = "{05C60535-1F16-4fd2-B633-F4F36F0B64E0}"
      ExtURISlicerListX14          = "{A8765BA9-456A-4DAB-B4F3-ACF838C121DE}"
      ExtURISlicerCachesListX14    = "{BBE1A952-AA13-448e-AADC-164F8A28A991}"
      ExtURISlicerListX15          = "{3A4CF648-6AED-40f4-86FF-DC5316D8AED3}"
      ExtURIProtectedRanges        = "{FC87AEE6-9EDD-4A0A-B7FB-166176984837}"
      ExtURIIgnoredErrors          = "{01252117-D84E-4E92-8308-4BE1C098FCBB}"
      ExtURIWebExtensions          = "{F7C9EE02-42E1-4005-9D12-6889AFFD525C}"
      ExtURITimelineRefs           = "{7E03D99C-DC04-49d9-9315-930204A7B6E9}"
      ExtURIDrawingBlip            = "{28A0092B-C50C-407E-A947-70E740481C1C}"
      ExtURIMacExcelMX             = "{64002731-A6B0-56B0-2670-7721B7C09600}"
  )
//  下面的常量定义了 EMU (English Metric Units) 单位：

  const (
      EMU int = 9525
  )
//  下面的常量定义了 XML 文档中的独立声明：

  const XMLHeader = "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\n"
//  以下这些常量定义了当前支持的数据验证类型：

  const (
      DataValidationTypeCustom
      DataValidationTypeDate
      DataValidationTypeDecimal
      DataValidationTypeTextLeng
      DataValidationTypeTime
      DataValidationTypeWhole
  )
//  以下这些常量定义了当前支持的数据验证条件：

  const (
      DataValidationOperatorBetween
      DataValidationOperatorEqual
      DataValidationOperatorGreaterThan
      DataValidationOperatorGreaterThanOrEqual
      DataValidationOperatorLessThan
      DataValidationOperatorLessThanOrEqual
      DataValidationOperatorNotBetween
      DataValidationOperatorNotEqual
  )

#+END_SRC
**** 拼音
***** go get -u github.com/chain-zhang/pinyin
+ 引用时注意，与安装时的名称大小写不同
  import 	"github.com/Chain-Zhang/pinyin"
* 常见操作
** 目录文件
*** 获取执行文件所在目录
+ 示例
  #+BEGIN_SRC go
  // 使用os包
  pwd, err := os.Getwd()
  if err != nil {
        fmt.Println(err)
        // os.Exit(1)
  }
  fmt.Println(pwd)
  
  // 或使用path/filepath包
  fmt.Println(filepath.Abs("./"))
  #+END_SRC
*** 获取操作系统指定的路径分隔符
+ 示例
  #+BEGIN_SRC go
  separator := string(os.PathSeparator)
  #+END_SRC
*** 重命名文件
+ 示例
  #+BEGIN_SRC go
  originalPath := "./test.txt"
  newPath := "test_new.txt"
  err := os.Rename(originalPath, newPath) // os.Rename("./2.txt", "./2_new.txt")
  if err != nil {
        log.Fatal(err)
  }
  #+END_SRC
*** 重命名文件夹
+ 示例
  #+BEGIN_SRC go
  originalPath := "test"
  newPath := "test_new"
  err := os.Rename(originalPath, newPath)
  if err != nil {
        log.Fatal(err)
  }
  #+END_SRC
*** 判断某个文件是否存在
+ 示例
  #+BEGIN_SRC go
  func main() {
      originalPath := "test.txt"
      result := Exists(originalPath)
      fmt.Println(result)
  }

  func Exists(name string) bool {
      if _, err := os.Stat(name); err != nil {
          if os.IsNotExist(err) {
              return false
          }
      }
      return true
  }
  #+END_SRC
*** 判断某个文件的读写权限
+ 示例
  #+BEGIN_SRC go
   //Write permission
    file, err := os.OpenFile("./test.txt", os.O_WRONLY, 0666)
    if err != nil {
        if os.IsPermission(err) {
            log.Println("Error: Write permission denied.")
        }
    }
    file.Close()

    //Read permission
    file, err = os.OpenFile("./test.txt", os.O_RDONLY, 0666)
    if err != nil {
        if os.IsPermission(err) {
            log.Println("Error: Read permission denied.")
        }
    }
    file.Close()
  #+END_SRC
*** 获取指定目录下的所有文件不包含子目录(可以指定获取文件、目录或所有)
+ 示例
  #+BEGIN_SRC go
  files, err := ioutil.ReadDir(pwd) // 当前目录下，也可以手动指定"./"、"E:/"
	if err != nil {
		log.Fatal(err)
	}

	for _, f := range files {
		if f.IsDir() { // 过滤为只打印目录，不加if判断则打印文件和目录
			fmt.Println(f.Name())
		}
	}
  #+END_SRC
*** 创建目录
+ 示例
  #+BEGIN_SRC go
    // mask := syscall.Umask(0)   //创建目录除了给定的权限还要加上系统的Umask，Go也是如实遵循这种约定
    // defer syscall.Umask(mask)
    os.Mkdir("abc", os.ModePerm)              //创建目录权限为0777  
    os.MkdirAll("dir1/dir2/dir3", os.ModePerm)   //创建多级目录权限为0777   

    // Mkdir 用于创建单个目录
    // mask := syscall.Umask(0)
    // defer syscall.Umask(mask)
     err:=os
    .Mkdir("./dir1",os.ModePerm)
    if err!=nil{
        fmt.Println(err)
    }
  #+END_SRC

+ 根据日期创建目录
  #+BEGIN_SRC go
  import (
    "os"
    "path/filepath"
    "time"
  )
  // CreateDateDir 根据当前日期来创建文件夹
  func CreateDateDir(Path string) string {
      folderName := time.Now().Format("20060102")
      folderPath := filepath.Join(Path, folderName)
      if _, err := os.Stat(folderPath); os.IsNotExist(err) {
          // 必须分成两步：先创建文件夹、再修改权限
          os.Mkdir(folderPath, 0777) //0777也可以os.ModePerm
          os.Chmod(folderPath, 0777)
	    }
      return folderPath
  }
  #+END_SRC
*** 创建文件
+ 示例
  #+BEGIN_SRC go
  f1, _ := os.Create("./1.txt") 
  defer f1.Close()
  #+END_SRC
*** 以读写方式打开文件，如果不存在则创建文件，等同于上面os.Create
+ 示例
  #+BEGIN_SRC go
  f4, _ := os.OpenFile("./4.txt", os.O_RDWR|os.O_CREATE|os.O_TRUNC, 0666)
  defer f4.Close()
  #+END_SRC
*** 用os.path.join()连接两个文件名地址
+ 示例
  #+BEGIN_SRC go
  os.path.join("D:\","test.txt")      \\结果是D:\test.txt
  #+END_SRC
*** 删除指定目录下所有文件
+ 示例
  #+BEGIN_SRC go
  os.Remove("abc/d/e/f")
  #+END_SRC
*** 删除指定目录
+ 示例
  #+BEGIN_SRC go
  os.RemoveAll("abc")
  #+END_SRC
*** 拷贝文件
**** io.Copy()函数
+ 示例
  #+BEGIN_SRC go
        func copy(src, dst string) (int64, error) {
                  sourceFileStat, err := os.Stat(src)
                  if err != nil {
                          return 0, err
                  }

                  if !sourceFileStat.Mode().IsRegular() {
                          return 0, fmt.Errorf("%s is not a regular file", src)
                  }

                  source, err := os.Open(src)
                  if err != nil {
                          return 0, err
                  }
                  defer source.Close()

                  destination, err := os.Create(dst)
                  if err != nil {
                          return 0, err
                  }
                  defer destination.Close()
                  nBytes, err := io.Copy(destination, source)
                  return nBytes, err
          }

          func CopyFile(dstName, srcName string) (written int64, err error) {
              src, err := os.Open(srcName)
              if err != nil {
                  return
              }
              defer src.Close()
              dst, err := os.OpenFile(dstName, os.O_WRONLY|os.O_CREATE, 0644)
              if err != nil {
                  return
              }
              defer dst.Close()
              return io.Copy(dst, src)
          }

  #+END_SRC
** 字符串
*** 判断
+ 示例
  #+BEGIN_SRC go
  // EqualFold
  // 判断两个字符串是否相等, 不区分大小写
  bool := strings.EqualFold("Home", "home")
  // -> true

  // HasPrefix
  // 是否包含某前缀, 区分大小写
  bool := strings.HasPrefix("Home", "h")
  // -> false

  // HasSuffix
  // 是否包含某一后缀, 区分大小写
   bool := strings.HasSuffix("Home", "me")
   // -> true

   // Contains
   // 是否包含某字串, 区分大小写
   bool := strings.Contains("HOME", "ho")
   // -> false
  #+END_SRC
*** 位置
+ 示例
  #+BEGIN_SRC go
  // Index
  // 字符首次出现的位置，不存在返回 -1
  position := strings.Index("lorem lorem", "lo")
  // -> 0

  // IndexFunc
  // 返回满足回调函数字符首次出现的位置
  num := strings.IndexFunc("me", func(r rune)bool {
      return r == rune('m')
  })
  // -> 0
  
  // LastIndex
  // 返回字符串，最后一次出现的位置
  num := strings.LastIndex("mm", "m")
  // -> 1

  // LastIndexFunc
  // 返回满足回调函数 的字符最后出现的位置, 使用方法与 IndexFunc 相同
  #+END_SRC
*** 转换
+ 示例
  #+BEGIN_SRC go
  // Title
  // 返回单词首字母大写的拷贝
  str := strings.Title("go home")
  // -> Go Home

  // ToLower
  // 返回字符全小写拷贝
  str := strings.ToLower("GO HOME")
  // -> go home

  // ToUpper
  // 返回字符全大写拷贝
  str := string.ToUpper("go home")
  // -> GO HOME

  // 重复/替换
  // Repeat
  // 字符串重复n次
  str := strings.Repeat("m", 3)
  // -> mmm

  // Replace
  // 字符串替换 小于0全部替换
  str := strings.Replace("co co co co", "co", "jc", 2)

  // Trim
  // 去除前后缀
  str := strings.Trim(" - title - ", "-")
  // title

  // TrimSpace
  // 去除前后空格
  #+END_SRC
*** 切分
+ 示例
  #+BEGIN_SRC go
  // Fields
  // 按照空格 分割字符
  strs := strings.Fields("coco jeck")
  // -> [coco jeck]

  // FieldsFunc
  // 根据回调 分割字符, 回调函数接收 rune 作为参数
  // 使用逗号分割
  str := strings.FieldsFunc("coco,jeck,andy", func(r rune) bool {
      return r == rune(',')
  })
  // -> [coco jeck andy]

  // Split
  // 使用指定字符作为分割符
  str := strings.Split("product/id/place", "/")
  // -> [product id place]

  // SplitN
  // 指定切分数量的Split
  str := strings.Split("product/id/place", "/", 2)
  // -> [product id/place]

  // Join
  // 合并字符串
  str := strings.Join([]string{"coco", "jeck"}, ",")
  // -> coco,jeck
  #+END_SRC
*** 读写
+ 示例
  #+BEGIN_SRC go
  // 获取字符串的io对象
  // NewRead
  // 创建字符串 Reader

  // NewRepacer
  // 创建字符串替换对象
  #+END_SRC
*** 常见操作
+ 按照位置截取新的字符串
  #+BEGIN_SRC go
  str := "XBodyContentX"
  content := str[1 : len(str)-1]
  #+END_SRC
** 日期时间
*** 获取当前日期
+ 示例
  #+BEGIN_SRC go
  now := time.Now()
  fmt.Printf("current time:%v\n", now)

  year := now.Year()
  month := now.Month()
  day := now.Day()
  hour := now.Hour()
  minute := now.Minute()
  second := now.Second()
  // %02d表示不够2位的话，就补0
  fmt.Printf("%02d-%02d-%02d %02d:%02d:%02d\n ", year, month, day, hour, minute, second)
  #+END_SRC
*** 时间格式化
+ 预设
  #+BEGIN_SRC go
  // 构建时区
  var timeLocation *time.Location
  timeLocation, _ = time.LoadLocation("")       //UTC
  timeLocation, _ = time.LoadLocation("UTC")      //UTC
  timeLocation, _ = time.LoadLocation("Local")     //Local
  timeLocation, _ = time.LoadLocation("Asia/Shanghai") //使用时区码
 
  //golang的时间格式化pattern
  var timeLayout = "2006-01-02 15:04:05"
  #+END_SRC
+ 示例
  #+BEGIN_SRC go
  now := time.Now()
  timeStr := now.Format("2006-01-02 15:04:05")
  fmt.Printf("time:%s\n", timeStr)
  #+END_SRC
* 框架
** gin
+ https://github.com/gin-gonic/gin
  https://gin-gonic.com/
*** 安装配置
+ 安装
  go get -u github.com/gin-gonic/gin
+ 导入
  import "github.com/gin-gonic/gin"
  import "net/http"(可选项)
+ 快速开始
  #+BEGIN_SRC go
  package main

  import "github.com/gin-gonic/gin"

  func main() {
        r := gin.Default()
        r.GET("/ping", func(c *gin.Context) {
          c.JSON(200, gin.H{
            "message": "pong",
          })
        })
        r.Run() // listen and serve on 0.0.0.0:8080 (for windows "localhost:8080")
  }
  // # run example.go and visit 0.0.0.0:8080/ping (for windows "localhost:8080/ping") on browser
  // $ go run example.go
  #+END_SRC
*** HTTP
**** HTTP请求和参数解析
***** 请求类型
****** GET
****** POST
****** DELETE
****** HEAD
****** OPTIONS
*** 创建Engine
+ 在gin框架中，Engine被定义为一个结构体，其中包含了路由组、中间件、页眉渲染接口、框架配置设置等相关内容
+ 默认的Engine可以通过gin.Default或gin.New进行创建，区别在于gin.Default也使用gin.New创建Engine实例，但会默认使用Logger和Recovery中间件
  #+BEGIN_SRC go
  engine1 := gin.Default()
  engine2 := gin.New()
  #+END_SRC
+ 通常情况下，应使用gin.Default创建Engine实例
+ 在创建的engine实例中，包含很多方法可以直接处理不同类型的HTTP请求
*** 通用处理HTTP请求
+ engine中可以使用Handle方法直接进行HTTP请求的处理
+ Handle方法包含三个参数
  #+BEGIN_SRC go
  func (group *RouterGroup) Handle(httpMethod, relativePath string, handlers ...HandlerFunc) IRoutes
  #+END_SRC
  - httpMethod
    表示要处理HTTP请求的类型，是GET、POST、DELETE等8种请求类型中的一种
  - relativePath
    表示要解析的接口，由开发者进行定义
  - handlers
    表示处理对应请求的的代码的定义
**** Handle处理GET请求
+ 示例
  #+BEGIN_SRC go
  engine.Handle("GET", "/hello", func(context *gin.Context) {
      //获取请求接口
      fmt.Println(context.FullPath())
      //获取字符串参数
      name := context.DefaultQuery("name", "")
      fmt.Println(name)

      //输出
      context.Writer.Write([]byte("Hello ," + name))
  })
  #+END_SRC
+ 通过Handle方法第一个参数指定处理GET类型的请求，解析的接口是/hello
+ Context是gin框架中封装的一个结构体，这是gin框架中最重要，最基础的一个结构体对象。该结构体可以提供我们操作请求，处理请求，获取数据等相关的操作，通常称之为上下文对象，简单说为我们提供操作环境
+ 可以通过context.Query和context.DefaultQuery获取GET请求携带的参数
+ 可以通过context.Writer.Write向请求发起端返回数据
**** Handle处理POST请求
+ 示例
  #+BEGIN_SRC go
  engine.Handle("POST", "/login", func(context *gin.Context) {

      fmt.Println(context.FullPath())
      //userName
      username := context.PostForm("username")
      fmt.Println(username)
      
      //passWord
      password := context.PostForm("pwd")
      fmt.Println(password)
      
      context.Writer.Write([]byte("User login"))
  })
  #+END_SRC
+ 第一个参数指定了解析POST类型的请求，第二个参数指定解析的接口为/login
+ POST请求是以form表单的方式提交数据的，可以通过context.PostForm获取表单中提交的数据字段
*** 分类处理
+ 除了engine中包含的通用的处理方法以外，engine还可以按类型进行直接解析。engine中包含有get方法、post方法、delete方法等与http请求类型对应的方法
**** engine.GET()处理GET请求
+ 示例
  #+BEGIN_SRC go
  engine.GET("/hello", func(context *gin.Context) {
      fmt.Println(context.FullPath())

      username := context.Query("name")
      fmt.Println(username)
      
      context.Writer.Write([]byte("Hello," + username))
  })
  #+END_SRC
+ context.DefaultQuery
  除了context.DefaultQuery方法获取请求携带的参数数据以外，还可以使用context.Query方法来获取Get请求携带的参数
**** engine.POST()处理POST请求
+ 示例
  #+BEGIN_SRC go
  engine.POST("/login", func(context *gin.Context) {

      fmt.Println(context.FullPath())
      username, exist := context.GetPostForm("username")
      if exist {
          fmt.Println(username)
      }

      password, exists := context.GetPostForm("pwd")
      if exists {
          fmt.Println(password)
      }

      context.Writer.Write([]byte("Hello , " + username))
  })
  #+END_SRC
+ context.GetPostForm获取表单数据
  POST请求以表单的形式提交数据,除了可以使用context.PostForm获取表单数据意外，还可以使用context.GetPostForm来获取表单数据
**** engine.DELETE()处理DELETE请求
+ 在项目开发中，通常都是遵循RESTful标准进行接口开发。除了GET、POST以外，还会有DELETE等操作
+ 比如要执行某个删除操作，会发送DELETE类型的请求，同时需要携带一些操作的参数。比如要删除用户，按照RESTful标准会进行如下所示
  #+BEGIN_SRC go
  engine.DELETE("/user/:id", DeleteHandle)
  func DeleteHandle(context *gin.Context) {
      fmt.Println(context.FullPath())

      userID := context.Param("id")

      fmt.Println(userID)

      context.Writer.Write([]byte("Delete user's id : " + userID))
  }
  #+END_SRC
+ context.Param获取请求参数
  客户端的请求接口是DELETE类型，/user/1,最后的1是要删除的用户的id，是一个变量。因此在服务端gin中，通过路由的:id来定义一个要删除用户的id变量值，同时使用context.Param进行获取
**** RouterGroup
+ 之所以engine中包含通用型的Handle和分类处理的GET、POST等类型的方法，是因为Engine中有RouterGroup作为匿名字段
+ RouteGroup可以称之为路由集合，在gin中定义为结构体
  #+BEGIN_SRC go
  type RouterGroup struct {
      Handlers HandlersChain
      basePath string
      engine   *Engine
      root     bool
  }
  #+END_SRC
+ RouteGroup的作用就是为每一个服务请求提供解析功能，并指定每一个请求对应的处理程序
*** 请求参数绑定与多数据格式处理
+ 只有username和password两个字段的表单数据进行提交时，可以使用context.PostForm和context.GetPostForm获取。但是如果表单数据较多时，使用PostForm和GetPostForm一次获取一个表单数据，开发效率较慢
+ Gin框架提供给开发者表单实体绑定的功能，可以将表单数据与结构体绑定
**** 表单实体绑定 
+ 表单数据的提交，往往对应着完整的数据结构体定义，其中对应着表单的输入项。gin框架提供了数据结构体和表单提交数据绑定的功能，提高表单数据获取的效率
+ 用户注册需要提交表单数据，假设注册时表单数据包含三项，分别为：username、phone和password
  #+BEGIN_SRC go
  type UserRegister struct {
      Username string form:"username" binding:"required"
      Phone    string form:"phone" binding:"required"
      Password string form:"password" binding:"required"
  }
  #+END_SRC
+ 创建了UserRegister结构体用于接收表单数据，通过tag标签的方式设置每个字段对应的form表单中的属性名，通过binding属于设置属性是否是必须
***** ShouldBindQuery
+ 使用ShouldBindQuery可以实现Get方式的数据请求的绑定
  #+BEGIN_SRC go
  func main() {

      engine := gin.Default()

      // http://localhost:8080/hello?name=davie&classes=软件工程
      engine.GET("/hello", func(context *gin.Context) {

          fmt.Println(context.FullPath())

          var student Student
          err := context.ShouldBindQuery(&student)
          if err != nil {
              log.Fatal(err.Error())
          }

          fmt.Println(student.Name)
          fmt.Println(student.Classes)
          context.Writer.Write([]byte("hello," + student.Name))

      })

      engine.Run()
  }

  type Student struct {
      Name    string form:"name"
      Classes string form:"classes"
  }
  #+END_SRC
***** ShouldBind
+ 使用ShouldBind可以实现Post方式的提交数据的绑定工作
  #+BEGIN_SRC go
  func main() {

      engine := gin.Default()

      engine.POST("/register", func(context *gin.Context) {
          fmt.Println(context.FullPath())
          var _register Register
          if err := context.ShouldBind(&_register); err != nil {
              log.Fatal(err.Error())
              return
          }

          fmt.Println(_register.UserName)
          fmt.Println(_register.Phone)
          context.Writer.Write([]byte(_register.UserName + " Register "))

      })

      engine.Run()
  }
  
  type Register struct {
      UserName string form:"name"
      Phone    string form:"phone"
      Password string form:"pwd"
  }
  #+END_SRC
***** ShouldBindJson
+ 当客户端使用Json格式进行数据提交时，可以采用ShouldBindJson对数据进行绑定并自动解析
  #+BEGIN_SRC go
  func main() {

      engine := gin.Default()

      engine.POST("/addstudent", func(context *gin.Context) {
          fmt.Println(context.FullPath())
          var person Person
          if err := context.BindJSON(&person); err != nil {
              log.Fatal(err.Error())
              return
          }

          fmt.Println("姓名：" + person.Name)
          fmt.Println("年龄：", person.Age)
          context.Writer.Write([]byte(" 添加记录：" + person.Name))
      })

      engine.Run()
  }

  type Person struct {
      Name string form:"name"
      Sex  string form:"sex"
      Age  int    form:"age"
  }
  #+END_SRC
*** 多数据格式返回请求结果
+ 在gin框架中，支持返回多种请求数据格式
**** []byte
+ 请求返回数据格式为[]byte。通过context.Writer.Write方法写入[]byte数据，使用context.Writer.Write向客户端写入返回数据。Writer是gin框架中封装的一个ResponseWriter接口类型，write方法就是http.ResponseWriter中包含的方法
  #+BEGIN_SRC go
  engine := gin.Default()
  engine.GET("/hello", func(context *gin.Context) {
        fullPath := "请求路径：" + context.FullPath()
        fmt.Println(fullPath)
        context.Writer.Write([]byte(fullPath))
  })
  engine.Run()
  #+END_SRC
**** string
+ 除了write方法以外，ResponseWriter自身还封装了WriteString方法返回数据
  #+BEGIN_SRC go
  engine.GET("/hello", func(context *gin.Context) {
        fullPath := "请求路径：" + context.FullPath()
        fmt.Println(fullPath)
        context.Writer.WriteString(fullPath)
  })
  #+END_SRC
**** JSON
+ 除了使用context.Writer对象返回[]byte和string类型的数据意外。在项目开发中，JSON格式规范使用的更为普遍
+ gin框架中的context包含的JSON方法可以将结构体类型的数据转换成JSON格式的结构化数据，然后返回给客户端
***** map类型
+ 调用JSON将map类型的数据转换成为json格式并返回给前端,第一个参数200表示设置请求返回的状态码。和http请求的状态码一致
+ 示例
  #+BEGIN_SRC go
  engine := gin.Default()
  engine.GET("/hellojson", func(context *gin.Context) {
      fullPath := "请求路径：" + context.FullPath()
      fmt.Println(fullPath)

      context.JSON(200, map[string]interface{}{
          "code":    1,
          "message": "OK",
          "data":    fullPath,
      })
  })
  engine.Run(":9000") 
  #+END_SRC
***** 结构体类型
+ 除了map以外，结构体也是可以直接转换为JSON格式进行返回的
  #+BEGIN_SRC go
  //通用请求返回结构体定义
  type Response struct {
      Code    int         json:"code"
      Message string      json:"msg"
      Data    interface{} json:"data"
  }

  engine.GET("/jsonstruct", func(context *gin.Context) {
      fullPath := "请求路径：" + context.FullPath()
      fmt.Println(fullPath)
      resp := Response{Code: 1, Message: "Ok", Data: fullPath}
      context.JSON(200, &resp)
  })
  #+END_SRC
**** HTML模板
+ 除了JSON格式以外，gin框架还支持返回HTML格式的数据。可以直接渲染HTML页面
  #+BEGIN_SRC go
  engine := gin.Default()
  //设置html的目录
  engine.LoadHTMLGlob("./html/*")
  engine.GET("/hellohtml", func(context *gin.Context) {
      fullPath := "请求路径:" + context.FullPath()

      context.HTML(http.StatusOK, "index.html", gin.H{
          "title":    "Gin教程",
          "fullpath": fullPath,
      })
  })
  engine.Run(":9000")
  #+END_SRC
+ 通过context.HTML来加载HTMl页面或者模板。同时需要在项目目录下有相应的html模板文件
  #+BEGIN_SRC go
   {{.title}}



   Gin教程

   {{.fullpath}}
  #+END_SRC
**** 加载静态资源文件
+ 在上面的index.html的基础上，添加一张img进行展示。需要将img所在的目录进行静态资源路径设置才可能会生效
  #+BEGIN_SRC go
  engine.Static("/img", "./img")
  #+END_SRC
+ 在工程项目的根目录下创建img目录，用于存放静态的img资源。同理，在项目开发时，一些静态的资源文件如html、js、css等可以通过静态资源文件设置的方式来进行设置
*** 使用路由组分类处理请求
+ gin框架中可以使用路由组来实现对路由的分类
+ 路由组是router.Group中的一个方法，用于对请求进行分组
  #+BEGIN_SRC go
  engine := gin.Default()
  userGroup := engine.Group("/user")
  userGroup.GET("/register", registerHandle)
  userGroup.GET("/login", loginHandle)
  userGroup.GET("/info", infoHandle)
  engine.Run(":9000")
  ...

  func registerHandle(context *gin.Context) {
      fullPath := " 用户注册功能 " + context.FullPath()
      fmt.Println(fullPath)
      context.Writer.WriteString(fullPath)
  }

  func loginHandle(context *gin.Context) {
      fullPath := " 用户登录功能 " + context.FullPath()
      fmt.Println(fullPath)
      context.Writer.WriteString(fullPath)
  }

  func infoHandle(context *gin.Context) {
      fullPath := " 信息查看功能 " + context.FullPath()
      fmt.Println(fullPath)
      context.Writer.WriteString(fullPath)
  }
  #+END_SRC
+ Group返回一个RouterGroup指针对象，而RouterGroup是gin框架中的一个路由组结构体定义。我们来看一下RouterGroup的定义如下所示
  #+BEGIN_SRC go
  type RouterGroup struct {
      Handlers HandlersChain
      basePath string
      engine   *Engine
      root     bool
  }
  #+END_SRC
+ RouterGroup实现了IRoutes中定义的方法，包含统一处理请求的Handle和分类型处理的GET、POST等。IRouters定义如下所示
  #+BEGIN_SRC go
  type IRoutes interface {
      Use(...HandlerFunc) IRoutes

      Handle(string, string, ...HandlerFunc) IRoutes
      Any(string, ...HandlerFunc) IRoutes
      GET(string, ...HandlerFunc) IRoutes
      POST(string, ...HandlerFunc) IRoutes
      DELETE(string, ...HandlerFunc) IRoutes
      PATCH(string, ...HandlerFunc) IRoutes
      PUT(string, ...HandlerFunc) IRoutes
      OPTIONS(string, ...HandlerFunc) IRoutes
      HEAD(string, ...HandlerFunc) IRoutes

      StaticFile(string, string) IRoutes
      Static(string, string) IRoutes
      StaticFS(string, http.FileSystem) IRoutes
  }
  #+END_SRC
*** middleware的编写与使用
**** 中间件
+ 在web应用服务中，完整的一个业务处理在技术上包含客户端操作、服务器端处理、返回处理结果给客户端三个步骤
+ 在实际的业务开发和处理中，会有根据负责的业务和需求场景。一个完整的系统可能要包含鉴权认证、权限管理、安全检查、日志记录等多维度的系统支持
+ 鉴权认证、权限管理、安全检查、日志记录等这些保障和支持系统业务属于全系统的业务，和具体的系统业务没有关联，对于系统中的所有业务都适用
+ 在业务开发过程中，为了更好的梳理系统架构，可以将上述描述所涉及的一些通用业务单独抽离并进行开发，然后以插件化的形式进行对接。这种方式既保证了系统功能的完整，同时又有效的将具体业务和系统功能进行解耦，并且，还可以达到灵活配置的目的
+ 这种通用业务独立开发并灵活配置使用的组件，一般称之为"中间件"，因为其位于服务器和实际业务处理程序之间。其含义就是相当于在请求和具体的业务逻辑处理之间增加某些操作，这种以额外添加的方式不会影响编码效率，也不会侵入到框架中
**** Gin的中间件
+ 在gin中，中间件称之为middleware,中间件的类型定义如下所示
  #+BEGIN_SRC go
  // HandlerFunc defines the handler used by gin middleware as return value.
  type HandlerFunc func(*Context)
  #+END_SRC
  HandlerFunc是一个函数类型,接收一个Context参数。用于编写程序处理函数并返回HandleFunc类型，作为中间件的定义
**** 中间件Use用法
+ 使用gin.Default创建了gin引擎engins变量，其中，就使用了中间件
  #+BEGIN_SRC go
  func Default() *Engine {
      debugPrintWARNINGDefault()
      engine := New()
      engine.Use(Logger(), Recovery())
      return engine
  }
  //Log中间件
  func Logger() HandlerFunc {
      return LoggerWithConfig(LoggerConfig{})
  }
  //Recovery中间件
  func Recovery() HandlerFunc {
      return RecoveryWithWriter(DefaultErrorWriter)
  }
  #+END_SRC
+ 在Default函数中，engine调用Use方法设置了Logger中间件和Recovery中间件。Use函数接收一个可变参数，类型为HandlerFunc，恰为中间件的类型。Use方法定义如下
  #+BEGIN_SRC go
  func (engine *Engine) Use(middleware ...HandlerFunc) IRoutes {
      engine.RouterGroup.Use(middleware...)
      engine.rebuild404Handlers()
      engine.rebuild405Handlers()
      return engine
  }
  #+END_SRC
**** 自定义中间件
+ 自己定义实现一个特殊需求的中间件，中间件的类型是函数，有两条标准
  - func函数
  - 返回值类型为HandlerFunc
+ 比如，我们自定义一个自己的中间件。在前面所学的内容中，我们在处理请求时，为了方便代码调试，通常都将请求的一些信息打印出来。有了中间件以后，为了避免代码多次重复编写，使用统一的中间件来完成。定义一个名为RequestInfos的中间件，在该中间件中打印请求的path和method
  #+BEGIN_SRC go
  func RequestInfos() gin.HandlerFunc {
      return func(context *gin.Context) {
          path := context.FullPath()
          method := context.Request.Method
          fmt.Println("请求Path：", path)
          fmt.Println("请求Method：", method)
      }
  }

  func main() {

      engine := gin.Default()
      engine.Use(RequestInfos())

      engine.GET("/query", func(context *gin.Context) {
          context.JSON(200, map[string]interface{}{
              "code": 1,
              "msg":  context.FullPath(),
          })
      })
      engine.Run(":9000")
  }

  #+END_SRC
  通过两条fmt.Println打印出了请求的信息，并通过engine.Use使用RequestInfos中间件。
  运行程序，能够得到正确的返回JSON格式的数据
**** context.Next函数
+ 在上文自定义的中间件RequestInfos中，打印了请求了请求的path和method，接着去执行了正常的业务处理函数。如果我们想输出业务处理结果的信息，该如何实现呢。答案是使用context.Next函数
+ context.Next函数可以将中间件代码的执行顺序一分为二，Next函数调用之前的代码在请求处理之前之前，当程序执行到context.Next时，会中断向下执行，转而先去执行具体的业务逻辑，执行完业务逻辑处理函数之后，程序会再次回到context.Next处，继续执行中间件后续的代码。具体用法如下
  #+BEGIN_SRC go
  func main() {
      engine := gin.Default()
      engine.Use(RequestInfos())
      engine.GET("/query", func(context *gin.Context) {
          fmt.Println(" 中间件的使用方法  ")
          context.JSON(404, map[string]interface{}{
              "code": 1,
              "msg":  context.FullPath(),
          })
      })
      engine.Run(":9000")
  }

  func RequestInfos() gin.HandlerFunc {
      return func(context *gin.Context) {
          path := context.FullPath()
          method := context.Request.Method
          fmt.Println("请求Path：", path)
          fmt.Println("请求Method：", method)
          context.Next()
          fmt.Println(context.Writer.Status())
      }
  }
  #+END_SRC
  执行程序，输出结果如下
  #+BEGIN_SRC shell
  请求Path： /query
  请求Method： GET
  中间件的使用方法  
  404
  #+END_SRC
*** Gin框架中使用数据库
+ 在gin中使用编程语言进行连接数据库，在gin中连接和操作mysql与在其他框架中连接操作mysql没有什么区别，分为主要的几个步骤
  - 引入mysql驱动程序：使用import将mysql驱动默认引入
    #+BEGIN_SRC go
    import _ "github.com/go-sql-driver/mysql"
    #+END_SRC
  - 拼接链接字符：在程序中链接mysql，需要按照一定的规则进行用户名，密码等信息的组合
    #+BEGIN_SRC go
    connStr := "root:12345678@tcp(127.0.0.1:3306)/ginsql"
    #+END_SRC
  - 使用sql.Open创建数据库连接
    #+BEGIN_SRC go
    db, err := sql.Open("mysql", connStr)
    if err != nil {
        log.Fatal(err.Error())
        return
    }
    #+END_SRC
+ 操作数据库
  - 创建数据库表
    #+BEGIN_SRC go
      _, err = db.Exec("create table person(" +
    "id int auto_increment primary key," +
    "name varchar(12) not null," +
    "age int default 1" +
    ");")
    if err != nil {
        log.Fatal(err.Error())
        return
    }
    #+END_SRC
  - 向数据库中插入数据
    #+BEGIN_SRC go
      _, err = db.Exec("insert into person(name,age) "+
    "values(?,?);", "Lily", 15)
    if err != nil {
        log.Fatal(err.Error())
        return
    } else {
        fmt.Println("数据插入成功")
    }
    #+END_SRC
  - 查询数据库记录
    #+BEGIN_SRC go
    rows, err := db.Query("select id,name,age from person")
    if err != nil {
        log.Fatal(err.Error())
        return
    }
    scan:
    if rows.Next() {
        //columns, err := rows.Columns()
        //fmt.Println(columns)
        person := new(Person)
        err = rows.Scan(&person.Id, &person.Name, &person.Age)
        if err != nil {
            log.Fatal(err.Error())
            return
        }
        fmt.Println(person.Id, person.Name, person.Age)
        goto scan
    }
    #+END_SRC
