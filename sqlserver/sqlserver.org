* 数据库基础知识
** 数据库概述
+ 数据库是数据存放的地方，有组织、可共享的数据集合。数据库中的的数据按照一定的数据模型组织、描述和存储，具有较小的冗余度、较高的数据独立性和易扩展性，可以为不同的用户共享
+ 数据库内容是通过数据库管理系统(Database Management System DBMS)来管理的，数据库管理系统是指数据库系统中对数据进行管理的软件系统，它是数据库系统的核心组成部分，用户对数据库的一切操作都是通过数据库管理系统完成的
+ 常见的数据库管理系统哟MySQL、SqlServer、Oracle等，通常也俗称为数据库
** 数据库模型
根据具体数据存储需求的不同，数据库可以使用多种类型的数据模型(数据库管理系统中数据的存储结构)
+ 层次模型(Hierarchical Model)
  - 树形结构，由节点和连线组成，其中节点表示实体，连线是实体之间的关系，数据将根据需要分门别类的存储在不同的层次之下
  - 优点是数据结构类似金字塔，不同层次之间的关联性简单直接；缺点是数据纵向发展，横向关系难以建立，数据容易重复出现，造成管理维护不便
+ 网状模型(Network Model)
  - 网状结构
  - 优点是容易反应实体之间的关联、避免数据的重复性；缺点是关联错综复杂，且当数据增多时难以对结构中的关联进行维护
+ 关系模型(Relation Model)
  - 使用的存储结构是多个二维表格
  - 二维表格中，每一行称为记录，用来描述一个对象的信息；每一列称为字段，用来描述对象的一个属性
  - 数据表之间存在相应的关联，这些关联被用来查询相关的数据
  - 优点是结构简单、格式唯一、理论基础严格，且数据表之间是相对独立的，可以在不影响其他数据表的情况下进行增删改查；在进行查询时，可以根据数据表之间的关联性，从多个数据表中抽取相关的信息
** 关系型数据库
*** 概述
+ 数据表中的行称为记录或元组，代表众多具有相同属性的对象之一
  - 数据表中任意两行不能相同，能唯一标识表中不同行的属性或属性组称为主键
+ 数据表中的列称为字段或属性，代表存储对象的共有属性
  - 列的取值范围称为域，同列具有相同的域，不同的列可以有相同的域
*** 术语
**** 键码(Key)
是关系模型中的重要概念，在关系中用来标识行的一列或多列
***** 公共关键字(Common Key)
+ 在关系型数据库中，关系之间的联系是通过相容或相同的属性或属性组来表示
+ 两个关系中具有相容或相同属性或属性组，那么这个属性或属性组被称为这两个关系的公共关键字
***** 候选关键字(Candidate Key)
+ 唯一标识表中的一行又不含多余属性的一个属性集
***** 主关键字(Primary Key)  
+ 被挑选出来作为表行的唯一标识的候选关键字
+ 一个表中只有一个主关键字，通常称为主键
+ 唯一标识一条记录，不能有重复的，不允许为空
+ 主键只能有一个
***** 外关键字(Foreign Key)
+ 如果公共关键字在一个表中是主关键字，那么这个公共关键字被称为另一个关系的外关键字，外关键字表示了两个关系之间的联系，也称作外键
+ 表的外键是另一表的主键, 外键可以有重复的, 可以是空值
+ 用来和其他表建立联系用的
+ 一个表可以有多个外键
+ 主键与外键的列名称可以不相同，但要求它们的值集相同，即主键所在表中出现的数据一定要和外键所在的表中的值匹配
**** 数据库对象
***** 表(Table)
***** 索引(Index)
***** 视图(View)
***** 图表(Diagram)
***** 默认值(Default)
***** 规则(Rule)
***** 触发器(Trigger)
***** 存储过程(Stored Procedure)
***** 用户(User)
*** 完整性规则
+ 关系模型的完整性规则是对数据的约束
+ 关系模型提供了三类完整性规则
  - 实体完整性规则
  - 参照完整性规则
  - 用户定义的完整性规则
**** 完整性约束
***** 实体完整性
+ 指关系的主属性(主键的组成部分)不能是空值("不知道"或"无意义"的值)，关系模型中以主键作为唯一标识，主键中的属性即主属性不能取空值
***** 空值(null)
+ 空值就是指不知道或不能使用的值，与数值零和空字符串的意义都不一样
***** 参照完整性
+ 外键的每个值必须在关系中主键的值中找到，或者它是空值
***** 用户定义的完整性
+ 是针对某一具体的实际数据库的约束条件
*** 范式理论
一般数据库满足第三范式即可
**** 第一范式
+ 第一范式是第二、第三范式的基础
+ 每个属性只能包含一个值
+ 关系中的每个数组一定不能相同
+ 所谓第一范式是指表中的每一列都是不可分割的基本数据项
+ 在任何一个关系型数据库管理系统中，任何一条关系至少都应该符合第一范式，否则不能称为关系型数据库管理系统
**** 第二范式
+ 满足第一范式的基础上，表中的任何一个非主键字段的数值都依赖于该表的主键字段
**** 第三范式
+ 满足第一、第二范式的基础上，表中的任何两个非主键字段的数值之间不存在函数依赖关系
*** E-R模型(实体-关系数据模型)
**** 实体模型
+ 
**** 关系模型
+ 一对一关联
+ 一对多关联
+ 多对多关联
* 配置SQL Server 2008
** 验证安装
+ SQL Server 配置管理器
  - 查看相关服务的运行状态
** 注册服务器
- 注册服务器是为SQL Server客户机/服务器系统确定一台数据库所在的机器，该机器作为服务器，可以为客户端的各种请求提供服务
- 可以使用Microsoft SQL Server Management Studio工具把许多相关的服务器集中在一个服务器组中，方便对多服务器环境的管理操作，服务器组是多台服务器的逻辑集合
  - 查看->已注册的服务器->数据库引擎->本地服务器组
** 配置服务器
+ 配置服务器主要是针对安装后的SQL Server2008实例进行
+ 可以使用Microsoft SQL Server Management Studio、sp_configuret系统存储过程、SET语句等方式设置服务器选项
*** 使用Microsoft SQL Server Management Studio设置
+ 在对象资源管理器中选中服务器图表右键属性进行设置
* 安全机制
** 概述
+ SQL Server 2008中，数据库中的所有对象都是位于架构内的，每一个架构的所有者是角色，而不是独立的用户，它允许多用户管理数据库对象
+ 使用安全主体和安全对象管理安全，一个请求服务器、数据库或架构资源的实体称为安全主体，每个安全主体都有唯一的安全标识符
+ 安全主体在3个级别上管理：windows、SQL Server和数据库
+ 安全主体的级别决定了安全主体的影响范围
** 系统登录
*** 登录账户种类
**** 系统管理员组
+ 管理员组在数据库服务器上属于本地组，这个组的成员包括本地管理员用户账户和任何设置为管理员的本地系统其它用户，此组默认授予sysadmin服务器角色
**** 管理员用户账户
**** sa登录
+ sa是SQL Server系统管理员的账户，此账户为兼容性保留账户，sa默认授予sysadmin服务器角色
**** Network Server和SYSTEM登录
+ Network Server和SYSTEM是SQL Server服务器上内置的本地账户，是否创建这些账户的服务器登录，依赖于服务器的配置
*** 创建SQL Server登录
系统内置的这些账户通常都有特殊用途，不分配给普通用户使用，而是创建一些适用于用户权限的账户
+ 在SQL Server Management Studio->服务器->安全性
+ 右键登录名->新建登录名
+ 常规选项卡：设置登录名、SQL Server 身份认证的密码、默认数据库
+ 用户映射选项卡：勾选指定的默认数据库
*** 创建Windows账户登录
** 权限
*** 概述
+ 在SQL Server数据库里的每一个数据库对象都由一个该数据库的用户所拥有，拥有者以数据库赋予的ID作为标识
+ 不同的分类方式可以把权限分成不同的类型
  - 预定义和自定义权限
    1. 预定义权限是不必通过授权即拥有的权限，如预定义服务器和数据库角色，对象的所有者也拥有该对象的所有权限及该对象所包含的对象的所有权限
    2. 自定义权限是指那些需要经过授权或继承才能得到的权限，大多数安全主体都需要经过授权才能获得对安全对象的使用权限
  - 所有对象和特殊对象的权限
    1. 所有对象的权限是针对SQL Server中所有对象具备的权限，如CONTROL权限
    2. 特殊对象的权限是不同对象所具有特有权限，如数据库、表、视图、存储过程等都拥有各自特定的操作权限
*** 权限类型
**** 对象权限
**** 语句权限
**** 隐式权限
*** 设置权限
用户和角色的权限是以记录的形式存储在各个数据库的sysprotects系统表中，权限分为3中状态：授予(GRANT)、拒绝(DENY)、撤销(REVOKE)
**** 授予权限
+ 使用GRANT语句进行授权
  GRANT
  {ALL | statement[,...n]}
  TO security_account[,...n]
+ ALL: 表示授予所有可以应用的权限，只有固定的服务器角色成员sysadmin可以使用ALL关键字；而在授予对象权限时，固定服务器角色成员sysadmin、固定数据库角色成员db_owner和数据库对象拥有者都可以使用ALL关键字
+ statement: 表示可以授权的命令，如CREATE DATABASE
+ security_account: 表示被授予权限的用户账户
+ 权限只能授予本数据库的用户，如果将权限授予public角色，则数据库里的所有用户将默认获得了该项权限
+ 例如：
  USE test
  GO
  GRANT SELECT,UPDATE,DELETE
  ON 学生信息
  TO zpbird
  GO
**** 撤销权限 
+ 使用REVOKE语句撤销权限可以停止此前的授予或拒绝操作，撤销类似于拒绝，但撤销是删除已授予的权限，并不妨碍用户从更高级别继承已授予的权限
+ 语法：
  REVOKE {ALL | statement[,...n]}
  FROM security_account[,...n]
+ 例如：
  USE test
  GO
  REVOKE SELECT,UPDATE,DELETE
  ON OBJECT::学生信息
  FROM zpbird
**** 拒绝权限
+ 在授予了用户对象权限后，可以在不撤销用户访问权的情况下，拒绝用户访问数据库对象
+ 语法：
  DENY {ALL | statement[,...n]}
  TO security_account[,...n]
** 数据库用户
*** 概述
+ 数据库用户是数据库级的主体，是登录名在数据库中的映射，是在数据库中执行操作的活动的行动者
+ 数据库用户不能直接拥有表、视图等数据库对象，而是通过架构拥有这些对象
*** 数据库用户
+ 使用数据库用户账户可以限制访问数据库的范围，默认的数据库用户有dbo用户、guest用户、sys用户等
+ dbo用户
  - 数据库所有者或dbo用户是一个特殊类型的数据库用户
  - 创建数据库的用户是数据库的所有者
  - dbo被隐式授予对数据库的所有权限，并且能将这些权限授予其他用户
  - sysadmin服务器角色的成员被自动映射为特殊用户dbo，以sysadmin角色登录能执行dbo的所有任务
+ guest用户
  - 默认情况下，guest用户存在于model数据库中，且授予guest的权限，由于model是创建所有数据库的模板，这意味着所有新的数据库将包括guest账户，授予guest权限
  - 除了master和tempdb数据库外的所有数据库都能添加删除guest，guest账户在master和tempdb数据库中有被限制的许可和权限
  - guest用户是公共服务器角色的一个成员，并继承这个角色的权限
  - 任何人以guest访问数据库前，guest必须存在于数据库中
  - guest用户仅用于用账户具有访问SQL Server的权限，但不能通过这个用户账户访问数据库
+ sys和INFORMATION_SCHEMA用户
  - 所有系统对象都包含于sys或INFOMATION_SCHEMA的架构中，这是创建在每一个数据库中的两个特殊架构，但是它们仅在master数据库中可见
  - 与这两个特殊架构相关的视图提供在数据库里所有对象的元数据的内部系统视图，sys和INFORMATION_SCHEMA用户用于引用这些对象
*** 创建数据库用户
+ 创建数据库用户可以分为两个过程
  - 创建数据库用户使用的SQL Server登录名
  - 为数据库创建用户，指定到创建的登录名
+ 添加数据库用户也可以使用系统存储过程sp_grantdbaccess来实现
  sp_grantdbaccess [@loginname=]'login'[,[@name_in_db=]'name_in_db']
  例如：
  EXEC SP_ADDLOGIN 'Suna_pro','atsuna','教务管理系统'
  GO
  USE 教务管理系统
  GO
  EXEC SP_GRANTDBACCESS Suna_pro
** 管理角色
+ SQL Server使用角色集中管理数据库或服务的权限，有两种类型的角色：服务器角色和数据库角色
*** 服务器角色
+ 服务器角色具有授予服务器管理的能力，用户创建了一个角色成员的登录名，用户用这个登录能执行这个角色许可的任何任务,例如，sysadmin角色的成员在SQL Server中有最高级别的权限，能执行任何类型的任务
+ 服务器角色(级别从低到高)
  - bulkadmin
    1. 可以运行BULK INSERT语句，允许从文本文件中将数据导入到数据库，为需要执行大容量插入到数据库的域账户而设计
    2. ADMINISTER BULK OPERATIONS
  - dbcreator
    1. 可以创建、更改、删除和还原任何数据库
    2. 这不仅是适合助理DBA的角色，也可能是适合开发人员的角色
    3. CREATE DATABASE
  - diskadmin
    1. 用于管理磁盘文件，如镜像数据库和添加备份设备，适合助理DBA
    2. ALTER RESOURCES
  - processadmin
    1. SQL Server能够多任务化，可以通过执行多个进程做多个事件，如生成一个进程用于向高速缓存写数据，同时生成另一个进程用于从高速缓存中读取数据
    2. 这个角色的成员可以结束(删除)进程
    3. ALTER SERVER STATE,ALTER ANY CONNECTION
  - secutityadmin
    1. 可以管理登录名及其属性，可以授权、拒绝和撤销服务器级、数据库级权限
    2. 可以重置登录名的密码
    3. ALTER ANY LOGIN
  - serveradmin
    1. 可以更改服务器范围的配置选项和关闭服务器
    2. ALTER SETTING, SHUTDOWN, CREATE ENDPOINT, ALTER SERVER STATE, ALTER ANY ENDPOINT, ALTER RESOURCE
  - setupadmin
    1. 可以管理链接服务器和控制启动的存储过程，能增加、删除和配置链接服务器，并能控制启动过程
    2. ALTER ANY LINKED SERVER
  - sysadmin
    1. 可以执行任何任务
    2. CONTROL SERVER
*** 数据库角色
+ SQL Server在每一个数据库中都预定义了数据库角色，也就是说每一个数据库都有一组自己的角色
+ SQL Server提供了3种类型的数据库角色
  - 标准角色(用户定义)
  - 应用程序角色(用户定义)
  - 预定义数据库角色(SQL Server内置固定)
+ 标准角色
  - 允许用户使用唯一的权限和特权来创建角色
  - 可以使用标准角色对用户进行逻辑分组，然后指派单一的权限到角色，适用于单独的指派权限到每一个用户
  - 例如，可以创建一个Users的角色，只允许用户选择(SELECT)、插入(INSERT)和更新(UPDATE)数据库中的指定表，但不允许执行任何其他任务
+ 应用程序角色
  - 允许用户为特定的应用程序创建密码保护的角色
  - 例如，用户能通过名为APIbook_Management的基于Web的应用程序连接，此应用程序将激活角色，然后用户将获得角色的权限和特权
  - 标准的数据库角色或其他的角色不能指派到应用程序角色，而是当应用程序连接数据库的时候激活应用程序角色
+ 预定义数据库角色
  - 这些角色时内置的，他们不能被更改权限，使用预定义角色指派数据库管理权限，可以指派单一的登录到多个角色
  - 常用预定义数据库角色
    1. db_owner
       可以做其他角色能做的所有事情，可以做一些管理性操作
    2. db_accessadmin
       可以通过添加或删除用户来指定谁可以访问数据库
    3. db_securityadmin
       可以修改角色成员身份和管理权限
    4. db_ddladmin
       可以在数据库中运行任何数据库定义语言DDL命令，允许创建、修改或删除数据库对象，而不必浏览里面的数据
    5. db_backupoperator
       可以备份该数据库
    6. db_datareader
       可以读取所有用户表中的所有数据
    7. db_datawriter
       可以在所有用户表中添加、删除或更改数据
    8. db_denydatareader
       不能读取数据库中用户表中的任何数据，但可以执行架构修改，如在表中添加列
    9. db_denydatawriter
       不能添加、修改或删除数据库内用户表中的任何数据
    10. public
        每个数据库用户都属于public数据库角色，当尚未对某个用户授予或拒绝对安全对象的特定权限时，则该用户将继承授予该安全对象的public角色权限，这个数据库角色不能被删除
*** 管理服务器角色
**** 将登陆指派到角色
+ 服务器->安全性->登录名->登录名属性
**** 指派角色到多个登陆名
+ 服务器->安全性->服务器角色->添加
*** 管理数据库角色
**** 将数据库用户指派到数据库角色
+ 服务器->数据库->安全性->角色->数据库角色->属性->添加
*** 标准数据库角色
+ 由于预定义的数据库角色有一组不能更改的权限，有时候不能满足我们的需求，这时，可以对为特定数据库创建的角色设置权限
+ 例如，一个数据库有3种用户：需要查看数据的普通用户；需要能够修改数据的管理员；需要能够修改数据库对象的开发人员，在这种情况想，可以创建3个角色以处理这些用户类型
+ 创建数据库角色时 ，先给角色指派权限，然后将用户指派给角色，这不同于数据库的固定角色，固定角色不需要指派权限，只需要分配用户即可
*** 应用程序角色
+ 应用程序角色是一个数据库主体，它使应用程序能够用其自身的、类似用户的特权来运行，使用应用程序角色可以只允许通过特定应用程序连接的用户访问特定数据
+ 与数据库角色不同的是，应用程序角色默认情况下不包含任何成员，而且是非活动的
+ 应用程序角色使用两种身份验证模式，可以使用sp_setapprole来激活，并且需要密码
+ 应用程序角色是数据库级别的主体，它们只能通过数据库中授予guset用户账户的权限来访问这些数据库，任何禁用guest用户账户的数据库对其他数据库中的应用程序角色都是不可访问的
+ 利用应用程序角色，用户仅使用它们的SQL Server登录和数据库账户将无法访问数据库，它们必须使用适当的应用程序
* 数据库管理
** 数据库文件和日志
+ SQL Server2008是以页为最小物理空间单位来存储的，每一个页的大小是8KB，数据库表中的每一行数据都不能跨页存储，每8个连接的页组成一个区，则一个区的大小为64KB，对于1MB的数据库来说就有16个区
+ 每个数据库都有一个与它相关联的事务日志，事务日志是对数据库的修改的历史记录,SQL Server用它来确保数据库的完整性，对数据库的所有更改首先写到事务日志，然后应用到数据库，如果数据库更新成功，事务完成并记录为成功；如果数据库更新失败，SQL Server使用事务软件还原数据库到初始化状态(称为回滚事务)
+ 数据库和事务日志包含在独立的数据库文件中，这意味着每一个数据库至少需要两个关联的存储文件：一个数据文件和一个日志文件，也可以有辅助数据文件
*** 主数据文件
+ 主数据文件包含数据库的启动信息，并指向数据库中的其他文件，用户数据和对象可以存储在此文件中，也可以存储在辅助数据文件中
+ 每个数据库只能有一个主数据文件，默认文件扩展名是.mdf
*** 辅助数据文件
+ 辅助数据文件是可选的，由用户定义并存储用户数据，通过将每个文件放在不同的磁盘上，辅助文件可用于将数据分散到多个磁盘上
+ 如果数据库超过了单个windows文件的最大限制，可以使用辅助数据文件，这样数据库就能继续增长
+ 辅助数据文件的默认扩展名是.ndf
*** 事务日志文件 
+ 事务日志文件保存用于恢复数据库的日志信息，每个数据库必须至少有一个日志文件，默认扩展名为.ldf
*** 文件组
+ 为了便于分配和管理，可以将数据文件集合起来，放到文件组中，文件组是针对数据文件而创建的，是数据库中数据文件的集合
+ 通过创建文件组，可以使不同的数据对象属于不同的文件组，利用文件组可以优化数据存储，并可以将不同的数据库对象存储在不同的文件组以提高IO读写的性能
+ 例如，可以分别在三个磁盘上创建三个文件：sys_School_data1.ndf、sys_School_data2.ndf、sys_School_data3.ndf，将它们分配给文件组School_FH，这样可以明确的在文件组School_FG上创建一个表，对表中数据的查询将分散到三个磁盘上，从而提高了性能
+ 需要遵守的规则
  - 主要数据文件必须存储于主文件组中
  - 与系统相关的数据库对象必须存储于主文件组中
  - 一个数据文件只能存在于一个文件组，而不能同时存在于多个文件组中
  - 数据库的数据信息和日志信息不能放在同一个文件组中，必须是分开存放的
  - 日志文件不能存放在任何文件组中
** 数据库管理基础
*** 系统数据库
+ 系统数据库是指随安装程序一起安装，用于协助SQL Server系统共同完成管理操作的数据库，它们是SQL Server运行的基础
+ SQL Server的设计是可以在必要时自动扩展数据库，master、model、tempdb、msdb和其他关键的数据库将不会在正常情况下缺少空间(最大2TB)
**** master数据库
+ master数据库是SQL Server最重要的数据库，是SQL Server的核心，如果该数据库损坏，SQL Server将无法正常工作
+ master数据库包含如下重要信息
  1. 所有的登录名或用户ID所属的角色
  2. 所有的系统配置设置(数据排序信息、安全实现、默认语言...)
  3. 服务器中的数据库的名称及相关信息
  4. 数据库的位置
  5. SQL Server如何初始化
+ 定期备份master数据库非常重要
**** model数据库
+ 创建数据库时，总是以一套预定义的标准为模型，例如，如果希望所有的数据库都有确定的初始大小，或都有特定的信息集，那么可以把这些信息存放在model数据库中，以model数据库作为其他数据库的模板数据库，如果想要使所有的数据库都有一个特定的表，可以把该表存放在model数据库里
+ model数据库是tempdb数据库的基础，对model数据库的任何改动都将反应到tempdb数据库中，在决定对model数据库有所改动时，必须预先考虑好并多加小心
**** tempdb数据库
+ tempdb数据库是一个临时性的数据库，存在于SQL Server会话期间，一旦SQL Server关闭，tempdb数据库将丢失，当SQL Server重新启动时，将重建全新的、空的tempdb数据库以供使用
+ tempdb数据库用作系统的临时存储空间，其主要作用是存储用户建立的临时表和临时存储过程；存储用户说明的全局变量值；为数据排序创建临时表；存储用户利用游标说明所筛选出来的数据
**** msdb数据库
+ msdb数据库给SQL Server代理提供必要的信息来运行作业，是SQL Server另一个十分重要的数据库，既然有了tempdb和model数据库，就不应该直接调整msdb数据库，也的确无必要，许多进程使用msdb数据库，例如，当创建备份或执行还原时，将用msdb数据库存储有关这些任务的信息
+ 不能在msdb数据库中执行下列操作
  1. 更改排序规则，默认为服务器排序规则
  2. 删除数据库
  3. 从数据库中删除guest用户
  4. 删除主文件组、主数据文件或日志文件
  5. 重命名数据库或主文件组
  6. 将数据库设置为OFFLINE
  7. 将主文件组设置为READ_ONLY
*** 常用数据库对象
**** 表
+ 表是数据库中实际存储数据的对象，由于数据库中的其他所有对象都依赖于表，因此可以将表理解为数据库的基本组件
+ 表中存储的数据又可以分为字段和记录
+ 字段是表中的纵向元素，包含同一类型的信息，例如学生编号、姓名等，字段组成记录
+ 记录是表中的横向元素，包含有单个表内所有字段所存储的信息
**** 视图
+ 视图与表非常相似，也是由字段和记录组成，与表不同的是，视图不包含任何数据，它总是基于表，用来提供一种浏览数据的不同方式
+ 视图的特点是，其本身不存储实际数据，因此可以是连接多张数据表的虚表，还可以是使用WHERE子句限制返回行的数据查询结果，并且它是专用的，比数据表更直接面向用户
**** 存储过程和触发器
+ 存储过程和触发器是两个特殊的数据库对象，在SQL Server中存储过程独立于表，而触发器则与表紧密结合
+ 用户可以使用存储过程来完善应用程序，使应用程序的运行更加有效率；可以使用触发器来实现复杂的业务规则，更加有效地实施数据完整性
**** 用户和角色
+ 用户是对数据库有存取权限的使用者
+ 角色是指一组数据库用户的集合，用户如果加入到某一角色，则将具有该角色的所有权限
**** 其他数据库对象
+ 索引
  - 索引是提供无需扫描整张表就能实现对数据快速访问的途径，使用索引可以快速访问数据库表中的特定信息
+ 约束
  - 约束是SQL Server实施数据一致性和完整性的方法，是数据库服务器强制的业务逻辑关系
+ 规则
  - 用来限制表字段的数据范围，例如限制性别字段只能是男或女
+ 类型
  - 除了系统给定的数据类型外，用户还可以根据自己的需求在系统类型的基础定义自己的数据类型
+ 函数
  - 除了系统提供的函数外，用户可以根据自己的需要定义符合自己要求的函数
*** 数据库快照
+ 数据库快照提供了一种数据库恢复手段，可以在源数据库损坏后，还原数据库到数据库快照前的状态
+ 不支持在SQL Server Management Studio中创建数据库快照，唯一的方式是使用Transact-SQL语句
+ 快照非常适用于存档用户仍需要访问的历史数据
+ 快照在用来产生报表时可以提高性能
+ 使用快照对源数据库的限制
  - 不能对数据库进行删除、分离或还原
  - 源数据库的性能受到影响
  - 不能从源数据库或任何快照中删除文件
  - 源数据库必须处于在线状态，除非该数据库在数据库镜像会话中是镜像数据库
** 创建数据库
*** 使用管理工具
**** 常规
+ 数据库名称、所有者、使用全文索引
+ 数据库文件
  - 逻辑名称
    指定该文件的文件名
  - 文件类型
    用于区别当前文件是数据文件还是日志文件
  - 文件组
    显示当前数据库文件所属的文件组，一个数据库文件只能存在于一个文件组里
  - 路径
    创建大型数据库时，尽量把主数据文件和事务日志文件设置在不同的路径下，可以提高读取效率
**** 选项
**** 文件组
*** 使用语句 
**** CREATE DATABASE语句
+ 最简单的形式，除了数据库名称，其他设置都使用系统默认值
  CREATE DATABASE test
+ 完整格式
  CREATE DATABSE test
  [
  ON [PRIMARY]
  [( NAME = logical_name,
     FILENAME = 'path'
     [, SIZE = database_size]
     [, MAXSIZE = database_maxsize]
     [, FILEGROWTH = growth_increment])
  [, FILEGROUP filegroup_name
  [( NAME = datafile_name
     FILENAME = 'path'
     [, SIZE = datafile_size]
     [, MAXSIZE = datafile_maxsize]
     [, FILEGROWTH = growth_increment])]]   
  ]
  [
  LOG ON
  [( NAME = logfile_name
     FILENAME = 'path'
     [, SIZE = database_size]
     [, MAXSIZE = database_maxsize]
     [, FILEGROWTH = growth_increment])]
  ]
  ]
**** 语法说明
+ ON 
  用来创建数据文件
+ PRIMARY
  表示创建的是主数据文件
+ FILEGROUP
  用来创建次文件组，其中还可以创建次数据文件
+ LOG ON
  用来创建事务日志文件
+ NAME 
  所创建文件的文件名称
+ FILENAME
  支出了各文件存储的路径
+ SIZE
  定义初始化大小
+ MAXSIZE
  指定文件的最大容量
+ FILEGROWTH
  指定文件增长值
+ []表示可以省略的选项或参数，[1,...n]表示同样的选项可以重复1到n遍
+ <>如果某项的内容太多需要额外说明，使用<>括起来，如语法中的<filespec>和<filegroup>,而该项的真正语法在双冒号加等号"::="后面定义
+ {}通常与竖杠符合"|"连用，表示{}中的信息或参数必选其中之一，不可省略
+ 如果数据库的数据文件或日志文件数量多于1个，则文件之间用逗号分隔，当某个数据库有两个或以上的数据文件，需要指定哪一个是主数据文件，默认情况下第一个数据文件是主数据文件，也可以使用PRIMARY关键字来指定主数据文件
**** 举例
CREATE DATABASE 教务管理系统
ON
(
  NAME = 教务管理系统_DATA,
  FILENAME = ' E:\data\教务管理系统_DATA.mdf',
  SIZE = 5MB,
  MAXSIZE = 20MB,
  FILEGROWTH = 5%
)
LOG ON
(
  NAME = 教务管理系统_LOG,
  FILENAME = ' E:\data\教务管理系统_LOG.ldf',
  SIZE = 2MB,
  MAXSIZE = 10MB,
  FILEGROWTH = 1MB
)
** 数据库操作
*** 修改数据库
**** 修改数据库名称
+ ALTER DATABASE
  - 该语句修改数据库名称时只更改了数据库的逻辑名称，对该数据库的数据文件和日志文件没有任何影响
  - ALTER DATABASE databaseName MODIFY NAME = newdatabaseName
+ sp_renamedb存储过程
  - 执行这个系统存储过程也可以修改数据库名称
  - EXEC sp_dboption '教务管理系统','SINGLE',True
    EXEC sp_renamedb '教务管理系统',' School_MIS '
    EXEC SP_DBOPTION ' School_MIS ','SINGLE',False
+ 使用管理工具
**** 修改数据库大小
+ 修改数据库大小实质上是修改数据文件和日志文件的长度，或增加/删除文件
+ 如果数据库中的数据量不断增加，就需要扩大数据库的尺寸，有3种方式
  - 设置数据库为自动增长方式，在创建数据库时设置
  - 直接修改数据库数据文件或日志文件的大小
  - 在数据库中增加新的次要数据文件或日志文件
+ 使用ALTER DATABASE中的ADD FILE增加次数据文件
  ALTER DATABASE 教务管理系统
  ADD FILE
  (
    NAME = 教务管理系统_DATA1,
    FILENAME = 'E:\data\教务管理系统_DATA1.mdf'，
    SIZE = 3MB,
    MAXSIZE = 10MB,
    FILEGROWTH = 10%
  )
**** 删除数据库
+ 使用图形管理器
+ SQL语句
  DROOP DATABASE database_name [,...n]
  - 使用DROP DATABSE删除数据库不会出现确认信息，使用时要谨慎
  - 不能删除系统数据库，否则SQL Server服务器将无法使用
*** 查看数据库状态
**** 数据库状态
+ ONLINE
  在线或联机状态，可以执行对数据库的访问
+ OFFLINE
  离线或脱机状态，数据库不能正常使用，可以人工设置，用户可以执行处于这种状态的数据库文件的移动等处理
+ RESTORING
  还原状态，正在还原主文件组的一个或多个文件，这时数据库不能使用
+ RECOVERING
  恢复状态，正在恢复数据库，这是一个临时性状态，如果恢复成功，则数据库自动处于在线状态，如果恢复失败，则数据库处于不能正常使用的可疑状态
+ RECOVERY PENDING
  恢复未完成状态，恢复过程中缺少资源造成的问题状态，数据库不可以使用，必须执行其他操作
+ SUSPECT
  可疑状态，主文件可疑或可能被破坏，数据库不能使用，必须执行其他操作来解决这种问题
+ EMERGENCY
  紧急状态，可以人工设置数据库为该状态，这时数据库处于单用户模式和只读状态，只能由sysadmin固定服务器角色成员访问，主要用于对数据库的故障排除
**** 数据库文件状态
+ 与数据库相同，SQL Server的数据库文件也有状态，并且该文件始终处于一个特定的、独立于数据库的状态
+ 与数据库相比，文件没有RECOVERING和EMERGENCY状态，而新增了一个DEFUNCT状态，用来表示当文件不处于在线时删除
**** 查看状态
+ 使用函数
+ 使用图形工具
*** 其他数据库操作
**** 分离数据库
+ 分离数据库是指将数据库从SQL Server实例上删除，但该数据库的文件和事务日志文件仍然保持不变，这时可以将该数据库附加到其他任何SQL Server实例上
+ 如果要分离的数据库出现下列任何情况之一，都将不能分离
  - 已复制并发布的数据库，如果进行复制，则数据库必须是未发布的，如果要分离数据库，必须先通过执行sp_replicationdboption存储过程禁用发布后再分离
  - 数据库中存在数据库快照，此时，必须先删除所有的数据库快照，才能分离数据库
  - 数据库处于未知状态，无法分离可疑和未知状态的数据库，必须将数据库设置为紧急模式，才能对其进行分离操作
+ 使用sp_detach_db存储过程来执行数据库分离操作
  EXEC sp_detach_db 教务管理系统
+ 使用GUI管理工具
  - [数据库]-右击数据库名称节点，[任务]-[分离]
  - 默认情况下，分离数据库将在分离数据库时保留过期的优化统计信息，若要更新现有的优化统计信息，可启用[更新统计信息]复选框
  - 在[状态]列中如果是"未就绪"，则[消息]列将显示有关数据库的超链接信息，当数据库涉及复制时，[消息]列将显示"Database replicated"
  - 数据库有一个或多个活动连接时,[消息]列将显示<活动连接数>活动连接，在可以分离数据列之前，必须启用[删除连接]复选框来断开与所有活动连接的连接
  - 分离数据库准备就绪后，点击[确定]按钮
**** 附加数据库
+ 附加数据库时，所有数据库文件(.mdf和.ndf文件)都必须可用，如果任何数据文件的路径与创建数据库或上次附加数据库时的路径不同，则必须指定文件的当前路径，在附加数据库的过程中，如果没有日志文件，系统将创建一个新的日志文件
+ 命令行方式
  CREATE DATABASE 教务管理系统
  ON
  (
    FILENAME = ' E:\Applications\School\data\教务管理系统_DAT.mdf'
  )
  LOG ON
  (
    FILENAME = ' E:\Applications\School\data\教务管理系统_LOG.ldf'
  )
  FOR ATTACH
+ GUI管理工具
  - [数据库]节点-[附加]
**** 收缩数据库
+ 数据库中的每个文件都可以通过删除未使用的页的方法减小，尽管数据库引擎会有效的重新使用空间，但某个文件多次出现无须原来大小的情况后，收缩文件就变得很有必要
+ 数据和事务日志文件都可以减小，可以成组或单独的手动收缩数据库文件，也可以设置数据库，使其按照指定的间隔自动收缩
+ SQL Server提供以下几种收缩数据库的方式
  - 自动数据库收缩
    1. 将"AUTO_SHRINK"选项设置为"ON"后，数据库引擎将自动收缩有可用空间的数据库，此选项可以使用ALTER DATABASE语句来进行设置
    2. 默认情况下，此选项设置为"OFF"
  - 手动数据库收缩
    这种方式下，要求使用DBCC SHRINKDATABASE语句或者DBCC SHRINKFILE语句来手动收缩数据库或数据库中的文件
  - 收缩事务日志
    1. 事务日志文件可以在固定的范围内收缩，日志中虚拟日志文件的大小决定着可以收缩的大小，因此不能讲日志文件收缩到比虚拟日志文件还小
    2. 如果希望将事务日志文件减到最小，解决办法是创建一个较小的事务日志，并让其自动增长，而不要一次创建一个大型的事务日志文件
**** 复制和移动数据库
+ 使用SQL Server的[复制数据库向导]工具可以复制或移动数据库，创建数据库的副本，在SQL Server不同的实例间复制和移动数据库，以及将SQL Server2005的数据库升级到2008，所有这些操作除了model、msdb、master系统数据库外都适用
+ SQL Server使用两种技术来进行复制和移动操作
  - 分离和附加
    1. 此方法是复制数据库的最快方式，但是需要源数据库脱机，以便能被分离/移动，当复制/移动操作完成后，数据库重新附加
    2. 要求用户必须是源和目标服务器sysadmin固定服务器角色的成员，同样，在开始复制操作前，用户应该把数据库设置为单用户模式，以确保没有活动的会话，否则[复制数据库向导]将不会执行复制/移动操作
  - SQL管理对象
    1. 此方法稍慢，但不要求源数据库脱机，要求用户必须是源数据库的所有者并且必须有CREATE DATABASE的权限，或在目标服务器上是固定dbcreator服务器角色的成员，在开始复制/移动操作以前不用把数据库设置为单用户模式，而且由于数据库没有脱机，在操作期间也允许活动的连接
    2. 如果源和目标服务器都是2005服务器，复制/移动操作保存全文目录，但如果源服务器是2000，则在复制/移动操作完成以后，全文目录必须重新生成并且完全的再填充
  - 操作步骤
    1. [教务管理系统]-[任务]-[复制数据库]-[复制数据库向导]
**** 优化数据库
+ 数据库是可供多个用户共享的信息资源，当多个用户并发存取数据库时，就会产生多个事务同时存取同一数据的情况，如果对并发操作不加以控制就可能出现存取不正确数据的情况，并将破坏数据库的一致性
+ 在设计数据库时，必须要以提高数据库性能及稳定性为前提，提高数据库性能就是提高数据库的运行速度及执行能力，提高数据库的稳定性就是如果数据库中某个文件或某些数据损坏或丢失，则数据库依然能够正常使用并顺序的执行任务
+ 2008中主要从3个方面对数据库进行优化
  1. 数据文件和事务日志文件的放置
     在创建数据库时，为了提高使用数据库及操纵数据的效率应尽量将数据文件分散在不同的物理磁盘上，同时尽量把数据文件和事务日志也分散在不同的物理磁盘上
  2. 文件组的使用
     + 文件组是SQL Server中一个或多个文件的命名集合，它构成分配或用于数据库管理的单个单元，使用文件组可以提高系统的性能，有两个明细的优点，第一可以平衡多个磁盘上的数据访问负荷；第二，可以使用并行线程来提高数据访问的效率
     + 可以通过备份单个文件或文件组，来防止数据库意外的产生，当数据库出现错误时，恢复备份的文件或文件组就可以使数据库能够重新使用，从而简化数据库的维护工作，对于大容量的数据库来说，备份文件或文件组是一个有效的备份策略，而且可以将表和索引分布到不同的文件组中，对于那些常用的表来说，可以提高查询语句的效率
     + 使用文件组时需要考虑的因素
       - 监控系统的性能，理解数据库的结构、文件分布状况、表和索引信息、使用的查询语句类型等
       - 如果使用用户定义的文件组，最好把默认的文件组改成用户定义的文件组，这样可以防止用户数据在PRIMARY文件组上的增长
       - 文件组只能提高性能，不能提高稳定性，如果文件组中的某个数据文件损坏，则整个文件组中的数据都将无法使用
  3. RAID技术的使用
     + RAID1可以用于日志数据
     + RAID5既适用于大数据量的操作，也适用于各种事务处理
**** 管理数据库快照
* 管理表 
** 表概述
*** 概念
+ 表是用来存储和操作数据的逻辑结构，是数据库中最重要、最基本、最核心的对象，是关系模型中表示实体的方式，也是用来组织和存储数据，具有行列结构的数据库对象
+ 列主要描述数据的属性，而行是组织数据的单位，每一行都是一条独立的数据记录，而每一列表示记录中相同的一个元素
+ 一般来讲表具有如下特点：代表实体、由行和列组成、列名在一个表中是唯一的、行和列的顺序不重要
*** 临时表和系统表
+ 在SQL Server中数据表可以分为4种类型：普通表、分区表、临时表、系统表
+ 临时表
  - 临时表是临时创建的、不能永久保存的表，临时表又可以分为本地临时表和全局临时表
  - 临时表的特征是表名前带有井号"#"，本地临时表为一个#开头；全局临时表以##开头，创建后对任何用户都可见，当所有引用该表的用户断开连接时被删除，所有的用户都可以创建临时表
+ 系统表
  - 系统表与普通表的主要区别在于，系统表存储了有关SQL Server服务器的配置、数据库设置、用户和表对象的描述等系统信息，一般只能有DBA来使用该表
*** 创建表
+ 使用GUI工具
+ CREATE TABLE语句
  - 语法
    CREATE TABLE [ database_name.[ owner ].| owner.] table_name
    (
    { < column_definition > | < table_constraint >
    | column_name AS computed_column_expression
    } [ ,...n ]
    )
    [ ON { filegroup | DEFAULT } ]
    [ TEXTIMAGE_ON { filegroup | DEFAULT } ]
    < column_definition >:: = { column_name data_type }
    [ [ DEFAULT constant_expression ] | [ INDENTITY [ (SEED,INCREMENT ) ] ] ]
    [ < column_constraint > ] [,...]
  - 示例
    USE 教务管理系统
    GO
    CREATE TABLE 学生信息
    (
    学号 varchar(14) NOT NULL,
    姓名 varchar(8) NULL,
    班级编号 varchar(14) NULL,
    性别 varchar(2) NULL,
    年级 int NULL,
    政治面貌 varchar(10) NULL,
    民族 varchar(6) NULL,
    籍贯 varchar(20) NULL,
    学籍 varchar(10) NULL
    )
** 数据类型
*** 精确数字数据类型
**** 整数
+ 整数是最常见的数据类型之一，主要用来存储数字数据，可以直接进行数据运算，而不必使用函数转换
+ 在SQL Server 2008中，整数包括以下四类
  1. bigint
     整数类型中存储量最大的一种，存储在8个字节中，每个字节的长度是8位，共64位
  2. int(Integer)
     存储在4个字节中，共32位，int整数是最常用的数据类型，只有当int表示的数据长度不足时，才考虑使用bigint
  3. smallint
     存储在2个字节中，共16位
  4. tinyint
     可以存储0~255范围之间的所有正整数，存储在1个字节，共8位
+ 在选择整数数据类型时，默认情况下应该考虑使用int数据类型，如果确认将要存储的数据可能非常大或很小，则可以考虑使用bigint或smallint
**** Bit(位类型)
Bit称为位数据类型，其数据有两种取值:0和1，长度为1字节，在输入0以外的其他值时，系统均看做为1，这种数据类型常作为逻辑变量使用，用来表示真、假或是、否
**** money和smallmoney(货币类型)
+ money
  用于存储货币值，存储在money数据类型中的数值以一个正数部分和一个小数部分存储在两个4字节的整形值中，其中前面一个4字节表示货币值的整数部分，后面一个4字节表示货币值的小数部分
+ smallmoney使用两个2字节存储
+ 可以在数字前面加货币符号
+ 小数位最多为4位50.0035，超出时自动四舍五入处理
*** 近似数字数据类型
**** float和real数据类型
+ real
  可以存储正负的十进制数值，最大可以有7位精确位数，占用4个字节的存储空间
+ float
  可以精确到第15位小数，如果不指定float数据类型的长度，占用8个字节的存储空间，利用float来声明变量和表中的列时，可以指定用来存储按科学计数法记录的数据尾数的bit数，如float(n),n的范围是1~53，当n为1~24时，精度是7位，占用4个字节；当n为25~53时，精度为15位，占8个字节存储
+ 在使用中，如果某些列中的数据或变量将参与科学计算，或计算量过大时，建议将这些数据对象设置为float或real数据类型，否则在运算过程中形成较大的误差
**** decimal和numeric数据类型
+ 在SQL Server 2008中，把这两种数据类型作为完全相同的一种数据类型来对待，都是带固定精度和位数的数据类型
+ decimal数据类型的语法
  decimal(p,s)
  - p 表示数字精度，s表示数字的小数位数，p的取值范围是1~38，默认为18；s的取值范围必须是0~p之间的数值，包括0和p
  - decimal(10,2)表示可以存储精度为10，小数位2位的数据，比如7422.32
*** Unicode字符数据类型
**** nchar
其定义形式为nchar(n),n的取值为1~4000
**** nvarchar
+ 其定义形式为nvarchar(n),n的取值为1~4000
+ 可以定义为nvarchar(max)，可以存储数量巨大的变长字符串，且完全兼容所有的SQL Server内置的字符串函数，建议使用nvarchar(max)替代ntext类型
+ ntext
  与text数据类型类似，存储在其中的数据通常是直接能输出到显示设备上的字符，显示设备可以是显示器、窗口或打印机
*** 二进制数据类型
**** binary
用于存储固定长度的二进制数据，形式为binary(n)，数据的存储长度是固定的，即n+4个字节，常用于存储图像等数据
**** varbinary
用于存储可变长度的二进制数据，定义形式为varbinary(n)
**** image
用于存储照片、目录图片或图画，其存储数据的模式与text数据类型相同，通常存储在image字段中的数据不能直接用Insert已经直接输入，可以储存最大2GB的数据，image数据类型列的数据与行的其他部分是分开保存的，行上只保存了一个指针
*** 时间和日期数据类型
**** date
取值范围0001-01-01到9999-12-31
**** time
取值范围00:00:00.0000000到23:59:59.9999999
**** datetimeoffset
**** datetime2
**** datetime
**** smalldatetime
*** 字符串数据类型
使用字符数据类型时，需要在其前后加上英文单引号或双引号
**** char
+ char(n)
+ 利用char数据类型存储数据时每个字符使用一个字节的存储空间，使用固定长度来存储字符，最长可以容纳8000个字符
+ 例如char数据类型定义表列或变量时，应该给定最大长度，使用char数据类型的最大好处是可以精确的计算数据占用的空间
**** varchar
+ varchar(n)
+ 最长存储8000个字符的变长字符型数据，与char数据类型不同的是，varchar随存储在表列中的每一个数据的字符数的不同而变化
**** text
+ 当存储的字符型数据非常庞大，8000字符完全不够时，应该使用text数据类型
*** 其他数据类型
**** sql_variant
+ 用于存储各种数据类型(不包括text、ntext、image、timestamp和sql_variant)的值，极大方便了SQL Server的开发工作
+ 定义为sql_variant的列可以存储int、binary和char值
+ 一般只有在不能准确确定将要存储的数据类型时，才使用这种数据类型
**** timestamp
+ 即时间戳，提供数据库范围内的唯一值，反映数据库中数据修改的相对顺序，timestamp值时二进制数值，表明数据库中的数据修改发生的相对顺序
+ timestamp数据类型与时间和日期无关
**** uniqueidentifier
+ 存储一个16字节长的二进制数据类型，是SQL Server根据计算机网络适配器地址和CPU时钟产生的全局唯一标识符代码
**** xml
+ 可以保存整个XML文档
**** table
+ 用于存储对表或者视图处理后的结果集，这种新的数据类型使得变量可以存储一个表，从而使函数或过程返回查询结果更加方便
**** cursor
+ 是变量或存储过程OUTPUT参数的一种数据类型，这些参数包含对游标的引用，可以为空，但CREATE TABLE语句中的列，不能使用cursor数据类型
*** 创建自己的数据类型
** 列的其他属性
*** NULL与NOT NULL
+ 列的为空性决定表中的行是否可以为该列包含空值，NULL(空，列可以不指定具体的值)意味着此值是未知的或不可用，向表中填充行时不必为该列给出具体值
+ NULL(或空值)不同于零、空白或长度为零的字符串"",NULL的意思是没有输入，出现NULL通常表示值未知或未定义，也没有两个NULL值是相等的，NULL是未知数据的占位符，表示数据库不知道有没有值，也不知道值是什么，
+ NOT NULL(列中必须给出具体的值)则不允许为空值，该列必须输入数据
+ 指定某一列不允许空值(NOT NULL)有助于维护数据的完整性
+ 示例
  USE 教务管理系统
  GO
  CREATE TABLE 课程信息
  (
  课程编号 int NOT NULL,
  课程名称 char(40) NOT NULL,
  课程简称 char(40) NOT NULL,
  班级编号 varchar(14) NOT NULL
  )
*** IDENTITY的应用
+ 使用IDENTITY关键字定义的字段叫做标识字段，一个标识字段是唯一标识表中每条记录的特殊字段，当一个新记录添加到表中时，这个字段就被自动赋给一个新值，默认情况按加1递增
+ IDENTITY列的值理想状态下应该是连续的递增数，但受到起始值、增量、失败这3种操作的影响，都会导致该值不连续
+ 每个表可以有一个且只能有一个标识字段
+ 语法
 IDENTITY(seed,increment)
+ 示例
  USE 教务管理系统
  GO
  CREATE TABLE 学生信息
  (
  学号 varchar(14) IDENTITY(1,1),
  姓名 varchar(8) NULL,
  班级编号 varchar(14) NULL
  )
** 维护数据表
*** 修改表
**** 注意事项
+ 修改表时要先查看该对象所依赖的关系，看它是否和其他对象有依赖关系，如果有，应先解除该对象的依赖关系后再对表进行修改操作，否则将有可能导致其他对象出错
+ 如果该表中已有数据的话，最好不要对该表重新设计，否则有可能出错
**** 使用GUI工具操作
**** 使用SQL语句
+ sp_rename对表重命名
  USE 教务管理系统
  GO
  EXEC sp_rename '学生信息','学生基本信息'
+ DROP TABLE删除表
  DROP TABLE 学生信息
  - 在删除表时，使用CASCADE时除删除表及其数据之外，所有引用该表的视图、约束、例程或触发器也将被删除
  - 删除表时使用RESTRIC，那么只有不存在依赖性时表才被删除
+ DELETE仅删除表中数据，保留表结构
  DELETE 学生信息
*** 修改列属性
+ 使用ALTER TABLE语句可以增加列、删除列，还可以对列的属性进行修改(重新设置列名、数据类型、长度、是否允许空、描述、默认值、精度、小数位数、标识、公式、排序规则等)，还可以设置和取消一个列的主键约束
+ ALTER TABLE语法
  ALTER TABLE table_name ALTER COLUMN column_name new_type_name
+ 示例
  USE 教务管理系统
  GO
  ALTER TABLE 学生信息
  ALTER COLUMN 姓名 varchar(20) NOT NULL
*** 添加/删除表列
**** 删除现有表中的列时具有以下特征的列不能被删除
+ 用于索引
+ 用于CHECK、FOREIGN KEY、UNIQUE、PRIMARY KEY约束
+ 与DEFAULT定义关联或绑定到某一默认对象
+ 绑定到规则
+ 已注册支持全文
+ 用作表的全文键
**** GUI工具操作
**** SQL语句操作
+ ADD 增加列
  USE 教务管理系统
  GO
  ALTER TABLE 学生信息
  ADD 家庭住址 varchar(20) NULL
+ DROP COLUMN 删除列
  USE 教务管理系统
  GO
  ALTER TABLE 学生信息
  DROP COLUMN 家庭住址 CASCADE(RESTRICT)
  - CASCADE选项表示将列和列中的数据删除，不论其他对象是否引用这一列，同时所有引用这一列的视图、约束、例程、触发器也将同时被删除
  - RESTRICT选项表示只有在没有任何对象引用该列时，此列才能被删除
** 数据库完整性
*** 数据库完整性分类
+ 实体完整性(Entity Integrity)
  - 实体完整性的目的是确保数据库中所有实体的唯一性，即不应使用完全相同的数据记录
  - 通过设定主键(Primary Key)、唯一键(Unique Key)、唯一索引(Unique Index)和标识列(Identity Column)等多种方法来实现完整性
  - 最常用的方法是使用主键
+ 区域完整性(Domain Integrity)
  - 区域完整性是要求数据表中的数据位于某一个特定的允许范围内
  - 使用默认值(Default)、检查(Check)、外键(Foreign Key)、数据类型(DataType)、规则(Rule)等多种方法实现区域完整性
  - 例如，如果限制"性别"列的数据值可以是"男"或"女"，则输入其他值时会被拒绝
+ 参考完整性(Referential InteGrity)
  - 参考完整性是用来维护相关数据表之间数据一致性的手段，通过实现参考完整性，可以避免因一个数据表的记录改变而造成另一个数据表内的数据变成无效的值
  - 使用外键(Foreign Key)、检查(Check)、触发器(Trigger)和存储过程(Stored Procedure)来实现
  - 例如，在班级信息表和课程信息表中，如果要删除班级信息表的一条记录，而同时在课程信息表中存在需要参考该记录的记录集，那么该删除操作将失败，这样可以避免课程信息表中的数据失去关联
+ 用户定义类型
  -由用户根据实际应用中的需要自行定义，可以用来实现用户定义完整性的方法有：规则(Rule)、触发器(Trigger)、存储过程(Stored Procedure)和数据表创建时可以使用的所有约束(Constraint)
*** 使用约束维护数据完整性
**** 主关键字约束(Primary Key Constraint)
+ PRIMARY KEY约束为主关键字约束，是一种SQL唯一约束，用于指定表的一列或几列的组合的值在表中具有唯一性，即能唯一地指定一行记录
+ PRIMARY KEY约束的创建方式又三种
  - 作为表定义的一部分在创建表时创建
  - 添加到尚没有PRIMARY KEY约束的表中
  - 如果已经存在PRIMARY KEY约束，可以对其进行修改和删除
+ 每个表中只能有一列被定义为PRIMARY KEY约束，该列不能包含空值，且IMAGE和TEXT类型的列不能定义为PRIMARY KEY约束
+ PRIMARY KEY约束可以用于表约束和列约束，表约束是指在表定义上定义的约束，列约束是指对于列的约束
+ 列约束
  <column_name>{<data_type>|<domain>} PRIMARY KEY
  - column_name 被定义为PRIMARY KEY约束的列名
  - data_type 该列数据类型
  - domain 列的值域
+ 表约束
  - 如果要将PRIMARY KEY约束作为表约束来添加，必须把它作为表定义中的元素来添加，语法如下
    CONSTRAINT <constraint_name>
    PRIMARY KEY [CLUSTERED | NONCLUSTERED]
    (<column_name[{,<column_name>}]>)
  - constraint_name指约束的名称，在数据库中应是唯一的，如果不指定，则系统会自动生成一个约束名
  - CLUSTERED和NONCLUSTERED指定了索引类别、聚集或非聚集
  - column_name指定组成主关键字的列名，可以是一个或多个，不能多于16个
  - 示例
    CREATE TABLE 学生信息 (
      学号 varchar(14),
      姓名 varchar(8) NULL,
      班级编号 varchar(14) NULL,
      性别 varchar(2) NULL,
      年级 int NULL
      CONSTRAINT 学号
      PRIMARY KEY (学号)
    )
+ 向已有表中添加主键，其中被指定为主键约束的列必须已经指定了NOT NULL约束，否则无法将该列指定为主键约束
  ALTER TABLE table_name (
  ADD
  [CONSTRAINT primarykey_name]
  PRIMARY KEY[CLUSTERED | NONCLUSTERED]
  (column_name[,...n])
  )
  示例
  ALTER TABLE 学生信息
  ADD
  CONSTRAINT 学号
  PRIMARY KEY(学号)
+ 删除主键约束
  ALTER TABLE table_name(
  DROP
  {[CONSTRAINT] primarykey_name}[,...n]
  )
  示例
  ALTER TABLE 学生信息
  DROP
  CONSTRAINT 学号
**** 外关键字约束(Foreign Key Constraint)
+ FOREIGN KEY约束定义了表之间的关系，主要用来维护两个表之间的一致性关系，当一个表中的一个列或多个列的组合与其他表中的主关键字定义相同时，就可以将这些列或列的组合定义为外关键字，并设定它适合与哪个表中的哪些列相关联
+ 外键约束不仅可以与另一张表上的主键约束建立联系，也可以与另一张表上的唯一约束建立联系，当一行新的数据被加入到表格中，或对表格中已经存在的外键上的数据进行修改时，新的数据必须存在于另一张表的主键上，或者为NULL
+ 在创建表时定义外键约束
  CONSTRAINT <constraint_name>
  FOREIGN KEY (<column_name>[{,<column_name>}])
  REFERENCES <ref_table> [(<ref_column>[{,<ref_column>}])]
  [ ON DELETE { CASCADE | NO ACTION } ]
  [ ON UPDATE { CASCADE | NO ACTION }]
  [ NOT FOR REPLICATION ]
  - REFERENCES 指定要建立关联的表的信息
  - ref_table 要建立关联的表的名称
  - ref_column 要建立关联的表中的相关列的名称
  - ON DELETE {CASCADE | NO ACTION} 指定在删除表中的数据时，对关联表所做的相关操作
    CASCADE:在删除父表数据行时会将子表中对应的数据行删除
    NO ACTION:在删除父表数据行时，SQL会产生一个错误，并将父表中的删除操作回滚，为默认值
  - ON UPDATE {CASCADE | NO ACTION}，在父表行数据更新是的处理方式，含义同上
  - NOT FOR REPLICATION
    指定列的外关键字约束在把从其他表中复制的数据插入到表中时不发送作用
+ 添加外键约束
  ALTER TABLE 学生信息
  ADD
  CONSTRAINT 班级编号
  FOREIGN KEY(班级编号)
  REFERENCES 班级信息(班级编号)
+ 删除外键约束
  ALTER TABLE 学生信息
  DROP CONSTRAINT 编辑编号
**** 唯一性约束(Unique Constraint)
+ UNIQUE约束是SQL完整性约束类型中，除了PRIMARY KEY约束之外另一种可以定义唯一性约束的类型
+ UNIQUE约束指定一个或多个列的组合的值具有唯一性，防止在列的输入重复的值，这一点雨PRIMARY KEY约束相同，但主键不允许空值，而且每个表中主键只能有一个，而在UNIQUE约束中允许有空值，且可以在多个列上定义
+ 语法
  CONSTRAINT <constraint_name>
  UNIQUE [CLUSTERED | NONCLUSTERED]
  (<column_name>[{,<column_name>}])
  示例
  CREATE TABLE 学生信息(
    学号 varchar(14) UNIQUE,
    姓名 varchar(8),
    编辑编号 varchar(14) NULL,
    性别 varchar(2) NULL,
    年级 int NULL
    CONSTRAINT 姓名 UNIQUE(姓名)
  )
**** 检查约束(Check Constraint)
+ 示例
  CREATE TABLE 学生信息(
    学号 varchar(14) PRIMARY KEY,
    姓名 varchar(8) NULL,
    班级编号 varchar(14) FOREIGN KEY REFERENCES 班级信息，
    性别 varchar(2) CHECK(性别 in ('男','女'))，
    年级 int NULL
  )
**** 默认约束(Default Constraint)
+ SQL Server 2008推荐使用DEFAULT约束，而不使用定义默认值的方式来指定列的默认值
+ 语法
  <column_name><data_type> DEFAULT <default_value>
  
  CREATE TABLE 学生信息(
  学号 varchar(14) PRIMARY KEY,
  姓名 varchar(8) NULL,
  班级编号 varchar(14) NULL,
  性别 varchar(2) NOT NULL,
  年级 int DEFAULT '该生未分配班级'
  )
**** 空值约束(Not Null Constraint)
+ 语法
  <column_name>{<data_type>|<comain>} NOT NULL
+ 在定义主键时，NOT NULL约束一般与PRIMARY KEY约束联合使用，只要在某列定义了PRIMARY KEY约束，那么该列必然遵守NOT NULL约束
*** 使用默认值维护数据完整性
+ 默认值对象一般作用于列或用户定义数据类型上，不会因为其绑定的列或用户定义数据类型的删除而受到影响，默认值对象可以是常量、内置函数或数学表达式
+ 为表中列数据添加默认值有两种方法
  - 使用CREATE TABLE语句创建表时，在列上DEFAULT定义提供默认值
  - 使用CREATE DEFAULT语句创建默认值对象，再将对象设置到列或用户定义数据类型上
    1. 使用CREATE DEFAULT语句创建默认值对象
       CREATE DEFAULT <default_name>
       AS <constant_expression>
       - defai;t_name 默认值对象的名称
       - constant_expression 是常量表达式，常量表达式中可以包括常量、内置函数或数学表达式，但不能包括任何列名或其他数据库对象
    2. 绑定默认值
       - 默认值对象就可以在插入记录时为列或用户定义数据类型提供默认值，绑定默认值可以使用sp_bindefault系统存储过程
         EXEC sp_bindefault 'default', 'object_name'[,'futureonly_flag']
       - 使用sp_unbindefault可以解除绑定
         EXEC sp_unbindefault 'object_name' [,'futureonly_flag']
    3. 查看默认值
       - GUI的对象资源管理器中可以查看数据库所创建的默认值，例如[数据库]-[教务管理系统]-[可编程性]，在[默认值]节点下的列表中列出了该数据库所创建的默认值
       - 使用sp_help可以查看默认值的拥有者、创建时间等基本信息
         EXEC sp_help Date
       - 使用sp_helptext可以查看默认值的定义语句
         EXEC sp_helptext Date
    4. 删除默认值
       DROP DEFAULT default_name
       在删除之前，需要解除使用与之的绑定
*** 使用规则维护数据完整性
+ 规则是数据库对存储在表的列或用户定义数据类型中的值的规则和限制，规则与其作用的表或用户定义数据类型是相互独立的，即表或用户数据类型的删除、修改不会对与之相关联的规则产生影响
+ 规则的作用于CHECK约束相似，是在向表中插入或更新数据时，用来限制输入值的取值范围，但与CHECK约束的不同之处有以下三点：
  - CHECK约束是在创建表时指定的，而规则可以作为单独的数据库对象来对列约束
  - 在同一表列中，可以有一个规则及多个CHECK约束
  - 规则可以应用于多个列，还可以应用于用户定义数据类型，而CHECK约束只能用于它定义的列
+ 创建规则
  CREAT RULE rule_name 
  AS 
  condition_expression
+ 绑定规则
  EXEC sp_bindrule 'rule', 'object_name'[, 'futureonly_flag']
+ 解除绑定
  EXEC sp_unbindrule 'object_name' [,'futureonly_flag']
+ 查看规则
  EXEC sp_help rule_name
+ 查看规则定义信息
  EXEC sp_helptext rule_name
+ 删除规则
  DROP RULE <rule_name>
*** 表关系图
+ 在关系数据库中，关系可以防止冗余数据，关系通过匹配键列(通常是两个表中同名的列)中的数据来发挥作用，通常关系将一个表的主键(为每行提供唯一的标识符)与另一个表中的外键向匹配
+ 表之间的关系有三种类型
  - 一对一
  - 一对多
  - 多对多
+ 使用GUI工具
  [数据库关系图]上右击，选择[新建数据库关系图]
* Transact-SQL语言
** 数据查询和管理
*** SELECT获取简单数据
+ 使用SELECT语句不但可以在数据库中精确的查找某条信息，而且还可以模糊的查找带有某项特征的多条数据，SELECT语句具有数据查询、统计、分组和排序的功能
+ 完整语法
  SELECT [ALL | DISTINCT] select_list
  [INTO new_table]
  FROM table_source
  [WHERE search_conditions]
  [GROUP BY group_by_expression]
  [HAVING search_conditions]
  [ORDER BY order_expression[ASC | DESC]]
  
  - SELECT子句
    1. 用来指定由查询返回的列，并且各列在SELECT子句中的顺序决定了它们在结果表中的顺序
    2. TOP关键字可以指定返回结果集中的前多少行
    3. 使用别名
       - ANSI规则标准
         SELECT 编号 'id', 姓名 'name' FROM 教师信息表
       - AS关键字
          SELECT 编号 AS 'id', 姓名 AS 'name' FROM 教师信息表
    4. 计算列
       - 在进行数据查询时，在SELECT子句中不仅可以是属性列，还可以是表达式，计算列并不存在于数据表中，而是通过对某些列的数据进行计算得到的结果
       - 由于计算列没有列名，需要指定一个别名
       - 表达式部分允许使用+、-、*、/算是运算符；AND"&"、XOR"^"、NOT"`"逻辑运算符；字符串连接符"+"和函数等
         SELEC 编号,学号,'调整前成绩'=成绩,成绩-15 '调整后成绩'
         SELECT 姓名,性别,'民族：'+民族+ -籍贯:'+籍贯 AS '学生信息' 
  - ALL | DISTINCT
    用来标识在查询结果集中对相同行的处理方式，ALL表示返回查询结果集的所有行，其中包括重复行；DISTINCT表示如果结果集中有相同的数据行则只保留显示一行，默认值为ALL
  - select_list
    用来指定要显示的目标列，如果要显示多个目标列，则各列之间用逗号隔开，如果要返回所有列，则使用星号'*'表示
  - INTO new_table
    用来创建一个新的数据表，new_table为新的表明，表的数据我查询的结果集
  - FROM table_source
    用来指定数据源，table_source为数据源表名称(或视图)组,可以同时查询多个表或视图用逗号","分开，相应的列前加上所在的表名或视图名
  - WHERE search_conditions
    1. 用来指定限定范围的行的搜索条件，符合搜索条件为true，不符合的为false或未知
    2. WHERE可以使用的运算符
       - 比较运算符 = > < >= <= <>(!=)
       - 逻辑运算符 AND OR NOT
         1. NOT只应用于简单条件，不能将NOT应用于包含AND或者OR条件的复合条件中，即NOT(性别='女' AND 面貌='党员')返回的结果集是错误的
         2. AND用于合并简单条件和包括NOT的条件，不允许包含OR条件，如果使用一个以上的AND条件，这些条件可以以任意顺序合并在一起，不需要括号
         3. OR可以使用AND和NOT合并所有复合条件，使用多个OR条件，可以任意顺序组合，不需要括号
         4. 优先级 从高到低NOT AND OR
       - 范围运算符 BETWEEN AND     NOT BETWEEN AND
         1. WHERE expression [NOT] BETWEEN value1 AND value2 
         2. 用户可以自行设定上边界值和下边界值来指定搜索范围,绝对不允许value1大于value2
       - 列表运算符 IN  NOT IN
         1. 需要确定表达式的取值是否属于某一列表值之一时使用,当值不止一个时需要将这些值用括号包裹，用逗号分隔
            WHERE expression [NOT] IN value_list
         2. IN关键字作为指定条件时不允许数据中出现NULL值，即有效值列表中不能包含NULL值的数据
            SELECT * FROM 学生信息 WHERE 学号 IN ('20005','2009')
       - 字符匹配符 LIKE  NOT LIKE
         1. 如果在查询数据时，只知道列名的一部分，或想统计一部分以某数据开头的数据信息
            WHERE expression [NOT] LIKE 'string'
         2. 进行模糊匹配时在string字符串中使用通配符，在使用含有通配符时必须将字符串连通配符用单引号括起来
            - % 任意多个字符
            - _ 单个字符
            - [] 指定范围的单个字符
            - [^ ] 不在指定范围的单个字符
         3. 示例
            M% 以M开头的任意字符串，如Milk
            %M 以M结尾的任意字符串，如ROOM
            %m% 表示任何位置包含字母m的所有字符串，如some man
            _M 表示查询以任意一个字符开头，以M结尾的两位字符串，如AM，PM
            M[ai]% 表示以M开头，第二个字符是a或i的所有字符串，如MAchine，Miss
            M[^ai]% 表示以M开头，第二个字符不是a或i的所有字符串，如Media，Moon
            [A-M]% 以A到M之间任意字符开头的字符串，如Job，Mail
            [^A-M]% 不是以A到M之间的任意字符开头的字符串，如Not，Zoo
         4. 比较字符串是不区分大小写的，如m%和M%是相同的比较字符串
         5. 如果LIKE后面的匹配串中不包含通配符，则可以用等号"="取代LIKE,用<>取代NOT LIKE
       - 未知值     IS NULL   IS NOT NULL
        使用包含IS NULL关键字的WHERE语句可以查询数据库中值为NULL的数据，用IS NOT NULL关键字查询值不为NULL的数据 
  - GROUP BY group_by_expression
    用来指定查询结果的分组条件，即归纳信息类型
    1. 可以将查询结果按照某一列或多列数据值进行分类，值相等的为一组，即对查询结果的信息进行归纳，汇总相关数据
    2. GROUP BY子句后可以带上HAVING子句表达组选择条件，组选择条件为带有函数的条件表达式，是决定整个组记录的取舍条件
    3. 语法
       GROUP BY group_by_expression [WITH ROLLUP|CUBE]
       - group_by_expression表示分组所依据的列
       - ROLLUP表示只返回第一个分组条件指定的列的统计行，如果改变列的顺序就会使返回的结果行数据发生变化
       - CUBE是ROLLUP的扩展，处理返回GROUP BY子句指定的列，还返回按组统计的行
    4. GROUP BY子句通常与统计函数联合使用，如COUNT、SUM等
    5. 常用的统计函数
       - COUNT  求组总项数，返回整数
       - SUM    求和，返回表达式中所有值的和
       - AVG    求平均值，返回表达式中所有值的平均值
       - MAX    求最大值
       - MIN    求最小值
       - ABS    求绝对值
       - ASCII  求ASCII码，返回字符型数据的ASCII码
       - RAND   产生随机数，返回一个位于0和1之间的随机数
    6. 在使用GROUP BY子句，将GROUP BY子句中的列称为分隔列或分组列，且必须保证SELECT语句中的列是可以计算的值或在GROUP BY列表中
       SELECT 班级编号,COUNT(课程名称) AS 选课总数 FROM 课程信息 GROUP BY 班级编号
       SELECT AVG(成绩) AS 平均成绩 FROM 成绩表 WHERE 课程编号='1'
  - HAVING search_conditions
    1. 用来指定组或聚合的搜索条件,通常与GROUP BY共同使用
    2. HAVING的用法类似于WHERE，WHERE用于限定每一行的查询条件，而HAVING限定分组统计值
       HAVING search_conditions
    3. search_conditions为查询所需要的统计，将限定这个GROUP BY创建的组
       - 如果指定了GROUP BY子句，则HAVING的查询条件将应用于GROUP BY创建的组
       - 如果指定了WHERE子句，但没有GROUP BY子句，将应用于WHERE子句的输出结果集
       - 如果WHERE和GROUP BY子句都没有指定，将应用于FROM子句的输出结果集
    4. 可以包含聚集函数，而WHERE子句不可以，且HAVING子句中的每一个元素都必须是出现在SELECT语句列表中的
       示例，按班级编号查询出每个班级选课总数，然后输出课程总数大于10的班级编号和选课总数
       SELECT 编辑编号, COUNT(课程名称) AS 选课总数
       FROM 课程信息
       GROUP BY 班级编号
       HAVING COUNT(*)>10
  - ORDER BY order_expression[ASC|DESC]
    1. 用来指定结果集的排序方式，ASC为升序，DESC为降序，默认为ASC
       ORDER BY order_expression [ASC | DESC]
    2. 其中order_expression表示用于排序的列或列的别名及表达式,当有多个排序列时,用逗号隔开,且每个列后都可以跟随一个ASC或DESC
  - SELECT中子句的顺序是有规定的，按照上述顺序可以正确执行
*** SELECT操作多表数据
+ 在实际查询应用中，用户所需要的数据并不全部都在一个表或视图中，而是存在于多个表中，这时就要使用多表查询，将多个表中的数据组合起来提取需要的信息
+ 多表查询实际上是通过各个表之间的共同列的相关性来查询数据，是数据库查询最主要的特征
**** 简单方式
+ 最简单的连接方式就是在SELECT语句列表中引用多个表的字段，其FROM子句中用逗号隔开不同的基本表
+ 如果使用WHERE子句创建一个同等连接则能使查询结果集更加丰富，同等连接是指第一个基本表中的一个或多个列值与第二个基本表中对应的一个或多个列值相等的连接
+ 通常情况下，一般使用键码列建立连接，即一个基本表中的主键码与第二个基本表中的外键码保持一致，以保持整个数据库的参照完整性
+ 基本原则
  - SELECT子句列表中，每个目标列前都要加上基本表名称
  - FROM子句应包括所有使用的基本表
  - WHERE子句应该定义一个同等连接
  SELECT S.学号,S.姓名,S.班级编号,C.成绩
  FROM 学生信息 S, 成绩表 C
  WHERE S.学号=C.学号
**** JOIN连接
+ JOIN连接查询的连接条件主要是通过以下方法定义两个表在查询中的关系方式
  - 指定每个表中要用于连接的目标列，即在一个基本表中指定外键，在另一个基本表中指定与其关联的键
  - 指定在比较各目标列的值时要使用的比较运算符，如=、<等
+ 连接可以在SELECT语句的FROM子句或WHERE子句中创建，连接条件与WHERE子句和HAVING子句组合，用于控制在FROM子句引用的基本表中所选定的行
+ 语法
  SELECT select_list
  FROM table1 join_type table2 [ON join_conditions]
  [WHERE search_conditions]
  [ORDER BY order_expression]
***** 内连接
+ 内连接是比较常用的一种数据连接查询方式，使用比较运算符进行多个基本表间数据的比较操作，并列出这些基本表中与连接条件相匹配的所有的数据行
+ 一般用INNER JOIN或JOIN关键字来指定内连接，它是连接查询默认的连接方式
+ 语法
  SELECT select_list
  FROM table1 INNER JOIN table2 [ON join_conditions]
  [WHERE search_conditions]
  [ORDER BY order_expression]
+ 内连接又可分为等价连接、非等值连接和自然连接三种
  1. 等值连接
     - 等值连接就是在连接条件中使用比较运算符等于号=来比较连接的列值，其查询结果中列出被连接表中的所有列，包括重复列
     - 示例
       SELECT 学生信息.学号,学生信息.姓名,学生信息.班级编号,成绩表.成绩
       FROM 学生信息 INNER JOIN 成绩表 ON 学生信息.学号=成绩表.学号
  2. 非等值连接
     - 非等值连接查询就是在连接条件中使用除了等号之外的比较运算符，也可以使用范围运算符BETWEEN
       SELECT S.学号,S.姓名,S.年级,S.班级编号,C.成绩
       FROM 学生信息 S INNER JOIN 成绩表 C
       ON S.学号=C.学号 AND C.成绩 BETWEEN 80 AND 100
       ORDER BY C.成绩 DESC
  3. 自然连接
     - 自然连接是在连接条件中使用等号比较连接列的列值，但它使用选择列表指出查询结果集中所包括的列，并删除连接表中的重复列，在使用自然连接查询时，它为具有相同名称的列自动进行记录匹配
       SELECT DISTINCT S.学号,S.姓名,S.年级,S.班级编号,C.成绩
       FROM 学生信息 S INNER JOIN 成绩表 C
       ON S.学号=C.学号
     - 内连接有返回信息的条件时，当且仅当至少有一个同属于两个表的行符合连接条件，内连接从第一个表中消除与另一个表中任何不匹配的行
***** 外连接
+ 外连接与内连接不同，内连接消除与与另一个表的任何不匹配的行，而外连接会返回FROM子句中提到的至少一个表或视图中的所有行，只要这些行符合任何搜索条件
+ 外连接参与连接的表有主从之分，以主表的每行数据去匹配从表中的数据行，如果符合连接条件，则直接返回到查询结果中；如果主表没有在从表中匹配到，主表的行仍然保留，并返回到查询结果中，相应的从表中的行将被填上空值后也返回到查询结果中
+ 根据查询语句中指定的关键字及各个表的位置可将外连接分为3类：左外连接、右外连接、完全连接
  1. 左外连接(LEFT OUTER JOIN)
     返回所有的匹配行并从关键字JOIN左边的表中返回所有不匹配的行
     SELECT S.学号,S.姓名,C.课程编号,C.成绩
     FROM 学生信息 S LEFT OUTER JOIN 成绩表 C ON S.学号=C.学号
     上述语句中，学生信息为主表，成绩表为从表，查询结果中将返回学生信息表的全部信息，而成绩表返回与学生信息表向匹配的行信息，将不匹配的行填上空值后也返回到查询结果中
  2. 右外连接(RIGHT OUTER JOIN) 
     返回所有匹配行从关键字JOIN右侧的表中返回所有不匹配的行
  3. 完全连接(FULL OUTER JOIN)
     返回两个表中使用匹配和不匹配的行
***** 交叉连接
+ 对两个基本表使用交叉连接查询，将生产来自这两个基本表的各行的所有可能组合，即在结果集中，两个基本表中每两个可能成对的行占一行
+ 在交叉连接中，查询条件一般限定在WHERE子句中，查询生产的结果集可分两种情况
  1. 不使用WHERE子句
     返回的结果集是被连接的两个基本表所有的苗卡尔积，即返回的结果集中的行数等于一个基本表中符合查询条件的行数乘以另一个基本表中符合查询条件的行数
  2. 使用WHERE子句
     返回的结果集是被连接的两个基本所有行的苗卡尔积减去WHERE子句条件搜索到的数据行数
+ 示例
  查询"课程编号"为12的学生的学号、姓名、性别、课程编号、成绩
  SELECT S.学号,S.姓名,S.性别,C.课程编号,C.成绩
  FROM 学生信息 S CROSS JOIN 成绩表 C 
  WHERE S.学号=C.学号 AND 课程编号="12"
  ORDER BY 成绩 DESC
***** 自连接
+ 自连接是指一个表与自身相连接的查询，自连接操作时通过给基本表定义别名的方式来实现的，实质上，这种自连接方式与两个表的连接操作完全相似，只是在每次列出这个表时便为其命名一个别名
+ 在自连接中可以使用内连接或外连接等方式连接
  SELECT S1.学号,S1.姓名,S2.性别,S2.政治面貌
  FROM 学生信息 S1 INNER JOIN 学生信息 S2 ON S1.学号=S2.学号
  WHERE S2.政治面貌='党员' AND S2.性别='男'
***** 联合查询
+ 联合查询是指将多个不同的查询结果连接在一起组成一组数据的查询方式
+ 使用UNION关键字连接各个SELECT子句，将两个或更多的查询结果集组合为一个单个结果集，该结果集包含联合结果中所有查询结果集中的全部行数据
+ 联合查询不同于对两个表中的列进行连接查询，前者是组合两个表中的行，后者是匹配两个表中的列数据
+ 语法
  SELECT select_list
  FROM table_source
  [WHERE search_conditions]
  {UNION [ALL]
  SELECT select_list
  FROM table_source
  [WHERE search_conditions]}
  [ORDER BY order_expression]
  - 其中ALL关键字为可选，如果在UNION子句中使用该关键字，则返回全部满足匹配的结果，如果不使用，则返回结果中删除满足匹配的重复行
  - 在进行联合查询时，查询结果的列标题为第一个查询语句的列标题，因此必须在第一个查询语句中定义列标题
  SELECT S.学号,S.姓名,'学生信息表' AS 当前位置
  FROM 学生信息 S WHERE 政治面貌='预备党员'
  UNION
  SELECT C.班级编号,C.班级名称,'班级信息表' 
  FROM 班级信息C
+ 使用UNION关键字进行联合查询时，应保证每个联合查询语句的选择列表中具有相同数量的表达式，并且每个查询选择表达式具有相同的数据类型，或者可以自动将它们转换为相同的数据类型
+ 在使用UNION的SELECT语句时，如果要对联合查询结果进行排序，则必须使用第一个查询语句中的列名、列标题和列序号，并且排序子语句ORDER BY中最好使用数字来指定排序次序，如果不用数字，则联合查询的子查询中的列名就需要相同，也可以使用别名来统一列名,在对联合查询的结果进行排序时，必须把ORDER BY放在SELECT的后面
***** 使用子查询
+ 使用子查询或连接，可以实现使用查询语句访问多个表中的数据，根据子查询返回行数的不同可以分为：返回多行的子查询、返回单行的子查询、嵌套子查询
  1. 返回多行的子查询
     - 是指执行查询获得的结果集中，返回了多行数据的子查询，一般情况下，对子查询的讨论都是通过WHERE子句实现的，但实际上还能用于SELECT语句及HAVING语句中
     - 在子查询中可以使用IN关键字、EXITS关键字和比较运算符来连接表
     - 使用IN关键字
       + IN关键字的作用是判断一个表中指定列的值是否包含在已定义的列表中，或在另一个表中，通过使用IN关键字把原表中目标列的值和子查询的返回结果进行比较，如果目标列值与子查询的结果一致或存在与之匹配的数据行，则查询结果集中就包含该数据行
       + 语法
         SELECT select_list
         FROM table_source
         WHERE expression IN | NOT IN (subquery)
         其中subquery表示子查询，括号外围的查询将子查询结果作为限定条件，进而进行查询
       + 示例
         查询和"陈岩"在同一个"年级"的学生"姓名"等信息
         SELECT 姓名,性别,年级 FROM 学生信息 S1
         WHERE S1.年级 IN (SELECT 年级 FROM 学生信息 S2 WHERE S2.姓名='陈岩')
         同样的查询可以使用自连接完成
         SELECT S1.姓名,S1.性别,S1.年级
         FROM 学生信息 S1, 学生信息 S2
         WHERE S1.年级=S2.年级 ANDF S2.姓名='陈岩'
     - 使用EXISTS关键字
       + EXISTS关键字的作用是在WHERE子句中测试子查询返回的行是否存在，它的子查询不返回任何数据，只产生逻辑值true或逻辑值false
       + 语法
         SELECT select_list
         FROM table_source
         WHERE EXISTS | NOT EXISTS (subquery)
       + 示例
         查询所有选修了"课序号"为8的所有学生的姓名
         SELECT 姓名 FROM 学生信息
         WHERE EXISTS(SELECT * FROM 选课表 WHERE 选课表.学号=学生信息.学号 AND 课序号='8')
       + 使用EXISTS关键字，如果子查询中能够返回数据行，即查询成功，则子查询外围的查询也能成功；如果失败则外围查询也会失败，这里EXISTS连接的子查询可以理解为外围查询的触发条件
       + in是把外表和内表作hash(字典集合)连接，而exists是对外表作循环，每次循环再对内表进行查询。一直以来认为exists比in效率高的说法是不准确的，如果查询的两个表大小相当，那么用in和exists差别不大；如果两个表中一个较小一个较大，则子查询表大的用exists，子查询表小的用in
     - 比较运算符
       + 子查询可以由一个比较运算符和一些关键字引入，查询结果返回一个值列表
       + 语法
         SELECT select_list
         FROM table_source
         WHERE expression operator [ANY|ALL|SOME] (subquery)
         - operator表示比较运算符：ANY|ALL|SOME是SQL支持的在子查询中进行比较的关键字，ANY和SOME表示外围查询限定条件与子查询返回值进行比较，如果外围查询中有任意多个数据满足比较条件，则全部返回；ALL表示外围查询限定条件与子查询返回值进行比较，外围子查询返回结果必须全部满足比较条件
         - 比较运算符含义
           >ANY         大于子查询结果中的某个值
           >ALL         大于子查询结果中的所有值
           <ANY         小于子查询结果中的某个值
           <ALL         小于子查询结果中的所有值
           >=ANY        大于等于子查询结果中的某个值
           >=ALL        大于等于子查询结果中的所有值
           <=ANY        小于等于子查询结果中的某个值
           <=ALL        小于等于子查询结果中的所有值
           !=ANY(<>)    不等于子查询结果中的某个值
           !=ALL(<>)    不等于子查询结果中的所有值
       + 示例
         查询其他系中比外语系中某一个学生年龄小的学生的信息
         SELECT 姓名,年龄
         FROM 学生信息
         WHERE 年龄 <ANY (SELECT 年龄 FROM 学生信息 WHERE 所在系别='外语系') AND 所在系别<>'外语系'//最后短语是父查询中的条件
  2. 返回单值的子查询
     - 就是子查询的查询结果只返回一个值，然后将一列值与这个返回的值进行比较
     - 在返回单值的子查询中，比较运算符不需要使用ANY、SOME等关键字；WHERE子句中可以使用比较运算符来连接子查询
     - 示例
       查询性别为女的学生的姓名等信息
       SELECT 姓名,班级编号,性别 FROM 学生信息
       WHERE 班级编号 IN (SELECT 班级编号 FROM 班级信息 WHERE 性别='女')
  3. 嵌套子查询
     - 当一个子查询中包含另一个子查询时称为嵌套子查询，能够帮助用户从多个表中完成查询任务
     - 示例
       查询班级编号在....之间且开课系别等于计算机系的信息
       SELECT 学号,姓名,系别 FROM 学生信息 WHERE 班级编号 IN
       (SELECT 班级编号 FROM 班级信息 WHERE 班级编号 BETWEEN '20021340000104' AND '20021340000106' AND 班级编号 IN
       (SELECT 班级编号 FROM 课程信息 WHERE 开课系别='计算机系'))
*** 插入SQL数据
**** INSERT...VALUES语句
+ INSERT语句时SQL中最常用的用于向数据表中插入数据的方法，可以向表中添加一个或多个新行
+ 语法
  INSERT [INTO] talbe_or_view [(column_list)] VALUES data_values
  - table_or_view
    用于指定向数据表中添加数据的表或视图名称
  - column_list
    用于指定该数据表的列名，可以指定一列或多列，所有这些列都必须放在圆括号中，指定多列用逗号隔开，如果指定了列名，那么在目标数据表中所有未指定的列必须支持空值或默认值
  - data_values
    指定向数据表中插入的数据值，这些值也必须放在圆括号中，用逗号隔开，如果指定了列名，则该数据必须与各列一一对应，如果没有指定列名，该数据必须与数据表中各列顺序一一对应
+ 在插入数据时，如果遗漏列表和数值中的一列，那么该列存在默认值时，将使用默认值，如果没有默认值这SQL Server将尝试填充一个空值，如果该列声明了NOT NULL，将导致插入报错
+ 示例
  INSERT INTO 教师信息表 VALUES(1022,'李四',34,'河南',5,'男')
  由于此语填充了所有的列值，所以无须给出列名，但插入的数值必须与表定义的列名顺序完全相同
**** INSERT...SELECT语句
+ 使用INSERT...SELECT语句可以把其他数据表的行记录添加到当前表中
+ 使用INSERT...SELECT语句比使用多个单行的INSERT语句效率要高得多
+ 使用INSERT...SELECT语句时应该遵循如下的原则
  - 在最外面的查询表中插入所有满足SELECT语句的行
  - 必须检验要插入新行的表是否存在
  - 必须保证接受新值的表中列的数据类型与源表中相应列的数据类型一致
  - 必须明确是否存在默认值，或所有被忽略的列是否允许为空值，如果不允许空值，必须为这些列提供值
+ 语法
  INSERT table_name
  SELECT column_list
  FROM table_list
  WHERE search_conditions
**** SELECT INTO语句创建表
+ 使用SELECT INTO语句可以把任何查询结果集放置到一个新表中，还可以通过使用SELECT INTO语句解决复杂的问题，例如，需要从不同数据源中得到数据集，如果一开始先创建一个临时表，则在该表上执行查询比在多表或多数据库中执行查询更简单
+ 使用SELECT INTO语句需要注意如下事项
  - 可以使用SELECT INTO语句创建一个表且在单独操作中向表中插入行，确保在表名是唯一的，如果表名出现重复，SELECT INTO语句将失败
  - 可以创建本地或全局临时表，本地临时表需要在表名前加井号#，全局临时表需要在表名前加两个井号##，本地临时表只在当前会话中可见，全局临时表在所有会话中都可见
  - 当使用者结束会话时，本地临时表的空间会被回收
  - 当创建表的会话结束且当前参照表的最后一个SQL语句完成时，全局临时表的空间会被回收
+ 语法
  SELECT <column_list>
  INTO new_table
  FROM {<table_source>}[,...n]
  WHERE <search_condition>
*** 更新SQL数据
**** 根据表中数据更新行(UPDATE)
+ 在SQL中，对数据的更新操作是通过使用UPDATE语句来实现的,UPDATE语句可以更改表或视图中的单行、行组或所有行的数据值
+ 语法
  UPDATE [TOP] table_or_view
  SET {column_name=expression | DEFAULT | NULL}[,...n]
  [WHERE search_conditions]
  - WHERE子句是可选的，如果省略该子句，那么将更新表中该列的所有数据
  - 使用UPDATE语句可以根据自己表的数据进行更新，也可以根据其他表的数据进行更新
+ 注意事项
  - 用WHERE指定需要更新的行，用SET子句指定新值
  - UPDATE无法更新标识列
  - 如果行的更新违反了约束或规则，比如违反了列NULL设置，或新值是不兼容的数据类型，则该语句被取消返回错误提示，不会更新任何记录
  - 不会更新任何违反完整性约束的行，该修改不会发生，语句将回滚
  - 每次只能修改一个表中的数据
  - 可以同时把一列或多列、一个变量或多个变量放在一个表达式中
+ 示例
  UPDATE 学生信息
  SET 政治面貌='团员',年龄=年龄+1 
  WHERE 政治面貌='群众'
**** 根据其他表更新行
+ UPDATE语句不但可以在一个表中进行操作，而且还能在多个表中进行操作，使用带FROM子句的UPDATE语句来修改表，该表基于其他表中的值
+ 语法
  UPDATE table_or_view
  SET {column_name=expression | DEFAULT | NULL}[,...n]
  [FROM table_source]
  [WHERE search_conditions]
+ 当使用包含UPDATE语句进行连接或子查询时注意事项
  - 在一个单独的UPDATE语句中，SQL Server不会对同一行做两次更新，这是一个内置限制
  - 使用SET关键字可以引入列的列表或各种要更新的变量名，其中SET关键字引用的列必须明确
  - 如果子查询没有返回值，必须在子查询中引入IN、EXISTS、ANY或ALL关键字
  - 可以考虑在相关子查询中使用聚合函数，因为在单独的UPDATE语句中，不会对同一行做两次更新
  - 子查询也可以嵌套在UPDATE语句中，用于构造修改条件
+ 示例
  UPDATE 成绩表
  SET 成绩=0
  WHERE '12'=(SELECT 课程编号 FROM 学生信息 WHERE 学生信息.学号=成绩表.学号)
**** 使用TOP表达式
+ 使用TOP表达式可以指定要更新的行数或行数的百分比，TOP表达式可以用在SELECT、INSERT、UPDATE、DELETE语句中
+ 语法
  TOP (expression) [PERCENT] [WITH TIES]
*** 删除SQL数据
**** DELETE语句
+ 使用DELETE语句可以删除表或视图中的一条或多条记录
+ 语法
  DELETE table_or_view
  FROM table_sources
  WHERE search_condition
+ DELETE语句中没有指定列名，是因为DELETE语句不能从表中删除单个列的数值，它只能删除行，如果要删除特定列的值，可以使用UPDATE将该列值设置为NULL，当然该列必须支持NULL值
+ DELETE语句只能从表中删除数据，并不删除表本身，删除表的定义，使用DROP TABLE语句
+ 与INSERT和UPDATE语句一样，从一个表中删除记录将引起其他表的参照完整性问题，这是一个潜在问题，需要时刻注意
+ 示例
  1. 删除单行数据
     DELETE 教师信息表 WHERE 编号='1020'
  2. 删除多行数据
     DELETE 教师信息表 WHERE 工龄='7'
  3. 删除所有数据
     DELETE FROM 新教师信息表
  4. 删除固定行数据
     DELETE TOP(5) PERCENT FROM 教师信息表
**** TRUNCATE TABLE语句
+ 使用TRUNCATE TABLE语句可以快速删除表中的所有记录，而且无日志记录，只记录整个数据页的释放操作
+ 语法
  TRUNCATE TABLE [[database.]owner.]table_name
+ 此语句删除表中所有数据时要比DELETE快的多
+ 不能用于有外关键字依赖的表，它是一次性完成删除与表有关的所有数据页的操作，不更新事务处理日志，无法使用ROLLBACK命令恢复，同时它也不删除表结构
**** 删除基于其他表中的行
+ 使用带有连接或子查询的DELETE语句可以删除基于其他表中的行数据
+ 在DELETE语句中，WHERE子句可以引用自身表中的值，并决定删除哪些行，如果使用了附加的FROM子句，就可以引用其他表来决定删除哪些行，当使用带有附加FROM子句的DELETE语句时，第一个FROM子句指出要删除行所在的表，第二个FROM子句引入一个连接作为DELETE语句的约束标准
+ 示例
  DELETE FROM 学生信息
  FROM 班级信息
  INNER JOIN 学生信息 ON 班级信息.=班级编号=学生信息.班级编号 WHERE 班级信息.年级=2001
+ 也可以使用与另一个表相关联的子查询来决定删除哪些行，在WHERE子句中使用嵌套子查询或关联子查询来决定删除哪些行
  DELETE FROM 学生信息
  WHERE 班级编号 IN (SELECT 班级编号 FROM 班级信息 WHERE 年级=2001)
* 使用XML查询技术
* Transact-SQL编程
** 语法规范
根据Transact-SQL语言的执行功能特点，可以分为三类
*** 数据定义语言DDL
+ 数据定义语言是最基础的Transact-SQL语言类型，用来创建数据库和创建、修改、删除数据库中的各种对象，为其他语言的操作提供对象
+ 只有在创建数据库和数据库中的各种对象之后，数据库中的各种其他操作才有意义
+ 数据库、表、触发器、存储过程、视图、索引、函数、类型及用户等都是数据库中的对象，都需要通过定义才能使用
+ 常见命令
  CREATE TABLE 
  ALTER TABLE
  DROP TABLE
*** 数据操纵对象DML
+ 数据操纵语言用于操纵表、视图中数据的语句，当创建表对象后，初始状态时该表为空，查询、插入、更新、删除数据时就需要使用到数据操纵语言
+ 常见命令
  SELECT
  DELETE
  INSERT
  UPDATE
*** 数据控制用于DCL
+ 涉及到权限管理的都被称作数据控制语言，主要用来执行有关安全管理的操作
+ 默认状态下，只有sysadmin、dbcreator、db_owner、db_securityadmin等人员才有权力执行数据控制语言
+ 常见命令
  GRANT
  REVOKE
  DENY
  RECOKE
** 语言基础
*** 常量
+ 常量是指程序运行中值始终都不改变的量，定义常量的格式取决于它所表示的值的数据类型
+ 常量类型及说明
  - 字符串常量
    包括在单引号或双引号中，由字母、数字字符、及特殊字符组成
    'China' "Process X is 60% complete"
  - 二进制常量
    只有0或1构成的串，并且不使用引号，任何大于1的数字将被转换为1
    10110001
  - 十进制整数常量
    使用不带小数点的十进制数据表示
    1984 251 +2008 -1120
  - 十六进制整数常量
    使用前缀0X后跟十六进制数字串表示
    0XEEFD 0X12454EFD
  - 日期常量
    通过使用单引号将日期时间字符串括起来组成
    常见的日期格式
    1. 字母日期格式：'July 25, 2008' '25-July-2008'
    2. 数字日期格式：'08/26/1988' '1998-08-26' '08-26-88' '1998年8月26日'
    3. 未分隔的字符串格式：'18200624'
    常见的时间格式：
    '11:20:28' '08:30 PM'
  - 实型常量
    1. 有定点表示
       1984.1121 4.0 +1984.0123 -1984.0144
    2. 浮点表示两种方式
       10E24 0.24E-6 +644.82E-6 -84E8
  - 货币常量
    以前缀为可选的小数点和可选的货币符号的数字字符串来表示
    $4451 $74074.11 -$84.5
*** 变量
+ 变量是程序执行过程中，其值可以改变的量，可以利用变量存储程序执行过程中涉及的数据
+ 变量由变量名和变量值构成，其类型与常量一样，变量名不能与命令和函数名相同
+ SQL Server中存在两种类型的变量：系统定义和维护的全局变量和用户定义用来保存中间结果的局部变量
**** 系统全局变量
+ 与当前连接有关的全局变量，与当前的处理有关的全局变量，例如@@Rowcount表示最近一个语句影响的行数；@@error保存最近执行操作的错误状态
+ 与整个SQL Server系统有关的全局变量
  - @@CONNECTIONS    返回SQL Server启动后，所接受的连接或试图连接的次数
  - @@CURSOR ROWS    返回游标打开后，游标中的行数
  - @@ERROR          返回上次执行SQL语句产生的错误数
  - @@LANGUAGE       返回当前使用的语言名称
  - @@OPTION         返回当前SET选项信息
  - @@PROCID         返回当前的存储过程标识符
  - @@ROWCOUNT       返回上一个语句所处理的行数
  - @@SERVERNAME     返回运行SQL Server的本地服务器名称
  - @@SERVICENAME    返回SQL Server运行时的注册名称
  - @@VERSION        返回当前SQL Server服务器的日期、版本和处理器类型
**** 局部变量
+ 局部变量必须先用DECLARE命令定以后才能使用，局部变量名要加上@作为前缀
+ DECLARE语句
  DECLARE
      {{@local_variable data_type}
        | {@cursor_variable_name CURSOR}
        | {table_type_definition}
      }[,...n]
+ 声明变量后要给局部变量赋值，可以使用SET或SELECT语句
  - SET @local_variable = expression
    通常使用SET给变量赋值，而不是SELECT
    DECLARE @hello char(20)
    SET @hello='hello,China!'
  - SELECT @local_cariable = expression[,...n]
+ 变量示例
  USE 教务管理系统
  GO
  DECLARE @政治面貌 char(10)
  SET @政治面貌='党员'
  SELECT 学号,姓名,籍贯,年级,民族,政治面貌,所在系别
  FROM 学生信息
  WHERE 政治面貌=@政治面貌
*** 表达式
+ 表达式是由变量、常量、运算符、函数等组成，表达式可以在查询语句的任何位置使用，例如检索数据的条件，指定数据的值等
**** 简单表达式
+ 简单表达式是指仅由变量、常量、运算符、函数等组成的表达式，简单表达式的结果悲剧单一，通常用来描述一个简单的条件
**** 复杂表达式
+ 复杂表达式是由两个或多个简单表达式通过运算符连接起来的表达式
+ 在复杂表达式中，如果两个或多个表达式有不同的数据类型，优先级低的数据类型可以隐式地转换为优先级高的数据类型
+ 示例
  SELECT A.学号,AVG(A.成绩) AS '平均成绩',B.姓名+SPACE(6)+B.性别+SPACE(4)+B.班级编号+'班'+SPACE(4)+STR(B.年级)+'年级' AS '考生信息'
  FROM 成绩表 A INNER JOIN 学生信息 B
  ON A.学号=B.学号
  GROUP BY A.学号,B.姓名,B.性别,B.班级编号,B.年级
  ORDER BY 平均成绩 DESC
**** 注释
+ 单行注释：__
+ 多行注释：/*    */
*** 运算符
**** 算术运算符
+ - * / %(取模-求余运算)
算术运算符两侧的表达式可以是任何数字数据类型，加和减运算符可以也用于datatime和smalldatatime
**** 赋值运算符
=
**** 位运算符
位运算符可以对两个表达式进行位操作，两个表达式可以是整数类型或二进制数据
&(与) 
|(或) 
^(异或)
**** 比较运算符
+ 比较运算符也称为关系运算符，用于比较两个表达式值之间的关系，表达式可以是字符、数字、或日期数据，也可以是text、ntext和image类型的数据，并可用在WHERE或HAVING查询子句中
+ 比较运算符的结果为布尔数据类型，输出结果为TRUE、FALSE或UNKNOW
+ 运算符
  =      等于，对于计算结果为非空值的参数，如果左侧的参数值等于右侧参数值，返回true；否则返回false；如果其中一个        参 数的计算结果为空值或都为空值，则该运算符返回空值
  >      大于，如果参数的计算结果存在空值，返回空值
  <      小于
  >=     大于等于
  <=     小于等于
  !=(<>) 不等于
**** 逻辑运算符
+ 返回true或false的布尔数据类型
+ 逻辑运算符
  - ALL        如果一组的比较都为true，返回true
  - AND        如果两个布尔表达式都为true，返回true
  - ANY        一组的比较中任何一个为true，返回true
  - BETWEEN    如果操作数在某个范围之内，返回true
  - EXISTS     如果子查询包含一些行，返回true
  - IN         如果操作数等于表达式列表中的一个，返回true
  - LIKE       操作数与一种模式相匹配，返回true
  - NOT        对任何布尔值取反
  - OR         如果两个布尔表达式中的一个为true，返回true
  - SOME       如果在一组比较中，有些为true，返回true
**** 连接运算符
+ 加号(+)是字符串的连接运算符，可以将字符串串联起来，其他所有字符串操作都使用字符串函数进行处理
**** 一元运算符
+ 一元运算符只对一个表达式进行操作
+ 正(+)
+ 负(-)
+ 位反(~)
  返回一个数的补数
**** 运算符优先级
1. ~(位非)
2. *(乘) /(除) %(取模)
3. +(正) -(负) +(加) -(减) +(连接) &(位与)
4. = > < >= <= <> != !> !< 比较运算符
5. ^(位异或) |(位或)
6. NOT
7. AND
8. ALL ANY BETWEEN IN LIKE OR SOME
9. =(赋值)
使用()调整优先级
*** 控制语句
**** BEGIN END语句块
+ 用于定义语句块，这些语句块作为一组语句执行，允许语句嵌套
+ 语法
  BEGIN
  {
  多条SQL语句
  或语句块
  }
  END
**** IF ELSE条件语句
+ 语法
  IF Boolean_expression
  {sql_statement|statement_block}
  ELSE
  {sql_statement|statement_block}
**** CASE分支语句
+ 简单CASE格式语法
  CASE input_expression
  WHEN when_expression THEN result_expression
  [...n]
  [ELSE else_result_expression]
  END
+ 搜索CASE格式语法
  CASE
  WHEN Boolean_expression THEN result_expression
  [...n]
  [ELSE else_result_expression]
  END
+ 示例
  SELECT 姓名,籍贯=
  CASE 籍贯
  WHEN '河南' THEN '来自河南'
  WHEN '北京' THEN '来自北京'
  WHEN '湖南' THEN '来自河南'
  ELSE '来自其他省市'
  END
  FROM 学生信息
**** WHILE循环语句
+ 语法
  WHILE Boolean_expression
  {sql_statement | statement_block}
  [BREAK]
  {sql_statement | statement_block}
  [CONTINUE]
  {sql_statement | statement_block}
+ 示例
  DECLARE @i int
  DECLARE @j int
  SET @i=0
  SET @j=0
  WHILE @i<8
    BEGIN
      IF @i<=4
         BEGIN
         WHILE @j<5
             BEGIN
               PRINT SPACE(9-@j)+REPLICATE('*',@j*2+1)
               SET @j=@j+1
             END
             SET @i=@i+1
         END
      ELSE
        BEGIN
          WHILE @j>0
            BEGIN
              SET @j=@j-1
              PRINT SPACE(10-@j)+REPLICATE('*',@j*2-1)
            END
            SET @i=@i+1
        END
   END
**** WAITFOR延迟语句
+ WAITFOR语句可以将它之后的语句在一个指定的间隔之后执行，或在将来的某一指定时间执行
+ 可以悬挂起批处理、存储过程或事件的执行，直到发生以下情况为止：已超过指定的时间间隔、到达指定的时间
+ 语法
  WAITFOR
  {
    DELAY time | TIME time | (receive_statement) [TIMEOUT timeout]
  }
  - DELAY
    可以继续执行批处理、存储过程或事务之前必须经过的指定时段，最长可以24小时
  - receive_statemen
    任何有效的RECEIVE语句
**** RETURN无条件退出语句
+ 该语句无条件终止查询、存储过程或批处理的执行，存储过程或批处理中RETURN语句后面的所有语句都不再执行
+ 当存储过程中使用该语句，可以使用该语句指定返回给调用应用程序、批处理或过程的整数值；如果RETURN语句为指定值，则返回零
+ 语法
  RETURN [integer_expression]
**** GOTO跳转语句
+ 该语句使得SQL批处理的执行跳至指定标签，由于该语句破坏结构化语句的结构，所以应尽量减少该语句的使用
+ 语法
  GOTO label
**** TRY CATCH错误处理语句
+ 如果TRY块内部发生错误，则会将控制传递CATCH块中包含的另一个语句组，TRY CATCH构造捕获所有严重级别大于10但不终止数据库连接的错误
+ 语法
  BEGIN TRY
  {sql_statement | statement_block}
  END TRY
  BEGIN CATCH
  {sql_statement | statement_block}
  END CATCH
*** 常用函数
**** 字符串函数
ASCII()      返回字符表达式中最左侧的字符的ASCII代码值
CHAR()       返回指定ASCII代码的字符
LEFT()       返回字符串中从左边开始指定个数的字符
LEN()        返回指定字符串表达式的字符(而不是字节)数，不包含尾随空格
LOWER()      将大写字符转换为小写字符
LTRIM()      删除前导空格
REPLACE()    替换函数，用第三个表达式替换第一个字符串表达式中出现的所有第二个指定字符串表达式的匹配项
REPLICATE()  复制函数，以指定的次数重复字符表达式
RIGHT()      返回字符串中从右边开始指定个数的字符
RTRIM()      删除尾随空格
SPACE()      空格函数，返回由重复的空格组成的字符串
STR()        返回由数字数据转换为字符数据
SUBSTRING()  返回字符串表达式、二进制表达式、文本表达式或图像表达式的一部分
UPPER()      小写转为大写字符串 
**** 数学函数
ABS()        绝对值
EXP()        返回以e为底的指数
CEILING()    返回大于或等于数值表达式的最小整数
FLOOR()      返回小于或等于数值表达式的最大整数
LN()         返回数值表达式的自然对数
LOG()        返回数值表达式以10为底的对数
POWER()      对数值表达式进行冥运算的结果
ROUND()      返回舍入到指定长度或精度的数值表达式
SIGN()       返回数值表达式的正号、负号或零
SQUARE()     返回数值表达式的平方
SQRT()       返回数值表达式的平方根
**** 聚合函数
+ 聚合函数经常与SELECT语句的GROUP BY子句一起使用，所有聚合函数均为确定性函数，即只要使用一组特定输入值调用聚合函数，该函数总是返回相同的值
+ 除了COUNT函数外，聚合函数都会忽略空值
+ 常用聚合函数
  AVG()          返回组中各值的平均值，如果为空将被忽略
  CHECKSUM()     用于生成哈希索引，返回按照表的某一行或一组表达式计算出来的校验和值
  CHECKSUM_AGG() 返回组中各值的校验和，空值将被忽略
  COUNT()        返回组中项值的数量，空值也将计数
  COUNT_BIG()    返回组中项值的数量，与COUNT函数的唯一区别是返回bigint数据类型的值，而COUNT返回int数据类型的值
  GROUPING()     当行由CUBE或ROLLUP运算符添加时，该函数将导致附件列的输出值为1；否则为零
  MAX()          返回最大值
  MIN()          返回最小值
  SUM()          返回组中各值的总和
  STDEV()        返回指定表达式中所有值的标准偏差
  STDEVP()       返回指定表达式中所有值的总体标准偏差
  VAR()          返回指定表达式中所有值的方差
  VARP()         返回指定表达式中所有值的总体方差
**** 数据类型转换函数
+ 默认情况下，SQL Server会对一些表达式进行自动转换：char和datetime、smallint和int、不同长度的char表达式，这种转换称为隐式转换
+ 没有自动执行数据类型转换的情况需要使用CAST和CONVERT转换函数，这种转换为显示转换
+ 语法
  CAST ( expression AS data_type [ (length) ])
  CONVERT ( data_type [ (length) ],expression [,style] )
+ 示例
  SELECT CAST(学号 AS varchar(10)) AS '学号',姓名 FROM 学生信息
  SELECT CONVERT(varchar(20),学号) AS '学号',姓名 FROM 学生信息
**** 日期和时间函数
+ datepart常量
  yy或yyyy    年
  qq或q       季
  mm或m       月
  wk或ww      周
  dw或w       周日期
  dy或y       年日期(1到366)
  dd或d       日
  Hh          时
  mi或n       分
  ss或s       秒
  ms          毫秒
+ 常用日期和时间函数
  DATEADD()        返回指定日期加上一个时间间隔后的新datetime值
  DATEDIEF()       返回跨两个指定日期的日期边界数和时间边界数
  DATENAME()       返回表示指定日期的指定日期部分的字符串
  DATEPART()       返回表示指定日期的指定日期部分的整数
  GETDATE()        返回当前系统日期和时间
  GETUTCDATE()     返回表示当前的UTC时间
  MONTH()          返回月份
  YEAR()           返回年份
  DAY()            返回天
*** 高级操作
**** 锁(Locks)
+ SQL Server的关键特性之一是支持多用户共享同一数据库，当某些用户同时对同一个数据进行修改时，会产生一定的并发问题，使用事务便可以解决用户存取数据的这个问题，从而保证数据库的完整性和一致性，为防止其他用户修改另一个还没有完成的事务中的数据，就必须在事务中使用锁
+ SQL Server提供了多种锁模式
  - 排他锁
    如果事务T1获得了数据项R上的排他锁，则T1对数据可读可写；其他事务对数据项R的任何封锁请求都不会成功，直至事务T1释放数据项R上的排他锁
  - 共享锁
    如果事务T1获得了数据项R上的共享锁，则T1对数据项R可读但不可写；事务T1对数据项R加上共享锁，则其他事务对数据项R的排他锁请求不会成功，而对数据项R的共享锁请求可以成功
  - 更新锁
    更新锁可以防止死锁情况的出现，当一个事务查询数据库以便进行修改时，可以对数据项施加更新锁，如果事务修改资源，则更新锁会转换成排他锁，否则会转换成共享锁。一次只有一个事务可以获得资源上的更新锁，它允许其他事务对资源的共享访问，但阻止排他式访问
  - 意向锁
    意向锁用来保护共享锁或排他锁放置在锁层次结构的底层资源上，在较低级别锁前可获取它们，会通知意向锁将锁放置在较低级别上
  - 键范围锁
    可防止幻读，通过保护行之间键的范围，可以防止事务访问的记录集进行幻象插入或删除
  - 架构锁
    执行表DDL操作时使用架构修改锁，在架构锁起作用期间，会防止对表的并发访问
  - 大容量更新锁
    允许多个进程将数据并行的大容量复制到同一表，同时防止其他不进行大容量复制的进程访问该表
+ 使用sys.dm_tran_locks视图可以快速了解SQL Server内的加锁情况，默认情况下，任何一个拥有VIEW SERVER STATE权限的用户均可以查询sys.dm_tran_locks视图
**** 游标(Cursor)
+ 游标是类似于C语言指针一样的结构，在SQL Server中它是一种数据访问机制，允许用户访问单独的数据行，而不是对整个行集进行操作，用户可以通过单独处理每一行逐条收集信息并对数据逐行进行操作，从而降低系统开销和潜在的阻隔情况
+ 在SQL Server中游标主要包括游标结果集和游标位置两部分，游标结果集是由定义游标的SELECT语句返回行的集合，游标位置则是指向这个结果集中的某一行的指针
+ 游标的特点
  - 游标返回一个完整的结果集，但允许程序设计语言只调用集合中的一行
  - 允许定位在结果集的特定行
  - 从结果集的当前位置检索一行或多行
  - 支持对结果集中当前位置的行进行数据修改
  - 可以为其他用户对显示在结果集中的数据库数据所做的更改提供不同级别的可见性支持
  - 提供脚本、存储过程和触发器中使用的访问结果集中数据的SQL语句
+ 声明游标语法
  DECLARE cursor_name CURSOR
  [ LOCAL | GLOBAL ]
  [ FORWARD_ONLY | SCROOL ]
  [ STATIC | KEYSET | DYNAMIC | FAST_FORWARD ]
  [ READ_ONLY | SCROLL_LOCKS | OPTIMISTIC ]
  [ TYPE_WARNING ]
  FOR select_statement
  [ FOR UPDATE [ OF column_name [,...n] ] ]
  
  DECLARE Tea_cursor CURSOR
  FOR SELECT * FROM 教师信息表
+ 打卡游标
  - 使用游标之前必须先打开游标，语法如下
    OPEN { { [ GLOBAL ] cursor_name } | cursor_variable_name }
    如果正在引用由GLOBAL关键字声明的游标，则必须使用GLOBAL关键字，可以直接使用游标的名称，也可以使用游标变量的名称，这里提到的游标变量用DECLARE语句声明，并且有SET语句设置成等于游标
  - 一旦打开了游标，就可以用@@CURSOR_ROWS全局变量检索游标中的行数，但要注意的是，在某些条件下@@CURSOR_ROWS并不反映游标中的实际行数
    例如
    OPEN Tea_cursor
+ 检索游标
  - 打开游标以后，就可以提取数据，FETCH语句就是用来从游标中将数据检索出来
    FETCH
    [ [ NEXT | PRIOR | FIRST | LAST
    | ABSOLUTE { n | @nvar }
    | RELATIVE { n | @nvar }
    ]
    FROM
    ]
    { { [ GLOBAL ] cursor_name } | @cursor_variable_name }
    [ INTO @variable_name [,...n]]
  - 游标是带一个指针的记录集，其中指针指向记录集中的某一条特定记录
    FETCH NEXT FROM Tea_cursor
    WHILE @@FETCH_STATUS = 0
    BEGIN
      FETCH NEXT FROM Tea_cursor
    END
    上述语句中的@@FETCH_STATUS全局变量保存的是FETCH操作的结束信息，如果其值为零，则表示有记录检索成功，如果值不为零，则FETCH语句由于某种原因而操作失败
+ 关闭游标
  - 打开游标以后，SQL Server会专门为游标开辟一定的内存以存放游标操作的数据结果集，同时游标的使用也会根据具体情况对某些数据进行封锁，所以在不使用游标的时候，一定要关闭游标释放内存
  - 语法
    CLOSE { { [ GLOBAL ] cursor_name } | @cursor_variable_name }
    CLOSE Tea_cursor
+ 释放游标
  - 游标结构本身也会占用一定的计算机资源，使用完成后，应该将游标释放
  - 语法
    DEALLOCATE { { [ GLOBAL ] cursor_name } | @cursor_variable_name }
    DEALLOCATE Tea_cursor
* 存储过程(Stored Procedure)
** 概述
+ 存储过程是一组为了完成特定功能的SQL语句集，经编译后存储在数据库中，存储过程可以包含程序流、逻辑及对数据库的查询，可以接受参数、输出参数、返回单个或多个结果集及返回值
+ 在SQL Server中可以使用Transact-SQL语言编写存储过程，也可以使用CLR方式编写存储过程
+ 有多种可用的存储过程
  1. 用户定义的存储过程
     - 是指封装了可重用代码的模块或者例程
     - Transact-SQL存储过程是指保存的Transact-SQL语句集合，可以接受和返回用户提供的参数
     - CLR存储过程
  2. 扩展存储过程
     - 扩展存储过程允许使用编程语言(例如C)创建自己的外部例程，扩展存储过程是指SQL Server的实例可以动态加载和运行的DLL
  3. 系统存储过程
     - SQL Server中许多管理活动都是通过执行一种特殊的存储过程完成的，称为系统存储过程
** 特点
+ 接受输入参数并以输出参数的格式向调用过程或者批处理返回多个值
+ 包含用于在数据库中执行操作(包括调用其他过程)的编程语句
+ 向调用过程或者批处理返回状态值，以指明成功或者失败(以及失败的原因)
+ 使用EXECUTE语句来运行存储过程，存储过程与函数不同，存储过程不返回取代其名称的值，也不能直接在表达式中使用
+ 存储过程与其他应用程序共享应用程序逻辑，因而确保了数据访问和修改的一致性，存储过程可以封装业务功能，在存储过程中可以在同一位置改变封装的业务规则和策略，所有的客户端可以使用相同的存储过程来确保数据访问和修改的一致性
+ 存储过程具有安全性和所有权链接，以及可以附加到它们的证书中，用户可以被授予权限来执行存储过程而不必直接对存储过程中引用的对象具有权限
+ 存储过程提供了安全机制，即使是没有访问存储过程引用的表或视图的权限的用户，也可以被授权执行该存储过程
+ 存储过程允许模块化程序设计，存储过程一旦创建，以后即可在程序中调用任意次，可以改进应用程序的可维护性，并允许应用程序统一访问数据库
+ 存储过程可以减少网络通信流量，用户可以通过发送一个单独的语句实现一个复杂的操作，而不需要在网络上发送几百个SQL代码
+ SQL Server可以将存储过程标记为autostart，如果需要定期执行维护任务或者有一个将会一直运行的后台守护进程，并希望该存储过程在所有时间都处于运行状态，这种方法非常有用
+ 自动执行存储过程的另一个用处是在tempdb中分配权限，可以使用自动执行存储过程来创建全局临时表，然后使用WAITFOR无限期休眠，将确保这个临时表始终存在，因为调用处理是第一个执行的，而且从不停止
** 设计存储过程
*** 创建存储过程的规则
+ CREATE PROCEDURE定义自身可以包括任意数量和类型的SQL语句，但有些语句不能用于存储过程，如下：
  CREATE AGGREGATE
  CREATE DEFAULT
  CREATE 或者 ALTER FUNCTION
  CREATE 或者 ALTER PROCEDURE
  SET PARSEONLY
  SET SHOWPLAN_TEXT
  USE Database_name
  CREATE RULE
  CREATE SCHEMA
  CREATE 或者 ALTER TRIGGRE
  CREATE 或者 ALTER VIEW
  SET SHOWPLAN_ALL
  SET SHOWPLAN_XML
+ 可以引用在同一存储过程中创建的对象，只要引用时已经创建了该对象即可
+ 可以在存储过程内引用临时表
+ 如果在存储过程内创建本地临时表，则临时表仅为该存储过程而存在，退出该存储过程后，临时表将消失
+ 如果执行的存储过程将调用另一个存储过程，则被调用的存储过程可以访问由第一个存储过程创建的所有对象，包括临时表
+ 如果执行对远程SQL Server实例进行更改的远程存储过程，则不能回滚这些更改，远程存储过程不参与事务处理
+ 存储过程中的参数的最大数目为2100
+ 存储过程中的局部变量的最大数目仅受可用内存的限制
+ 根据可用内存的不同，存储过程最大可达128MB
*** 限定存储过程内的名称
+ 在存储过程内，如果用于语句(例如SELECT或者INSERT)的对象名没有限定架构，则架构将默认为该存储过程的架构
+ 在存储过程内，如果创建该存储过程的用户没有限定SELECE、INSERT、UPDATE或者DELETE语句中引用的表名或者视图名，则默认情况下，通过该存储过程对这些表进行的访问将受到该过程创建者的权限的限制
+ 如果有其他用户要使用存储过程，则用于所有数据定义语言(DDL)语句(例如CREATE、ALTER、DROP、DBCC、EXECUTE和动态SQL语句)的对象名应该用该对象架构名称来限定，为这些对象指定架构名称可以确保名称解析为同一对象，而不管存储过程的调用方是谁，如果没有指定架构名称，SQL Server将首先尝试使用调用方的默认架构或者用户在EXECUTE AS子句中指定的架构来解析对象名称，然后尝试使用dbo架构
*** 加密存储过程的定义
+ 如果要创建存储过程，并且希望确保其他用户无法查看该过程的定义，则可以使用WITH ENCRYPION子句，过程定义将以不可读的形式存储，存储过程一旦被加密，其定义将无法解密，任何人包括存储过程的所有者或者系统管理员都将无法查看该存储过程的定义
*** SET语句选项
+ 当创建或更改存储过程后，数据库将保存SET QUOTED_IDENTIFIER和SET ANSI_NULLS的设置，执行存储过程时，将使用这些原始设置，因此在执行存储过程时，将忽略任何客服端会话的SET QUOTED_IDENTIFIER和SET ANSI_NULLS的设置，在存储过程中出现的SET QUOTED_IDENTIFIER和SET ANSI_NULLS语句不影响存储过程的功能
+ 其他SET选项(例如SET ARITHABORT、SET ANSI_WARNINGS、SET ANSI_PADDINGS)在创建或更改存储过程后不保存，如果存储过程的逻辑取决于特定的设置，应在该过程开头添加SET语句，以确保设置正确，从存储过程中执行SET语句时，该设置只在存储过程完成之前有效，之后，该设置将还原为它在调用存储过程时的值
** 使用存储过程
*** 创建存储过程
+ 必须具有CREATE PROCEDURE权限才能使用CREATE PROCEDURE语句创建存储过程，存储过程是架构作用域中的对象，只能在本地数据库中创建存储过程，应该指定所有的输入参数、执行数据库操作的语句、返回至调用过程或者批处理时表示成功或者失败的状态值，捕获和处理潜在错误时错误处理语句等
+ 语法
  CREATE PROC[EDURE] procedure_name [;number]
  [{@parameter data_type}]
  [VARYING][=default][OUTPUT][,...n]
  [WITH {RECOMPILE | ENCRYPTION| RECOMPILE,ENCRYPTION}]
  [FOR REPLICATION]
  AS sql_statement[...n]
  - procedure_name 
    新存储过程的名称，过程名称在架构中必须是唯一的，可在procedure_name前面使用一个数字符号(#)来创建局部临时过程，使用两个井号(##)创建全局临时过程，对于CLR存储过程，不能指定临时名称
  - ;number
    是可选的整数，用来对同名的过程分组，使用一个DROP PROCEDURE语句可将这些分组过程一起删除
  - @parameter
    过程中的参数，可以声明一个或多个参数，除非定义了参数的默认值或者将参数设置为等于另一个参数，否则用户必须在调用过程时为每个声明的参数提供值，如果指定FOR REPLICATION,则无法声明参数
  - data_type
    参数的数据类型，所有数据类型均可以用作存储过程的参数，不过cursor数据类型只能用于OUTPUT参数，如果指定的数据类型为cursor，则必须同时指定VARYING和OUTPUT关键字，对于CLR存储过程，不能指定char、varchar、text、ntext、image、cursor和table作为参数
  - VARYING
    指定作为输出参数支持的结果集(有存储过程动态构造，内容可以变化)，仅适用于游标参数
  - default
    参数的默认值，如果定义default值，则无需指定此参数的值即可执行过程，默认值必须是常量或NULL，如果过程使用带like关键字的参数，则可包含下列通配符：% _ [] [^]
  - OUTPUT
    指示参数是输出参数，此选项的值可以返回给调用EXECUTE的语句，除非是CLR过程，否则text、ntext和image参数不能用作OUTPUT参数，OUTPUT关键字的输出参数可以为游标占位符，CLR过程除外
  - RECOMPILE
    指示数据库引擎不缓存该过程的计划，该过程在运行时编译，如果指定了FOR REPLICATION，则不能使用此选项
  - ENCRYPTION
    加密syscomments表中包含CREATE PROCEDURE语句文本的条目
  - FOR REPLICATION
    指定不能在订阅服务器上执行为复制创建的存储过程，如果指定了FOR REPLICATION，则无法声明参数，对于CLR存储过程，不能指定FOR REPLICATION
+ 示例
  CREATE PROCEDURE Pro_学生信息
  AS 
    SELECT 学号,姓名,班级编号,籍贯
    FROM 学生信息
    WHERE 籍贯='湖南'
    ORDER BY 学号
*** 使用存储过程参数
+ 存储过程的优势不仅在于存储在服务器端、运行速度快，还有重要的一点就是存储过程可以完成的功能非常强大，可以使用输入参数、输出参数、默认值
**** 参数的定义
+ 存储过程可以使用两种类型的参数：输入参数和输出参数，参数用于在存储过程和应用程序之间的数据交换
+ 输入参数允许用户将数据值传递到存储过程或函数
+ 输出参数允许存储过程将数据值或游标变量传递给用户
+ 每个存储过程向用户返回一个整数代码，如果存储过程没有显示设置返回代码的值，则返回代码为零
+ 存储过程的参数在创建时应在CREATE PRODURCE和AS关键字之间定义，每个参数都要指定参数名和数据类型，参数名必须以@为前缀，可以为参数指定默认值；如果是输出参数，则使用OUTPUT关键字描述，各个参数定义之间用逗号隔开
  @parameter_name data_type [=default] [OUTPUT]
**** 输入参数
+ 输入参数，即指在存储过程中有一个条件，在执行存储过程时为这个条件指定值，通过存储过程返回相应的信息
+ 使用输入参数可以向同一存储过程多次查找数据库
+ 示例
  USE 教务管理系统
  GO
  CREATE PROCEDURE Pro_学生_性别_信息
  @性别 NVARCHAR(10)
  AS
    SELECT 学号,姓名,性别,籍贯,B.班级名称,B.班主任
    FROM 学生信息 A,班级信息 B
    WHERE A.班级编号=B.班级编号
    AND 班级名称='计算机02'
    AND A.性别=@性别
  GO
+ SQL Server提供了两种传递参数的方式
  1. 按位置传递
     这种方式是在执行存储过程的语句中，直接给出参数的值，当有多个参数时，给出的参数的顺序与创建存储过程的语句中的参数顺序一致，即参数传递的顺序就是参数定义的顺序
     EXEC Pro_学生_性别_信息 '女'
  2. 通过参数名传递
     这种方式使用参数名=参数值的形式给出参数值，通过参数名传递参数的好处是，参数可以不注意顺序
     EXEC Pro_学生_性别_信息 @性别='女'
+ 使用默认参数值
  创建存储过程时，如果参数为设定默认值，则在调用时不指定参数，系统会报错；如果希望不给出参数值时也能正常运行，则可以给参数设置默认值来实现
  USE 教务管理系统
  GO
  CREATE PROCEDURE Pro_学生_性别_信息
  @性别 NVARCHAR(10)='男'
  AS
    SELECT 学号,姓名,性别,籍贯,B.班级名称,B.班主任
    FROM 学生信息 A,班级信息 B
    WHERE A.班级编号=B.班级编号
    AND 班级名称='计算机02'
    AND A.性别=@性别
  GO
**** 输出参数
+ 通过定义输出参数，可以从存储过程中返回一个或多个值，为了使用输出参数，必须在CREATE PROCEDURE语句和EXECUTE语句中指定关键字OUTPUT，在执行存储过程时，如果忽略OUTPUT关键字，存储过程仍然会执行单不返回值
+ 示例
  USE 教务管理系统
  GO
  CREATE PROCEDURE Pro_GetTeacherName
  @学生名称 nvarchar(20)='徐红'
  @班主任 nvarchar(20) OUTPUT
  AS
    SELECT @班主任=B.班主任
    FROM 信息信息 A,班级信息 B
    WHERE A.班级编号=B.班级编号
    AND A.姓名=@学生姓名
  GO
+ 为了接收存储过程的返回值，需要一个变量来重复返回参数的值，在调用存储过程的语句中，必须为这个变量加上OUTPUT关键字来声明
  DECLARE @Name NVARCHAR(20)
  EXEC Pro_GetTeachreName '于丽',@Name OUTPUT
  SELECT '于丽的班主任是：'+@Name AS '结果'
  GO
+ 除非是CLR过程，否则text、ntext、image参数不能用作OUTPUT参数，使用OUTPUT关键字的输出参数可以为游标占位符，CLR过程除外，不能将用户定义表类型指定为存储过程的OUTPUT参数
**** 执行存储过程
+ 使用EXECUTE语句执行存储过程，可以简写为EXEC，参数值放在存储过程名称的后面
***** 通过存储过程自身执行存储过程
+ 可以通过调用带有存储过程名和任意参数的EXECUTE语句执行一个存储过程
+ 语法
  [EXEC[USE]]
  {
  [@return_status=]
  {procedure_name[;number] | @procedure_name_var}
  [[@parameter=]{value | @variable[OUTPUT] | [DEFAULT]}]
  [,...n]
  [WITH RECOMPILE]
  }
+ 直接方式
+ 间接方式
***** 在INSERT语句中执行存储过程
+ 示例
  INSERT INTO 学生籍贯信息
  EXEC Pro_添加学生信息
***** 通过存储过程右键菜单执行
**** 管理存储过程
***** 修改存储过程
+ 使用ALTER PROCEDURE语句修改现有的存储过程与删除和重建存储过程不同，它仍保持存储过程的权限不发生变化
+ 语法
  ALTER PROCEDURE procedure_name[;number]
  .....
+ 注意事项
  - 如果要修改具有任何选项的存储过程，例如WITH ENCRYPTION选项，必须在ALTER PROCEDURE语句中包括该选项以保留该选项提供的功能
  - ALTER PROCEDURE语句只能修改一个单一的过程，如果过程调用到其他存储过程嵌套的存储过程不受影响
  - 默认状态下，允许该语句的执行者是存储过程最初的创建者，sysadmin服务器角色成员和db_owner与db_ddladmin固定的数据库角色成员，用户不能授权执行ALTER PROCEDURE语句
  - 建议不要直接修改系统存储过程，相反，可以通过从现有的存储过程中复制语句来创建用户定义的系统存储过程，然后修改它满足要求
***** 删除存储过程
+ 使用DROP PROCEDURE语句从当前数据库中删除用户定义的存储过程
+ 语法
  DROP PROCEDURE{procedure}[,...n]
+ 如果另一个存储过程调用某个已经被删除的存储过程，系统将报错，但如果定义了具有相同名称和参数的新存储过程来替换一被删除的存储过程，那么将可以顺利执行
+ 在删除存储过程前，先执行sp_depends存储过程来确定是否有对象依赖于此存储过程
***** 查看存储过程
+ 查看存储过程的定义信息，可以使用sys.dql_modules目录视图、OBJECT_DEFININTION元数据函数、sp_helptext系统存储过程等
+ 如果创建存储过程中使用了WITH ENCRYTION子句，将隐藏存储过程定义文本的信息
+ 使用sys.objects、sys.procedure、sys.parameters、sys.numbered_procedures等目录视图可以查看有关存储过程的名称、参数等信息
* 触发器(Trigger)
** 定义
+ 触发器是一种特殊的存储过程，它与表紧密相连，可以看作是表定义的一部分，当用户修改指定表或视图中的数据时，触发器将会自动执行
+ 触发器基于一个表创建，但是可以针对多个表进行操作，可以用来对表实施复杂的完整性约束，当触发器所保存的数据发生改变时，触发器被自动激活，从而防止对数据的不正确修改
+ 触发器优点
  1. 自动执行，在表的数据做了任何修改(比如手工输入或使用程序采集的操作)之后立即激活
  2. 可以通过数据库中的相关表进行层叠更改，这比直接把代码写在前台的做法更安全合理
  3. 可以强制限制，这些限制比用CHECK约束所定义的更复杂，与CHECK约束不同的是，触发器可以引用其他表中的列
+ 触发器的执行环境
  - 每当调用触发器时，就创建触发器的执行环境，如果调用多个触发器，就会分别为每个触发器创建执行环境，然鹅，在任何时候，一个会话只有唯一的一个执行环境是活动的，一个表的触发器可能引起第二个表的触发器激活
** 分类
+ DDL触发器
  如果要执行以下操作，可以使用DDL触发器
  - 要防止对数据库架构进行某些更改
  - 希望数据库中发生某种情况以响应数据库架构中的更改
  - 要记录数据库架构中的更改或事件
+ DML触发器
  - INSERT触发器
  - UPDATE触发器
  - DELETE触发器
  - DML触发器在以下方面非常有用
    1. 通过数据库中的相关表实现级联更改，不过，通过级联引用完整性约束可以更有效地进行这些更改
    2. 防止恶意或错误的INSERT UPDATE DELETE操作，并强制执行比CHECK约束更为复杂的其他限制
    3. 评估数据修改前后表的状态，并根据该差异采取措施
    4. 一个表中的多个同类DML触发器允许采取多个不同的操作来响应同一个修改语句
    5. SQL Server为每个触发器语句创建两种特殊的表：DELETED表和INSERTED表，这是两个逻辑表，由系统来自创建和维护，用户不能对它们进行修改，它们存放在内存而不是数据库中，这两个表的结构总是与被该触发器作用的表的结构相同，触发器执行完成后，与该触发器相关的这两个表也会被删除；DELETED表存放由执行DELETE或UPDATE语句而要从表中删除的所有行，在执行DELETE或UPDATE操作时，被删除的行从触发触发器的表中被移动到DELETED表中；INSERTED表存放由执行INSERT或UPDATE语句而要向表中插入的所有行，在执行INSERT或UPDATE操作时，新的行同时添加到触发触发器的表和INSERTED表中，INSERTED表的内容是触发触发器表中新行的副本
** 创建触发器
*** DML触发器
+ DML触发器用于在数据被修改时强制执行业务规则，以及扩展约束、默认值和规则的完整性检查逻辑
+ 创建DML触发器制定的内容
  - 名称
  - 所基于的表或视图
  - 激活时机
  - 激活触发器的操作语句，有效选项是INSERT、UPDATE、DELETE
  - 触发器执行的语句
+ 语法
  CREATE TRIGGER trigger_name
  ON { table | view }
  {
    { { FOR | AFTER | INSTEAD OF }
      { [DELETE] [,] [INSERT] [,] [UPDATE] }
        AS
          sql_statement
    }
  }
+ INSERT触发器
  - 当对目标表(触发器的基表)执行INSERT语句时调用的触发器
  - 示例：当[学生信息]表添加一条学生信息时，同时更新[班级信息]表中的"人数"列
    USE 教务管理系统
    GO
    CREATE TRIGGER Trig_更新班级人数
    ON 学生信息
    AFTER INSERT
    AS
      UPDATE 班级信息 SET 人数=人数+1
      WHERE 班级编号 IN (SELECT 班级编号 FROM inserted)
    GO
+ DELETE触发器
  - 当运行DELETE语句时，会激活DELETE触发器，用于约束用户能够从数据库中删除的数据，有些数据不希望能被用户轻易删除
  - 注意事项
    1. 当某行被添加到deleted表中时，就不再存在于数据库表中，因此deleted表和数据库表没有相同的行
    2. 创建deleted表时，空间从内存中分配，deleted临时表总是被存储在高速缓存中
    3. 为DELETE动作定义的触发器并不执行TRUNCATE TABLE语句，原因在于日志不记录TRUNCATE TABLE语句
  - 示例
    USE 教务管理系统
    GO
    CREATE TRIGGER Trig_删除教师信息
    ON 教师信息
    AFTER DELETE
    AS
      SELECT 教师编号,姓名 AS 被删除教师的姓名,年龄,家庭住址,电话 FROM deleted
    GO
+ UPDATE触发器
  - 当UPDATE语句在目标表上运行时，会调用UPDATE触发器，这类触发器专门用于约束用户能修改的现有数据
  - 可以将UPDATE语句看作两步操作：捕获数据当前像的DELETE语句和捕获数据后像的INSERT语句，当激活触发器时，原始行(前像)被移入到临时表deleted表，更新行(后像)被移入到临时表inserted表中
  - 触发器检查deleted表和inserted表以及被更新的表，来确定是否更新了多行及如何执行触发器动作
  - 可以使用IF UPDATE语句定义一个监视指定列数据更新的触发器，可以让触发器容易隔离出特定列的活动，当他检测到指定列已经更新时，触发器会进一步执行适当的动作
  - 示例：当[学生籍贯信息]表中一个学生的籍贯信息发生变更时，同时更新[学生信息]表中的相应学生的籍贯信息
    CREATE TRIGGER Trig_更新籍贯
    ON 学生籍贯信息
    FOR UPDATE
    AS
    IF UPDATE(籍贯)
      BEGIN
        UPDATE 学生信息
        SET 籍贯=(SELECT 籍贯 FROM inserted)
        WHERE 籍贯=(SELECT 籍贯 FROM deleted)
      END
  - 示例：某列不允许被修改
    CREATE TRIGGER Trig_修改课程信息
    ON 课程信息
    FOR UPDATE
    AS
    IF UPDATE(课程名称)
      BEGIN
        RAISERROR('该事务不能被处理，[课程名称]列的值不能被改变',10,1)
        ROLLBACK TRANSACTION
      END
+ 创建INSTEAD OF触发器
  - 可以在表或视图上指定INSTEAD OF触发器，可以指定执行触发器而不是执行触发SQL语句，从而屏蔽原来的SQL语句，而转向执行触发器内部的SQL语句，对于每一种触发动作(INSERT、UPDATE、DELETE)，每一个表或视图只能有一个INSTEAD OF触发器
  - 此触发器的主要优点是可以使不能更新的视图支持更新，基于多个基表的视图必须使用INSTEAD OF触发器来支持引用多个表中数据的插入、更新和删除操作
  - 另一个优点是可以编写这样的逻辑代码：在允许批处理的其他部分成功的同时拒绝批处理的某些部分，例如，通常不能在一个基于连接的视图上进行DELETE操作，但可以编写一个INSTEAD OF DELETE触发器来实现删除
  - 示例：创建一个用于替代DELETE语句的INSTEAD OF DELETE触发器，用于实现删除[学生信息]表中的一个人员时，级联删除该人员对应的[学生籍贯信息]表中的内容，默认情况下，[学生信息]和[学生籍贯]在"学号"列上存在外键约束，因此不允许直接删除[学生信息]表中的内容
    CREATE TRIGGER Trig_DELETE
    ON 学生信息
    INSTEAD OF DELETE
    AS
    BEGIN
      DELETE 学生籍贯信息 WHERE 学号 IN (SELECT 学号 FROM deleted)
      DELETE 学生信息 WHERE 学号 IN (SELECT 学号 FROM deleted)
    END
*** DDL触发器
+ DDL触发器响应CREATE、ALTER、DROP语句，基本语法如下
  CREATE TRIGGER trigger_name
  ON { ALL SERVER | DATABASE }
  WITH ENCRYPTION
  { FOR | AFTER | event_type }
  AS sql_statement
+ 如果想要控制哪个用户可以修改数据库结构及如何修改，甚至只想跟踪数据库结构上发生的修改，则DDL触发器非常适合，对重要的数据库，内部的结构及其数据都很重要，是不能轻易删除或改变的，即便要改动也要在改动之前做好备份，以免丢失重要的数据，就可以创建一个DDL触发器来防止此情况的发生
+ 示例
  CREATE TRIGGER Trig_DDL教务信息
  ON DATABASE
  FOR DROP_TABLE,ALTER_TABLE
  AS
  BEGIN
    PRINT '不能删除或修改当前数据库的内容'
    ROLLBACK
  END
*** 嵌套触发器
+ 如果触发器的执行操作时引发了另一个触发器，而这个触发器又接着引发下一个触发器，就形成了嵌套触发器，任何触发器都可以包含影响另一个表的UPDATE、INSERT、DELETE语句，嵌套触发器在安装时就被占用，但可以使用sp_configure系统存储过程禁用和重新启用嵌套
+ DML触发器和DDL触发器最多可以嵌套32层，可以通过nested triggers服务器配置选项来控制是否可以嵌套AFTER触发器，但不管此设置如何，都可以嵌套INSTEAD OF触发器(只有DML触发器可以为INSTEAD OF触发器)，如果嵌套链中的任何触发器建立了无穷循环，则超过最大嵌套层数，该触发器将被终止，回滚整个事务
+ 注意事项
  - 默认嵌套触发器配置选项开启
  - 在同一个触发器事务中，一个嵌套触发器不能被触发两次
  - 触发器是一个事务，如果一系列嵌套触发器的任何层中发生错误，整个事务都将取消，所有数据修改将回滚
  - 可以使用@@NESTLEVEL函数来查看当前的嵌套层数
  - 嵌套触发器是用来保证整个数据库完整性的重要功能，但有时候可能需要禁用嵌套功能，嵌套触发器要求复杂而又有条理的设计，级联修改可能会修改用户不想涉及的数据，在用户要以特定的顺序更新表时，可能出现问题
  - 设置嵌套功能开关
    禁用 EXEC sp_configure 'nested triggers',0
    开启 EXEC sp_configure 'nested triggers',1 
*** 递归触发器
+ 如果启用递归触发器选项，那么改变表中数据的触发器，通过递归执行可以再次触发自己
+ 默认递归触发器选项是禁用的
*** 管理触发器
+ 修改触发器
  1. 删除原来的触发器，再创建与之同名的触发器
  2. 直接修改
     ALTER TRIGGER Trig_name
+ 禁用(启用)触发器
  DISABLE(ENABLE) TRIGGER Trig_name
+ 删除触发器
  DROP TRIGGER Trig_name
* 架构
** 概述
+ 架构是对象的容器，用于在数据库内定义对象的命名空间，用于简化管理和创建可以共同管理的对象子集
+ 架构与用户分离，用户拥有架构，并且当服务器在查询中解析非限定对象时，总是有一个默认的架构供服务器使用，这意味着访问默认架构中的对象时，不需要指定架构名称
+ 要访问其他架构中的对象时，需要两部分或者三部分的标识符标识符，两部分标识符指定架构名称和对象名称，格式为schema_name.object_name；三部分的标识符指定数据库名称、架构名称和对象名称database_name.schema_name.object_name
+ 架构优点
  - 用户不再是对象的直接所有者，从数据库中删除用户是非常简单的任务，不再需要在删除创建对象的用户之前重命名对象
  - 多个角色可以通过在角色或Windows组中的成员资格来拥有单个架构，使得管理表、视图和其他数据库定义的对象变得简单
  - 多个用户可以共享单个默认架构，这样就使授权访问共享对象变得更加容易
** 创建架构
+ 在创建表之前，应该谨慎考虑架构的名称，最长128个字符，在数据库中必须是唯一的
+ GUI创建架构
  - [服务器][数据库][具体数据库][安全性]-右键[架构][新建架构]
+ SQL命令
  - 语法
    CREATE SCHEMA schema_name_clause [ <schema_element> [...n] ]
    <schema_name_clause>::=
        {
          schema_name
          | AUTHORIZATION owner_name
          | schema_name AUTHORIZATION owner_name
        }
    <schema_element>::=
        {
            table_definition | view_definition | grant_statement
            revoke_statement | deny_statement
        }
        
  - AUTHORIZATION owner_name
    指定拥有架构的数据库级主体的名，此主体可以拥有其他架构，并且可以不使用当前架构作为其默认架构
** 修改架构
** 移动对象到新的架构
+ 只有在同一数据库内的对象才可以从一个架构移动到另一个架构，移动对象到一个新的架构会更改与对象相关联的命名空间，也会更改对象查询和访问的方式
+ 移动对象到新的架构也会影响对象的权限，所有对象上的权限都会被删除，如果对象的所有者设置为特定的用户或角色，则继续成为对象的所有者，如果对象的所有者设置为SCHEMA OWNER，所有权仍然为SCHEMA OWNER所有，移动后，所有者将变成新架构的所有者
+ 要在架构之间移动对象，必须拥有对对象的CONTROL权限及对对象的目标架构的ALTER权限，如果对象上有EXECUTE AS OWNER(以所有者执行)的具体要求，并且所有者设置为SCHEMA OWNER，则必须也拥有对目标架构的所有者的INPERSONATION权限
** 删除架构
+ 删除架构必须在架构上拥有CONTROL的权限，且删除之前，需要移动或删除该架构下的所有对象，否则删除操作会失败
* 视图
** 概述
+ 查看多表中的数据一般可以使用子查询或连接来完成，另一种方式就是使用视图
+ 视图是原始数据库中数据的一种变换，是查看表中数据的另一种方式，是根据预定义的查询建立起来的一个表，是一种逻辑对象，从一个或几个基本表中导出的表，是一种虚拟表
+ 视图是把其定义存放在系统数据中，不直接存储视图对应的数据，直到用户使用视图时才去查找对应的数据
+ 视图中被查询的表称为视图的基表，可以把视图当作表来引用，视图结合了基表和查询两者的特性
+ 视图的内容可以包括以下几个方面
  - 基表中列的子集或行的子集：视图可以是基表的一部分
  - 两个或多个基表的联合：视图是多个基表联合检索的产物
  - 两个或多个基表的连接：视图通过对多个基本的连接生成
  - 基表的统计汇总：视图不仅是基表的映射，还可以是通过对基本的各种复杂运算得到的结果集
  - 其他视图的子集：视图即可以基于表，也可以基于其他视图
  - 视图和基表的混合：视图和基表可以起到同样查看数据的作用
+ 视图的优点
  - 数据集中显示，视图着重于用户感兴趣的某些特定数据及所负责的特定任务，可以提高数据操作效率
  - 简化对数据的操作，在对数据库进行操作时，用户可以将经常使用的连接、投影、联合查询等定义为视图，不必每次重写查询语句
  - 自定义数据，视图可以让不同的用户以不同的方式看到不同或相同的数据集
  - 导出和导入数据，用户可以使用视图将数据导出至其他应用程序
  - 合并分割数据，某些情况下，由于表的数据量太大，在表的设计过程中可能需要经常对表进行水平分割或垂直分割，表的这种变化会对使用它的应用程序产生较大的影响，使用视图则可以重新保持原有的结构关系，从而使外模式保持不变，应用程序仍可以通过视图来重载数据
  - 安全机制，通过视图可以限定用户查询权限，使部分用户只能查看和修改特定的数据
+ 视图可以使应用程序和数据库表在一定程度上独立，程序可以建立在视图之上，从而程序与数据库表被视图分隔开来
  - 如果应用程序建立在数据库表上，当数据库表发生变化时，可以在表上建立视图，屏蔽表的变化，从而应用程序可以不动
  - 如果应用程序建立在数据库表上，当应用程序发生变化时，可以在表上建立视图，屏蔽程序的变化，从而使数据库表不动
  - 如果应用程序建立在视图上，当数据库表发生变化时，可以修改视图，屏蔽表的变化，使应用程序不动
  - 如果应用程序建立在视图上，当应用程序变化时，可以在表上修改视图，屏蔽应用程序的变化，数据库可以不动
** 创建视图
*** GUI工具
*** SQL语句
+ 语法
  CREATE VIEW view_name(view_column_name)
  AS query_expression
  [WITH CHECK OPTION]
+ 示例
  CREATE VIEW view_学生籍贯
  AS
  SELECT 学号,姓名,性别,籍贯
  FROM 学生信息
** 视图修改数据
+ 视图不仅可以查询数据，还可以修改数据，使用视图修改数据本质上是对基表中数据的修改
+ 在使用CREATE VIEW语句中包含以下内容时，视图中的数据时不允许修改的
  - SELECT列表中含有DISTINCT
  - SELECT列表中含有表达式，如计算列、函数等
  - 在FROM子句中引用多个表
  - 引用不可更新的视图
  - GROUP BY或HAVING子句
*** 插入数据
+ 向视图插入数据不同于基表，有如下限制条件
  - 视图中没有包含基表中所有属性为NOT NULL的列，会失败
  - 不能含有统计函数的结果或多个列值的组合
  - 不能在使用了DISTINCT、GROUP BY或HAVING的语句的视图中插入数据
*** 更新数据
*** 删除数据
* 索引
** 概述
+ 索引是一个单独的、物理的数据库结构，它是某个表中一列或若干列的集合和相应的指向表中物理标识这些值的数据页的逻辑指针清单
+ 索引的建立依赖于表，它提供了数据库中编排表中数据的内部方法，一个表的存储有两部分组成，一部分用来存放表的数据页面，另一部分存放索引页面，通常索引页面相对数据页面小得多，当进行数据检索时，系统先搜索索引页面，从中找到所需数据的指针，再通过指针从数据页面中读取数据
+ 索引一旦创建，由数据库自动管理和维护，在向表中插入、更新或删除记录是，数据库会自动在索引中做出相应的修改
+ 利用索引进行检索数据具有以下优点
  - 保证数据的唯一性，唯一性索引的创建可以保证表中数据不重复
  - 加快数据检索速度，具有索引的列几乎可以立即响应查询，未创建索引的列在查询时需要等待很长的时间，因为数据库会按照表的顺序逐行进行搜索
  - 加快表之间的连接速度
  - 使用ORDER BY和GROUP BY子句中进行检索数据时，显著减少查询中分组和排序的时间
+ 注意避免在一个表上创建大量的索引，否则不但会影响插入、删除、更新数据的性能，也会在表中数据更改时，增加要所有索引进行调整的操作，降低系统的维护速度
+ 在SQL Server2008中，将表和索引分别存储在不同的文件组，会大大提高操作数据的速度
** 聚集索引
+ 在SQL Server中，索引按B-Tree树结构进行组织，一个表只能包含一个聚集索引，聚集索引查找数据几乎总是比非聚集索引快，聚集索引需要至少相当于该表120%的附加空间，以存放该表的副本和索引中间页
+ 实现方式
  1. PRIMARY KEY和UNIQUE约束
     - 创建PRIMARY KEY约束时，如果不存在该表的聚集索引且未指定唯一非聚集索引，则将自动对一列或多列创建唯一聚集索引主键列不允许为空值
     - 创建UNIQUE约束时，默认情况下将创建唯一非聚集索引，以便强制UNIQUE约束，如果不存在该表的聚集索引，可以指定唯一聚集索引，将索引创建为约束的一部分后，会自动将索引命名为与约束名称相同的名称
  2. 独立于约束的索引
     该索引指定非聚集主键约束后，可以对非主键的列创建聚集索引
  3. 索引视图
     可以对一个或多个视图列定义唯一聚集索引
** 非聚集索引
+ 有没有非聚集索引搜索都不影响数据页的组织，每个表可以有多个非聚集索引
+ 非聚集索引可以提高从表中查询数据的速度，但也会降低向表中插入和更新数据的速度
+ 当用户改变了一个建立了非聚集索引的表的数据时，必须同时更新索引，如果一个表需要频繁更新数据，就不要对它建立太多的非聚集索引，如果硬盘盒内存空间有限，也应限制使用非聚集索引的数量
+ 实现方式
  1. PRIMARY KEY和UNIQUE约束
  2. 独立于约束的索引
  3. 索引视图的非聚集索引
** XML索引
** 确定使用索引的列(要合理使用)
+ 索引的缺点
  - 创建和维护索引要耗费时间
  - 索引需要占用物理空间
  - 对表中数据进行增、删、改时，索引也要动态的维护，降低了数据的维护速度
+ 创建索引的原则
  - 适合创建索引的表或列
    1. 有许多行数据的表
    2. 经常用于查询的列
    3. 有宽范围值且在一个典型的查询中，极有可能被选择的列
    4. 用于聚合函数的列
    5. 用于GROUP BY查询的列
    6. 用于ORDER BY查询的列
    7. 用于表级联的列
  - 不适合创建索引的表或列
    1. 几乎没有数据的表
    2. 很少用于查询的列
    3. 有宽范围值且在一个典型的查询中，不太可能被选择的列
    4. 列的字节数大
    5. 经常修改，但很少用于查询的表
+ 聚集与非聚集索引的使用原则
  - 聚集索引
    1. 被大范围搜索的主键，如账号
    2. 返回大结果集的查询
    3. 用于许多查询的列
    4. 强选择性的列
    5. 用于ORDER BY或者GROUP BY查询的列
    6. 用于级联表的列
  - 非聚集索引
    1. 顺序的标识符的主键，如标识列
    2. 返回小结果集的查询
    3. 用于聚合函数的列
    4. 外键
** 操作索引
*** 创建索引
+ GUI工具
+ SQL语句
  - 语法
    CREATE [UNIQUE] [CLUSTERED] [NONCLUSTERED] INDEX index_name
    ON table_or_view_name (colum [ ASC | DESC ][,...n])
    [INCLUDE (column_name[,...n])]
    [WITH
      (  PAD_INDEX={ON|OFF}
       | FILLFACTOR = fillfactor
       | SORT_IN_TEMPDB = {ON|OFF}
       | IGNORE_DUP_KEY = {ON|OFF}
       | STATISTICS_NORECOMPUTE = {ON|OFF}
       | DROP_EXISTING = {ON|OFF}
       | ONLINE = {ON|OFF}
       | ALLOW_ROW_LOCKS = {ON|OFF}
       | ALLOW_PAGE_LOCKS = {ON|OFF}
       | MAXDOP = max_degree_of_parallelism
      )[,...n]]
    ON {partition_schema_name(column_name) | filegroup_name | default}
*** 管理索引
+ 创建索引之后，由于数据的增、删、改操作后会使索引页出现碎块，为了提高系统的性能，必须对索引进行维护管理
+ GUI工具
+ SQL语句
  1. 修改索引
     - 当数据更改以后，要重新生成索引、重新组织或者禁止索引
     - 语法
       重新生成索引
       ALTER INDEX index_name ON table_or_view REBUILD
       重新组织索引
       ALTER INDEX index_name ON table_or_view REORGANIZE
       禁用索引
       ALTER INDEX index_name ON table_or_view DISABLES
  2. 删除索引
     - 语法
       DROP INDEX <table or view name><index name>
       或者
       DROP INDEX <index name> ON <table or view name>
     - 注意事项
       + 不能使用DROP INDEX语句删除由主键约束或者唯一性约束创建的索引，要删除这些索引，必须先删除约束
       + 删除表时，该表的全部索引都将被删除
       + 当删除一个聚集索引时，该表的全部非聚集索引将重新自动创建
       + 不能在系统表上使用DROP INDEX语句
  3. 查看索引
     索引信息包括索引统计信息和索引碎片信息，通过查询这些信息分析索引性能，可以更好地维护索引
     - 查看索引信息
       sys.indexes    查看索引类型、文件组、分区方案、索引选项等信息
       sys.index_columns    查看列ID、索引内的位置、类型、排列信息
       sys.stats    查看与索引关联的统计信息
       sys.stats_columns    查看与索引关联列的信息
       sys.xml_indexes
       sys.dm_db_index_physical_stats    查看索引大小、碎片统计信息等
       sys.dm_db_index_operational_stats    查看当前索引和表IO统计信息
       sys.dm_db_index_usage_stats 
       INDEXKEY_PROPERTY
       INDEXPROPERTY
       INDEX_COL
     - 查看索引碎片
       GUI工具
     - 查看统计信息
       GUI
*** 使用数据库引擎优化顾问
+ 可以方便创建和选择索引、索引视图和分区的最佳集合，优化顾问分析一个或多个数据库的工作负荷，这种负荷指执行的一组SQL语句
+ 主要功能
  - 通过使用查询优化器分析工作负荷中的查询，推荐数据库的最佳索引组合
  - 为工作负荷中引用的数据库推荐分区
  - 分析建议的更改会产生的影响，包括索引的使用、查询在表之间的分布及查询在工作负荷中的性能
  - 推荐为执行一个小型的问题查询集而对数据库进行优化的方法
  - 允许通过指定磁盘空间约束等高级选项对推荐进行自定义
  - 提供对所给工作负荷的建议执行效果的汇总报告
+ 数据库引擎优化顾问的使用步骤
  - [GUI][工具][数据库引擎优化顾问]
* 事务
** 概述
+ 事务是现代数据库理论的核心概念之一，即用户定义的一个数据库操作序列，这些操作要么全部完成，要么全部取消，是一个不可分割的工作单位，事务是单个的工作单元，是数据库中不可再分的基本部分
+ 事务中一旦发生任何问题，整个事务就会重新开始，数据库返回到事务开始前的状态，事务成功完成的话，便会将操作结果应用到数据库
** ACID属性
+ 在形式上，可以说事务由ACID属性标识，事务是作为单个逻辑工作单元执行的一系列操作，一个逻辑工作单元必须有原子性、一致性、隔离性和持久性(ACID)属性
  1. 原子性
    指当事务结束时，事务内的所有工作在数据库中要么都得到完成，要么都没有得到完成，数据库不能处于事务只有一部分完成的状态
  2. 一致性
    事务完成时，必须使得所有数据库都保持一致状态，在相关数据库中，所有规则都必须应用于事务的修改，事务结束时，所有的内部数据结构(B树索引或双向链表)都必须是正确的
  3. 隔离性
     - 由并发事务所做的修改必须与任何其他并发事务所做的修改隔离，事务识别数据所处的状态，要么是另一个事务修改它之前的状态，要么是修改后的状态，事务不会识别中间状态的数据
     - 由于事务是相互隔离的，如果从数据库的一个崭新副本开始，并按最初执行所有操作的相同顺序再执行™一遍，保证能得到相同的结果，这正是能够从备份与事务日志中还原事务的原因所在
  4. 持久性
     - 一旦完成了事务提交，就变成永久的，事务所完成的工作得到永久保存，如果提交一个事务以后计算机故障，那么重启计算机后，该事务的结果依然是存在的
** 事务分类
*** 系统提供的事务
+ 是指一条语句构成了一个事务，这些语句包括
  - ALTER TABLE
  - CREATE
  - DELETE
  - DROP
  - FETCH
  - GRANT
  - INSERT
  - OPEN
  - REVOKE
  - SELECT
  - UPDATE
  - TRUNCATE TABLE
+ 示例
  UPDATE 教师信息
  SET 籍贯='河北'
  假如表中有1000条数据，则这个事务要么成功的将1000数据的籍贯进行修改，要么一条也不改
*** 用户自定义的事务
+ 在实际应用中，经常使用的是用户自定义的事务，事务定义的方法是用BEGIN TRANSACTION语句标识事务开始，用COMMIT TRANSACTION或ROLLBACK TRANSACTION语句标识事务结束，这两个语句之间的所有语句被视为一个事务
+ 示例
  DECLARE @KC INT,@CJ INT,@CS INT
  BEGIN TRANSACTION
    UPDATE 成绩表
    SET 课程编号=15
    WHERE 学号='200030000043'
    SET @KC=@@ERROR
    UPDATE 成绩表
    SET 成绩=-10
    WHERE 学号='200030000043'
    SET @CJ=@@ERROR
    UPDATE 成绩表
    SET 考试次数=2
    WHERE 学号='200030000043'
    SET @CS=@@ERROR
  IF @KC=0 AND @CJ=0 AND @CS=0
    COMMIT TRANSACTION
  ELSE
    ROLLBACK TRANSACTION
** 管理事务 
+ 应用程序对事务的管理是通过下列4条语句管理事务：BEGIN TRANSACTION、COMMIT TRANSACTION、ROLLBACK TRANSACTION、SAVE TRANSACTION和两个全局变量：@@ERROR、@@TRANCOUNT
*** BEGIN TRANSACTION语句
+ 用于标识一个用户自定义事务的开始，语法如下
  BEGIN {TRAN | TRANSACTION}
  [{transaction_name | @tran_name_variable}
  [WITH MARK ['description']]
  ]
  - transaction_name
    分配给事务的名称，仅在成对嵌套的BEGIN...COMMIT或BEGIN...ROLLBACK语句的最外层使用事务名
  - WITH MARK
    指定在日志中标记事务，使用WITH MARK子句的事务必须指定事务名
+ 事务是可以嵌套的，原则是必须先提交或回退内层事务，然后提交或回退外层事务，即一条COMMIT TRANSACTION或ROLLBACK TRANSACTION语句对应最近的一条BEGIN TRANSACTION语句
*** COMMIT TRANSACTION语句
+ 用于结束一个用户自定义的事务，保证对数据的修改已经成功写入数据库
+ 语法
  COMMIT [TRAN | TRANSACTION] [transaction_name | @tran_name_cariable]
  和
  COMMIT [WORK]
*** ROLLBACK TRANSACTION语句
+ 语法
  ROLLBACK [TRAN |TRANSACTION] [transaction_name | @tran_name_variable | savepoint_name | @savepoint_variable]
  和
  ROLLBACK [WORK]
  - ROLLBACK TRANSACTION
    语句抛弃自最近一条BEGIN TRANSACTION语句以后的所有操作
  - ROLLBACK WORK
    总是回退到最外层事务
*** SAVE TRANSACTION语句
+ 允许部分提交一个事务，同时仍能回退这个事务的其余部分
*** @@TRANCOUNT变量
+ 是系统全局变量，用来报告当前等待处理的嵌套事务数量，这个变量适合用来确定在批处理所启动的一个事务的中间是否有正在执行的触发器
*** @@ERROR变量
+ 是系统变量，用来保存来自任何一条SQL语句的最新错误号，每当一条不引起错误的语句执行完毕时，这个变量包含零
** 本地事务支持
*** 自动提交事务模式
+ 自动提交事务是默认的事务管理模式，每个单独的SQL语句都是一个事务，且每个SQL语句完成时都被提交或回滚
*** 显示事务模式
+ BEGIN...COMMIT
*** 隐式事务模式
+ 隐式事务是一种连接选项，在该模式下连接执行的每个SQL语句都被视为单独的事务，在提交或回滚当前事务后自动启动新事务，无须描述事务的开始，只需要提交或回滚每个事务，隐式事务模式生成连续的事务链
+ 通过SET IMPLICIT_TRANSACTIONS ON语句设置隐式事务
+ 通过API函数设置隐式事务
  - ODBC
  - OLE DB
*** 批范围的事务
** 隔离级别
*** SQL server中的隔离级别
+ 事务准备接受不一致数据的级别称为隔离级别，是一个事务必须与其他事务进行隔离的程度，较低的隔离级别可以增加并发，代价是降低数据的正确性；较高的隔离级别可以确保数据的正确性，但对并发产生负面影响，应用程序要求的隔离级别确定了SQL Server使用锁定的行为
+ SQL Server支持四种隔离级别
  1. 未提交读(READ UNCOMMITTED)
     执行脏读或0级隔离锁定，表示不发出共享锁，也不接受排他锁，可以对数据执行未提交读或脏读，在事务结束前可以更改数据内的数值，行也可以出现在数据集中或从数据集消失，它的作用与事务内所有语句中所有表上设置NOLOCK相同，是限制最小的级别
  2. 提交读(READ COMMITTED)
     指定在读取数据时控制共享锁以免脏读，但是数据可以在事务结束前更改，从而产生不可重复读取或幻象数据，是SQL Server的默认值
  3. 可重复读(REPEATABLE READ) 
     表示锁定查询中使用的所有数据以防止其他用户更新数据，但其他用户可以将新的幻象行插入数据集，且幻象行包括在当前事务的后续读取中
  4. 可串行读(SERIALIZABLE)
     表示在数据集上放置一个范围锁，以防止其他用户在事务完成之前更新数据集或将行插入数据集内，这是限制最大的级别
+ 隔离级别越高，越能保证数据的完整性和一致性，但对并发性能的影响也越大，对于多数应用程序，可以优先考虑将隔离级别设置为READ COMMITTED，能够避免脏读取，且具有较好的并发性能，尽管会导致不可重复读、虚读、第二类丢失更新这些并发问题，在可能出现这类问题的个别场合，可以由应用程序采用悲观锁或乐观锁来控制
+ 事务必须运行于可重复读或更高的隔离级别以防止丢失更新，当两个事务检索相同的行，然后基于原检索的值对行进行更新时，会发生丢失更新，如果两个事务使用一个UPDATE语句更新行，并且不基于以前检索的值进行更新，则在默认的提交读隔离级别不会发生丢失更新
*** 自定义隔离级别
** 分布式事务
*** SQL分布式事务
*** MS DTC分布式事务
**** ODBC分布式事务
**** OLE DB分布式事务
*** 分布式查询和发布式事务
** 高级事务主题
*** 嵌套事务
*** 事务保存点
*** 使用绑定会话
*** 调整事务隔离级别
*** 在存储过程和触发器中回滚和提交
*** 显示事务中禁用的SQL语句
*** 编写有效的事务
*** 管理长时间运行的事务
+ 查看长时间运行的事务
  1. sys.dm_tran_database_transactions
  2. DBCC OPENTRAN
+ 停止事务
* 备份与恢复数据库 
** 概述
*** 何时备份系统数据库
+ 修改master数据库之后
+ 修改model数据库之后
+ 修改msdb数据库之后
*** 何时备份用户数据库
+ 创建数据库之后
+ 创建索引之后
+ 清理事务日志之后
+ 执行大容量数据之后
*** 数据库备份和恢复的体系结构及特性
+ 四种备份类型
  - 完整备份
    包括所有数据文件的完整镜像和足够的日志，以便恢复数据
  - 差异备份
    基于之前对应的最近一次完整备份数据(基准备份)，差异备份只包含基准备份之后更改的数据区，在还原差异备份之前，必须先还原其基准备份
  - 日志备份
    事务日志备份包括在前一根日志备份中没有备份的所有日志记录，只有在完整恢复模式和大容量日志恢复模式下才会有事务日志备份
  - 文件和文件组备份
    文件和文件组备份可以用来备份和还原数据库中的文件，使用文件备份可以仅还原已损坏的文件，而不必还原数据库的其余部分，提高恢复速度
+ 当数据库处于在线状态并在使用时，可以进行备份，但有一些限制
  - 无法备份离线数据
  - 备份过程中，不允许的操作
    1. 创建或删除数据库文件
    2. 在收缩数据库操作过程中截断文件
** 备份数据
*** 创建备份设备
+ 
*** 管理备份设备
+ 列出备份设备
+ 删除备份设备
*** 完整备份
*** 差异备份
*** 事务日志备份
*** 文件组备份
*** 备份压缩
** 恢复数据
*** 标准恢复
*** 时间点恢复
** 复制数据库
* 数据库自动化
** 配置SQL Server代理
*** 启用SQL Server代理
*** 代理服务安全性
** 操作员
** 作业
** 警报
** 邮件
** 维护计划向导
