* python版本控制
** 设置python版本 
*** pyenv
+ 安装pyenv
  - archlinux
    pacman -S pyenv
+ 列出可供安装的 python 版本
  pyenv  install --list
+ 安装指定版本号
  pyenv install 3.7.6
+ python 安装完成后需要运行
  pyenv rehash
+ 设置全局python版本
  pyenv global 3.7.6 
+ 在当前目录下设置 python 版本
  pyenv local 3.7.6
+ 列出系统中安装的 python 版本
  pyenv versions
+ 显示当前目录下采用的 python 版本
  pyenv version        
+ 删除当前目录下local环境，即删除了.python-version文件
  pyenv local --unset
+ 升级
  pyenv update

** 隔离各个项目的依赖文件
*** pyenv-virtualenv
**** 简介
+ pyenv-virtualenv是与pyenv相同的作者pyenv的插件，可以方便地同时使用pyenv和virtualenv
+ pyenv-virtualenv 通过为每个项目设置独立的虚拟环境（目录）来解决，不同项目依赖的库文件的版本不一致问题
+ pyenv-virtualenv 是 pyenv 的一个插件，因此需要首先安装 pyenv ，然后通过 git 或者 brew 安装 pyenv-virtualenv
+ 使用 pyenv-virtualenv 创建虚拟环境
  pyenv virtualenv 3.6.1 my-virtual-env-3.6.1
  将创建一个名为my-virtual-env-3.6.1的虚拟环境（目录），并且将 python 3.6.1 对应的bin和lib复制到该环境中。当该虚拟环境被激活后，所有的 python 操作都只在该环境中进行，从而和其它 python 内容隔离
+ pyenv-virtualenv 支持自动激活和退出虚拟环境。首先确保在 shell 配置文件中添加了(.bashrc)
  eval "$(pyenv init -)"
  eval "$(pyenv virtualenv-init -)"
  需要使用虚拟环境的目录（通常是项目目录）中：建立一个.python-version的文本文件，将虚拟环境名称（如my-virtual-env-3.6.1）写在里面即可。之后每次进／出该目录时，虚拟环境都将自动激活／退出
+ 也可以用命令手动激活和退出
  $ pyenv activate my-virtual-env-3.6.1
  $ pyenv deactivate
+ 通过 pyenv local <version> 命令可以为某个目录指定所使用的 python 版本，此处可以把版本名替换为某个虚拟环境名，也就是说可以为某个目录指定所使用的虚拟环境，此时在相应的 .python-version 文件中记录的就是指定的虚拟环境名。在这种情况下，当进入这个目录时，会自动激活相应的虚拟环境，退出这个目录时，会自动关闭相应的虚拟环境（在 pyenv 中，虚拟环境和正式的 python 版本具有同样的地位，通过 pyenv versions 查看 python 版本时，虚拟环境也是作为一个独立的 python 版本出现的）
**** 使用
+ 安装
  sudo pacman -S pyenv-virtualenv
+ pyenv-virtualenv 支持自动激活和退出虚拟环境。首先确保在 shell 配置文件中添加了(.bashrc)，需要重新开启shell
  eval "$(pyenv init -)"
  eval "$(pyenv virtualenv-init -)"
+ 列出所有的虚拟环境
  pyenv virtualenvs
+ 创建虚拟环境
  pyenv virtualenv [version] <virtualenv-name>
  pyenv virtualenv 3.7.6 aaa_pyv_3.7.6
+ 激活和关闭虚拟环境
  pyenv activate <virtualenv-name>
  pyenv deactivate
+ 删除虚拟环境
  pyenv virtualenv-delete <virtualenv-name>
  
*** virtualenv
*** virtualenvwrapper
+ 是一组对virtualenv的扩展（请参阅docs ）。 它给你的命令像mkvirtualenv ， lssitepackages ，特别是在不同的virtualenv目录之间切换的工作。 如果您想要多个virtualenv目录，此工具特别有用
* pip
** 配置pip国内源
+ Linux
  修改 ~/.pip/pip.conf (没有就创建一个文件夹及文件。文件夹要加“.”，表示是隐藏文件夹)
  内容如下：
  #+BEGIN_SRC file
  [global] 
  index-url = https://pypi.tuna.tsinghua.edu.cn/simple
  [install]
  trusted-host = https://pypi.tuna.tsinghua.edu.cn  # trusted-host 此参数是为了避免麻烦，否则使用的时候可能会提示不受信任
  #+END_SRC
+ windows
  在user目录中创建一个pip目录，如：C:\Users\xx\pip，新建文件pip.ini
  #+BEGIN_SRC file
  [global] 
  index-url = https://pypi.tuna.tsinghua.edu.cn/simple
  [install]
  trusted-host = https://pypi.tuna.tsinghua.edu.cn  # trusted-host 此参数是为了避免麻烦，否则使用的时候可能会提示不受信任

  #+END_SRC
+ 升级pip
  #+BEGIN_SRC shell
  python -m pip install --upgrade pip
  卸载 
   python -m pip uninstall  pip 
  #+END_SRC
** pip使用
+ 安装
  sudo pacman -S python-pip
* 配置emacs环境
+ 安装python包
  当使用pyenv时，需要使用pyenv安装新的python版本，不能使用system的python，在设置上会造成与linux自带的python混乱
  pip install virtualenv jedi epc rope autopep8 yapf black ipython 

   向~/.bashrc文件中PATH变量添加相应的路径
  nano ~/.bashrc
    export PATH="$HOME/.local/bin:$HOME/.pyenv/shims:$PATH"

+ 设置pylint
  - 安装见主页https://www.pylint.org/#install
    当使用pyenv时，需要使用pyenv安装新的python版本，不能使用system的python，在设置上会造成与linux自带的python混乱
    pip install pylint 
    pip install pylint --upgrade

    sudo pacman -S python-pylint (当使用pyenv时不能使用)
  - 使用customize-group设置flycheck中Flycheck Executables-Flycheck Python Pylint Executable为pylint的安装路径"C:\Users\PC-BGS-WG\AppData\Local\Programs\Python\Python37\Scripts\pylint.exe"
  - 设置.pylintrc文件的位置
+ pylint无法启动时，点击下方flycheck文字，选择切换检查器，选择python-pylint查看报错信息
+ Elpy配置
  - 安装
    
    sudo pacman -S python-virtualenv
  - Elpy Configuration
    Emacs.............: 26.3
    Elpy..............: 1.32.0
    Virtualenv........: None
    Interactive Python: ipython (not found)
    RPC virtualenv....: rpc-venv (/store/zpbird/software/emacs/emacs_home/.emacs.d/elpy/rpc-venv)
    Python...........: python 3.8.1 (/store/zpbird/software/emacs/emacs_home/.emacs.d/elpy/rpc-venv/bin/python)
    Jedi.............: Not found (0.16.0 available)
    Rope.............: Not found (0.16.0 available)
    Autopep8.........: Not found (1.5 available)
    Yapf.............: Not found (0.29.0 available)
    Black............: Not found (19.10b0 available)
    Syntax checker....: Not found (flake8)
    Warnings
    You have not activated a virtual env. While Elpy supports this, it is often a
    good idea to work inside a virtual env. You can use M-x pyvenv-activate or M-x
    pyvenv-workon to activate a virtual env.

    The directory ~/.local/bin/ is not in your PATH. As there is no active
    virtualenv, installing Python packages locally will place executables in that
    directory, so Emacs won't find them. If you are missing some commands, do add
    this directory to your PATH -- and then do `elpy-rpc-restart'.
    The jedi package is not available. Completion and code navigation will not work.
    [Install jedi]
    The autopep8 package is not available. Commands using this will not work.
    [Install autopep8]
    The yapf package is not available. Commands using this will not work.
    [Install yapf]
    The black package is not available. Commands using this will not work.
    [Install black]
    The configured syntax checker could not be found. Elpy uses this program to
    provide syntax checks of your programs, so you might want to install one. Elpy
    by default uses flake8.
    [Install flake8]

    Options
    `Raised' text indicates buttons; type RET or click mouse-1 on a button to invoke
    its action.  Invoke [+] to expand a group, and [-] to collapse an expanded
    group.  Invoke the [Group], [Face], and [Option] buttons below to edit that item
    in another window.
    [+]-- Group Elpy
    [+]-- Group Python
    [+]-- Group Virtual Environments (Pyvenv)
    [+]-- Group Completion (Company)
    [+]-- Group Call Signatures (ElDoc)
    [+]-- Group Inline Errors (Flymake)
    [+]-- Group Code folding (hideshow)
    [+]-- Group Snippets (YASnippet)
    [+]-- Group Directory Grep (rgrep)
    [+]-- Group Search as You Type (ido)
    [+]-- Group Django extension
    [+]-- Group Autodoc extension

* python解释器
** python
+ python解释器程序的文件名为python(windowns下为python.exe)，python文件包括解释器本身和python编译器，python程序必须包含在该系统的PATH环境变量中
+ PYTHONHOME环境变量
  python安装目录，包含标准python库模块的lib子模块也必须放在此目录下
+ 命令行语法和选项
  - python解释器命令行语法可以概括为以下命令
    [path]python {option} [-c command | -m module | file | -] {arguments}
  - 选项
    -c      将pytong语句指定为命令行的一部分
    ......
    -V      打印python版本号
** 运行python程序
+ python解释器将根据需要自动编译python源文件，源文件通常都有一个.py的扩展名
+ python可以将每个模块的编译好的字节代码文件保存在相同的目录中，将这些文件作为该模块的源文件，并将其保存为相同的文件名称和扩展名为.pyc(如果运行python的时候包含-O选项，则扩展名为.pyo)
* python语言
** 词法结构
*** 行
+ 当一条语句太长，单个物理行无法容纳时，可以将两个相邻的物理行连接成一个逻辑行，需要确保第一个物理行没有注释并以反斜杠(\)结束
+ 当如果一个左边的圆、方、花括号还没有对应的右括号，则python将自动把多个物理行连接成一个逻辑行，这种机制通常可以产生更具可读性的代码
*** 缩进
+ python使用缩进(indentation)来表示程序的块结构
+ python标准风格是每个缩进级别使用4个空格，永远都不要使用制表符
*** 字符集
**** ASCII集合
+ 通常python源代码必须完全由ASCII集合组成
+ 开发者可以选择告诉python，在特定的源文件中使用了作为ASCII超集的字符集，但这些字符只能出现在注释和字符串字母常量中
+ 使用其他字符集需要在python源文件的起始部分加上一行相应注释
  #+BEGIN_SRC python
  # -*- coding: utf-8 -*-
  #+END_SRC
**** UTF-8集合
+ 使用utf-8字符集需要在python源文件的起始部分加上一行相应注释
  #+BEGIN_SRC python
  # -*- coding: utf-8 -*-
  #+END_SRC
*** 语言符号
+ python将每个逻辑行分成一个由名为语言符号(token)的基本词法组件组成的序列
+ 常用的语言符号类型包括：标识符(identifier)、关键字(keyword)、运算符(operator)、定界符(delimiter)、字面常量(literal)
**** 标识符(Identifier)
+ 是用来标识变量、函数、类、模块或其他对象的名称，以字母或下划线开头，由字母、数字、某些标点符号组成，区分大小写
+ python的命名风格
  - 类名称以大写字母开始，而所有其他标识符都是小写字母
  - 以单个下划线开头的标识符表示是私有的
  - 以两个下划线开头表示非常强的私有性，如果该标识符还以两个下划线结束，则表示是python的特殊名称
  - 标识符_(单个下划线)专门用于交互式解释器会话中
**** 关键字(Keyword)
+ 关键字时python保留以供专门语法使用的标识符，关键字只包含小写字母
+ 开发者不能将关键字用作常规标识符
+ 常用关键字
  and assert
  break
  class continue
  def del
  elif else except exec
  finally for from
  global
  if import in is
  lambda
  not
  or
  pass print
  raise
  return
  try
  while
  with
  yield
**** 运算符(Operator)
+ 常用运算符
  + - * / % ** // << >> & | ^ ~ < <= > >= <> != ==
**** 定界符(Delimiter)
+ python使用以下符号及组合作为表达式、列表、字典、各种语句和字符串中的定界符
  ( ) [ ] { }
  ' ' " " . = ;
  += -= *= /= //= %=
  &= \= ^= >>= <<= **=
**** 字面常量(Literal)
+ 字面常量是在程序中直接显示的数值和字符串
+ 字面常量示例
  42                 # 整数字面常量
  3.14               # 浮点型字面常量
  1.0j               # 虚数字面常量
  'hello'            # 字符串字面常量
  "world"            # 另一种字符串字面常量
  """Good night"""   # 三重引用字符串字面常量
+ 使用字面常量和定界符，可以创建其他一些基本类型的数据值
  [ 42, 3.14, 'hello' ]  # 列表
  ( 100, 200, 300 )      # 元组
  { 'x':42, 'y':3.14 }   # 字典
**** 语句
***** 简单语句(simple statement)
+ 简单语句是不包含其他语句的语句，一个简单语句完全包含在一个逻辑行中
+ 赋值语句是一个简单语句，可以为变量赋值，与其他一些语言不通，python的赋值操作是一个语句，不能作为表达式的一部分
***** 复合语句(compound statement)
+ 复合语句包含一个或多个其他语句，并可以控制这些语句的执行
+ 复合语句具有一个或多个子句(caluse)，这些子语句以相同的缩进排列，每个子句有一个以关键字开始，以冒号:结束的标题，然后是正文，正文就是由一个或多个语句组成的序列，当正文包含多个语句是，也被称为块(block)，这些语句必须放到标题行之后的单独逻辑行中，向右缩进4个空格，当缩进返回该子句的标题的缩进位置(或到某些复杂语句更左边的缩进位置)时，块词法就结束了
** 数据类型
+ python程序的运行取决于该程序要处理的数据，python中的所有数据值都是对象，并且每个对象或值都有一个类型(type)对象的类型决定了该对象支持哪些操作
+ 类型还确定了该对象的属性(attribute)和项目(item)，以及该对象是否可以被改变，一个可以被改变的对象称为"可变对象"(mutable object),而不可以被改变的对象称为"不可变对象"(immutable object)
+ 内置的type(obj)可以接受任何对象作为其参数，并返回obj类型的类型对象，如果对象obj具有类型type(或其任何子类)，则内置函数isinstance(obj,type)将返回True，否则返回False
+ 对于一些基本数据类型，如数字、字符串、元组、列表、字典，python都有内置类型，开发者还可以创建用户自定义类型，这些类型也被称为类(class)
*** 数字
+ python的内置数字对象支持整数(普通整型和长整型)、浮点型数字、复数
+ python中的所有数字都是不可变对象，即对一个数字对象执行任何的操作，总是会产生一个新的数字对象
**** 整数
+ 整数字面常量可以是十进制、八进制、十六进制
+ 开发者不需要担心普通整型和长整型之间的区别，在需要的时候，对普通整型的操作将生产长整型的结果
+ 开发者可以选择字母L放在任何类型的整数字面量的后面以明确表示该整数是长整型
+ 普通整型只占用几个字节的内存，并且其最小值和最大值是由计算机架构决定的，长整型没有预定义的大小限制，只要内存允许，可以无限大
**** 浮点型
 + 浮点型字面常量可以由包含小数点(.)、指数部分(e或E)或包含这两个部分的十进制数字序列表示，浮点型字面常量的的第一个字符不能是e或E，但可以是任何数字或小数点
**** 复数
+ 复数是由两个浮点值组成的，一个是实数，一个是虚数
*** 序列
+ 序列(sequence)是一个排序的项目容器，按非负整数索引
+ python内置了一些序列类型：字符串(普通和统一的字符编码标准Unicode)、元祖和列表
+ 库和扩展模块提供了其他一些序列类型，开发者也可以自己编写序列类型
**** 可迭代对象
+ 一个可以用来概括"序列"的python概念就是可迭代对象(iterable),所有序列都是可迭代的，只要是可以使用可迭代对象的，则表示开发者可以使用序列
+ 可迭代的对象通常表示一个"有界"(bounded)的可迭代对象，也就是一个最终可以停止生成项目的可迭代对象
+ 所有序列都是有界的，而通常，可迭代对象"可以"是无界的，但没有进行特别处理的话，很容易引发一个永不停止、耗尽所有可用内存的程序
**** 字符串
+ python内置的字符串对象是一个字符序列，用来保存和显示基于文本的信息
+ python中的字符串都是不变的(immutable),这意味着在对字符串执行操作时，总是会产生一个新的字符串对象，而不是修改一个现有的字符串
+ 字符串字面常量可以是被引用的或被三重引用，引用的字符串是一个由包含在单引号或双引号中的零个或多个字符串组成的序列
+ 单引号和双引号的引用功能是相同的，提供这两种引用功能是可以让开发者在使用其中一种引用字符串时可以包含另一种引用符号
  #+BEGIN_SRC python
  'I\'m a python fanatic'    # 使用转义符
  "I'm a python fanatic "    # 直接包含
  #+END_SRC
+ 让字符串常量跨越多个物理行，可以使用反斜杠(\)作为一行文本的最后一个字符，表示下一行文本是这一行的后续文本
+ 让输出的字符串跨越两行，可以在字符串使用\n\中嵌入一个新行，或使用三重引用字符串(三对双引号)，可以保留换行格式，但唯一不能在三重引用字符串中使用的字符就是未加转义的反斜线(\)
+ 多个字符串字面常量可以通过一些可选的空格邻接在一起，编译器将把这些邻接的字符串字面常量串联成单个字符串对象
***** 字符串转义序列
  \<newline>    忽略行尾
  \\             反斜线
  \'             单引号
  \"             双引号
  \a             响铃(Bell)
  \b             退格(Backspace)
  \f             换页(Form feed)
  \n             换行(Newline)
  \r             回车(Carriage return)
  \t             制表符(Tab)
  \v             垂直制表符(Vertical tab)
  \DDD           八进制值 DDD
  \xXX           十六进制值 XX
  \other         其他字符
**** 元组(tuple)
+ 元组是一个顺序不可变的项目序列，元组中的项目都是断言对象，并且可以是不同的类型
+ 开发者可以使用一连串由逗号(,)分隔的表达式(元组中的项目)来指定一个元组，在最后一个项目的后面，可以有选择的多放置一个逗号
+ 包含两个项目的元组通常称为"对"(pair)，创建一个有单个项目组成的元组(通常称为"单例"singleton)，可以在表达式的末尾加一个逗号
+ 可以使用内置的类型tuple来创建一个元组
  #+BEGIN_SRC python
  tuple('wow')
  # 将创建下面的元组
  ('w', 'o', 'w')
  #+END_SRC
**** 列表(list)
 + 列表是一个顺序可变的项目序列，列表中的项目可以是不同类型的任意对象
 + 使用包含在方括号([])中的一连串由逗号(,)分隔的表达式(列表中的项目)来指定一个列表，在最后一个项目的后面，可以有选择的多放置一个逗号
 + 可以使用内置的类型list来创建一个列表
   #+BEGIN_SRC python
   list('wow')
   # 将生成下列列表
   ['w', 'o', 'w']
   #+END_SRC
*** 集合
+ python内置了集合类型(set和frozenset)
+ 集合中的项目可以是不同的类型，但必须是可哈希的(hashable)，set类型的实例都是可变的，因此不是可哈希的，frozenset类型的实例都是 不可变的和可哈希的，因此开发者不能拥有一个项目为set的集合，但可以拥有一个项目为frozenset的集合
+ 集合和frozenset都不是排好序的
*** 映射(mapping)
+ 映射是一个按照近乎是任意值排序的对象组成的任意集合，这些任意值被称为键(key)，与序列不同，映射是可变的，并且不是排好序的
**** 字典
+ 字典中的键可以是不同类型，但这些键必须是可哈希(hashable)的，字典中的值是任意对象，可以是不同类型
+ 字典中的项目是一个键/值对，开发者可以将字典看作是联合的数组
+ 开发使用在花括号{}中使用逗号分隔的一连串表达式对(这些对就是字典中的项目)来表示字典，可以选择在最后一个项目的后面多放一个逗号
+ 字典中的每个项目都可以写作key:value的形式，其中key是一个给定项目的键的表达式，value是给定项目的值的表达式
+ 如果某个键在字典字面常量中出现了多次，则只能在结果字典对象中保留该键的一个项目，字典不允许包含重复的键，如果出现，字典只保留该键的最后一个项目
+ 可以调用内置类型dict来创建字典
  #+BEGIN_SRC python
  d = {key1 : value1, key2 : value2 }
  dict(x=42, y=3.14, z=7)
  dict([[1, 2], [3,4]])
  dict()
  #+END_SRC
+ 不带任何参数的dict()可以创建并返回一个空白目录
*** None
+ 内置的None表示一个空(null)对象，None没有方法和其他属性
+ 开发者可以在需要一个引用，但不介意引用什么对象或在需要表示这里没有对象的时候，使用None作为一个占位符，函数将返回None作为其结果，除非函数具有return语句指定返回值，否则函数默认返回None作为其结果
*** 可调用(callable)
+ 可调用类型是那些类型的实例支持函数调用操作的类型，python提供了几个内置函数，并支持用户自定义函数，生成器也是可调用的
+ 类型也是可调用的，如dict、list、tuple等内置类型，及类对象(class)和方法(method)和特殊方法命名__call__的类实例的函数
*** 布尔型值(bool)
+ python中的所有数据值都可以被看作是一个布尔型值:真(True)或假(False)，任何非零数字或非空容器(字符串、元组、列表、集合或字典)都为真，而0(任何数字类型)、None和空容器都为假
+ 使用浮点型数字作为真值时需要注意，这种使用相当于比较一个数字是否确切等于零，而浮点型数字几乎永远都不能用来比较确切相等
+ 内置类型bool是int的一个子类，bool类型的唯一两个值时True和False，可以使用字符串'True'和'False'来表示，还可以用数字值1和0来表示
+ 好的python风格是不使用重复调用
  - 可以写成 if x
  - 不要写成 if bool(x)、if x==True、if bool(x)==True
** 变量和其他引用
+ python程序通过引用来访问数据的值，引用(reference)表示一个值(对象)在内存中的位置的名称
+ 引用可以表现为变量、属性和项目的形式
+ 在python中，一个变量或其他引用不具备固定的类型，在给定的时间被限定到某个对象的引用总是具有一种类型，但是给定的引用可能会在程序执行期间被指定为各种类型的对象
*** 变量
+ 在python中没有变量的声明，变量的表现形式是以一个绑定(bind)该变量的语句开始的即设置一个变量名称，将引用保存到某些对象上；开发者还可以解除绑定一个变量，复位该名称，使其不再保存引用
+ 赋值语句是绑定变量和其他引用的最常用方法，Del语句可以用来取消对引用的绑定
+ 绑定一个已经被绑定的引用称为重新绑定(rebinding)，一般意义上的绑定都包含了重新绑定，如果没有任何引用绑定到一个对象，该对象将会消失，只要不出现这种情况，重新绑定或解除绑定一个引用对该引用绑定的对象没有任何影响，自动清除无引用绑定的对象被称为垃圾收集
+ 开发者可用使用python保留的关键字之外的任何标识符来命名一个变量
+ 变量可用是全局(global)或本地(local)的，全局变量是模块对象的一个属性；本地变量存在于函数的本地命名空间中
*** 对象属性和项目
+ 对象的属性(attribute)和项目(item)之间的主要区别在于开发者用来访问他们的语法之中，对象的属性是通过该对象的引用，后面带一个点好(.),在带一个被称为属性名(attribute name)的标识符标识(例如：x.y表示被绑定到名称x对象上的一个名为y的属性)
+ 对象的项目是通过该对象的引用，后面带一个包含在方括号([])中的表达式来表示，方括号中的表达式被称为该项目的索引(index)或键(key)，而该对象被称为这个项目的容器(container)例如：x[y]表示被绑定为名称y的键或索引的项目，且该项目被包含在绑定为名称x的容器对象中
+ 可以被调用的属性也被称为方法(method)，python没有对可调用和不可调用的属性给出很强的区别，有关属性的所有规则也应用于可调用的属性(方法)
*** 访问不存在的引用
+ 一个很常见的编程错误就是试图访问一个不存在的引用，python编译器分析和编译源代码时，只诊断语法错误，不会诊断语义错误，比如访问一个未绑定的属性、项目、变量，只有在错误代码执行时才能诊断出语义错误
*** 赋值语句
**** 简单赋值
+ 语法
  target = expression
  - 目标对象(target)也称为左边(LHS)，表达式就是右边(RHS)
  - 在执行赋值语句是，python将计算右边表达式的值，然后将该表达式的值绑定到左边的目标对象上，绑定操作并不取决于这个值的类型
  - python并没有像其他语言一样，在可调用和不可调用对象之间设定特别强的区别，因此可以将函数、方法、类型和其他可调用对象绑定到变量上，就像数字、字符串、列表等对象一样
  - 绑定操作的细节取决于目标对象的类型，赋值语句中的目标对象可以是一个标识符、属性引用、索引、切片
    1. 标识符(identifier)
       是一个变量的名称，为一个标识符赋值也就是使用赋值的名称绑定这个变量
    2. 属性引用(attribute reference)
       属性引用的具体语法obj.name，obj是任意表达式，name是一个标识符，也叫做对象属性名，为一个属性引用赋值也就是让对象obj绑定其名为name的属性
    3. 索引(indexing)
       索引具体语法obj[expr]，obj和expr都是任意表达式，为一个索引赋值就是让容器obj绑定一个由expr的值指定的项目，这个值也被称为容器中项目的索引或键
    4. 切片(alicing)
       - 切片具体语法obj[start:stop]或obj[start:stop:stride]，其中start、stop、stride都是任意表达式且都是可选的，即obj[:stop:]和obj[:stop]都是语法正确的切片，相当于obj[None:stop:None]
       - 为obj[start:stop:stride]这样的切片赋值相当于为索引obj[slice(start,stop,stride)]赋值，其中slice是python内置类型
+ 当赋值语句的目标对象是一个标识符时，该赋值语句表示要绑定一个变量，这样做事允许的；在所有其他情况下，赋值语句表示请求一个对象绑定其一或多个属性或项目，一个对象可能会拒绝创建或重新绑定某些或全部属性或项目，尝试一个不被允许的操作会引发异常
+ 多个变量同时赋予相同值
  #+BEGIN_SRC python
  a = b = c = 0 
  a, b, c = x
  #+END_SRC
+ 交换引用
  #+BEGIN_SRC python
  a, b = b, a
  #+END_SRC
**** 增量赋值
+ 增量赋值与简单赋值的区别在于，增量赋值没有在目标对象和表达式之间使用等号，而是使用增量运输费(augmented operator),该运输费是一个二元运算符后面带一个等号
+ 增量赋值不支持多个目标对象
+ 在增量赋值中，首先计算赋值语句右边表达式的值，如果赋值语句左边的目标对象具有一个特殊方法，正好是这个运算符的一个适当的原地运算版本，python将调用该方法，并以右边表达式的值作为其参数，只有该方法才能决定如何正确的修改左边的目标对象并返回修改后的对象；如果目标对象没有适当的原地运算特殊方法，python将对增量赋值语句的左边和右边对象应用相应的二元运算符，然后将目标引用重新绑定为该运算符的结果，例如x+=y就像x=x.__iadd__(y)一样，其中x具有特殊方法__iadd__，否则x+=y等于x=x+y
+ 增量赋值不能创建目标引用，在执行增量赋值时，该目标引用必须已经被绑定，增量赋值可以将目标应用重新绑定到一个新对象或修改目标引用已经绑定的相同对象，相反，简单赋值可以创建或重新绑定左边的目标引用，但不能修改该对象
+ 对象和对象引用之间的区别至关重要，例如x=x+y不会修改名称x最初绑定的对象，而是创新绑定名称x，以表示一个新对象，相反，x+=y则修改了名称x绑定的对象，如果该对象具有特殊方法__iadd__；否则，x+=y将把名称x重新绑定到一个新对象上，就像赋值语句x=x+y一样
**** del语句
+ del语句并不删除对象，而是解除绑定引用，当一个对象没有任何引用绑定存在时，结果可能是通过垃圾收集自动删除该对象
** 表达式和运算符
*** 表达式(expression)
+ 表达式是一个代码语句，python将计算这段代码产生一个计算结果，最简单的表达式是字面常量和标识符
+ 可以使用运算符和/或定界符来连接子表达式以建立复杂的表达式
  #+BEGIN_SRC python
   'expr,...'  # 字符串转换
   {key:expr,...}  # 创建字典
   [expr,...]  # 创建列表
   (expr,...)  # 创建元组或圆括号
   f(expr,...)  # 函数调用
   x[index:index]  # 切片
   x[index]  # 索引
   x.attr  # 属性引用
   x**y  # 幂(x的y次幂)
   x  # 按位非
   +x, -x  # 一元正和负
   x*y, x/y, x//y, x%y  # 乘 除 截断除法 求余
   x+y, x-y  # 加 减
   x<<y, x>>y  # 左移位 右移位
   x&y  # 按位与
   x^y  # 按位异或
   x|y  # 按位或
   x<y, x<=y, x>y, x>=y, x!=y, x<>y(旧版), x==y  # 比较
   x is y, x is not y  # 同一性测试
   x in y, x not in y  # 成员测试
   not x  # 布尔非
   x and y  # 布尔与
   x or y  # 布尔或
   lambda arg,...:expr  # 匿名简单函数 
  #+END_SRC
  不推荐使用字符串转换运算符，建议使用内置函数repr
*** 比较链
+ 可以将比较运算符链接在一起，隐含逻辑与(and)操作
  a < b <= c < d 与下面表达式同意
  a < b and b <=c and c < d
*** 短路运算符
+ 运算符and和or可以短路(short-circuit)其操作数的计算：只有其值为是为了得到完整的and或or运算的真实值所必须的时候，右边的操作数才会真正进行计算
+ 例如：x and y 将先计算x，如果x为假，则结果就是x；否则，结果为y，同样，x or y先计算x，如果x为真，则结果为x，否则为y
+ and 和 or 并不强制其结果为真(True)或假(False)，而是返回一个或另一个操作数，这可以让开发者更广泛的使用这些运算符，而不只是在布尔运算环境中
+ 三元短路运算符
  whentrue if condition else whenfalse
** 数值运算
*** 数值转换
+ 任意两个python内置类型的数字之间执行算术运算和比较，如果操作数的类型不同，将应用强制转换：将具有"较小"类型的操作数转换为"较大"类型的操作数，这些类型从小到大的顺序排列为：整型、长整型、浮点型数字和复数
+ 可以通过向任何内置数字类型传递一个非复数的数值参数来请求显示转换，如果参数存在小数，整型和长整型将丢弃该参数的小数部分，例如：int(9.8)转换为9
*** 算术运算
+ python的算术运算采用了最显而易见的运算方式，并可能引发除法和幂运算异常
**** 除法
+ 如果/、//或%右边的操作数为0，python将引发一个运行时异常
+ //运算符执行截断除法，即返回一个整数结果忽略小数部分，python默认使用-Qold参数，使用/与//效果相同，如果需要保留/结果中小数部分需要使用-Qnew开关或在源文件起始位置使用以下语句
  from __future__import division
**** 幂运算
+ 对于幂运算a**b，如果a小于零，并且b是一个带有非零小数部分的浮点数，会引发一个异常
**** 比较
+ 包括数字在内的所有对象都可以进行相等(==)和不等(!=)比较
+ 比较指令(< <= > >=)可以在任意两个数字之间使用，除法其中一个操作数是复数
**** 整数的按位运算
+ 整型数值和长整型数值可以被看作是由多个位组成的字符串，可以进行按位运算
** 序列运算
*** 序列概述
+ 序列就是其项目可以通过索引或切片访问的容器，内置的len函数可以将任意容器作为一个参数，返回其中包含项目的数量，内置的min和max函数可以将其项目是可比较的一个非空迭代作为一个参数，返回最小和最大项目
+ 序列转换
  除了在需要的时候可以将普通字符串转换为Unicode字符串，不同的序列类型之间不存在隐式转换
+ 串联和重复
  可以使用+运算符将相同类型的序列串联在一起，还可以使用*运算符将一个序列S乘以整数n，S*n或n*S表示将n个S的副本串联在一起，当n<=0时，S*n是一个与S具有相同类型的空白序列
+ 成员测试
  x in S 运算符可以通过测试检查对象x是否等于序列S中的任何项目，在特殊情况下，比如字符串，x in S 具有更广泛的应用，该运算符将测试x是否等于字符串S的任意子字符串，而不仅是任意单个字符
+ 索引序列
  - 序列S的第n个项目可以表示为索引：S[n]
  - 索引从0开始，S的第一个项目是S[0]，如果序列S包含L个项目，则n最大为L-1
  - 索引n可以是负数，最小到-L，负的n表示序列S的第L+n个项目，即S[-1]相当于S[L-1]，是序列S的最后一个项目，S[-2]是倒数第二个项目
  - 使用>=L或<-L的索引或无效的索引会引发异常
+ 序列切片
  - 表示序列S的子序列，可以使用切片，其语法是S[i:j]，从第i个项目开始(包括i)，到第j个项目介绍(不包括j)
  - 如果j<=i或i>=L，则该切片是一个空白序列
  - 如果i等于0可以忽略，切片从S的起始项目开始，如果j>=L可以忽略，切片会包括S的最后一个项目，都省略则得到整个序列的一个副本
  - 切片可以使用扩展语法S[i:j:k]，k是步长(stride)，即连续的两个索引之间的间距，S[i:j]等于S[i:j:1]；S[::2]是S的子序列，包含S中所有索引为偶数的项目；而S[::-1]包含序列S中的所有项目，顺序相反
*** 字符串
+ 字符串对象是不可变的，因此重新绑定或删除字符串的一个项目或切片会引发异常
+ 字符串对象的项目(对应于字符串中每个字符)本身也都是字符串，每个字符长度为1,
+ 字符串对象的切片仍然是字符串
*** 元组
+ 元组对象是不可变的，重新绑定或删除元组中的一个项目或切片将会引发异常
+ 元组中的项目可以是任意对象，且可以具有不同类型
+ 元组的切片也是元组
*** 列表
+ 列表对象是可变的，可以重新绑定或删除列表中的项目和切片
+ 列表中的项目可以是任意对象，可以具有不同类型，列表的切片也是列表
**** 修改列表
+ 可以通过为一个索引的项目赋值来修改列表
  #+BEGIN_SRC python
  x = [1, 2, 3, 4]
  x[1] = 42  # 次数列表的项目为[1, 42, 3, 4] 
  #+END_SRC
+ 修改列表对象的另一种方法是使用列表的一个切片作为赋值语句的目标对象(左边)，赋值语句的右边必须是一个迭代，如果左边的切片是扩展格式，则右边必须具有与左边切片中的项目数量相同的项目；如果左边切片是普通格式，则左边和右边切片可以是任意长度，为列表的普通切片赋值可以添加和删除列表的项目
  #+BEGIN_SRC python
  x = [1, 2, 3, 4]
  x[1:3] = [22, 33, 44]  # x的项目为[1, 22, 33, 44, 4]
  x[1:4] = [8, 9]         # x的项目为[1, 8, 9, 4]
  #+END_SRC
+ 切片赋值的重要特殊情况
  - 使用空白列表[]作为右边的表达式可以从列表中删除目标切片，即L[i:j]=[]等同于del L[i:j]
  - 使用列表的空白切片作为左边的目标对象可以将右边的项目插入到列表的适当位置，即L[i:j]=['a', 'b']将把项目'a'和'b'插入到赋值前的列表L中索引为i的项目的前面
  - 使用包含整个列表对象L[:]的切边作为左边对象将完全替代列表L中的内容
  - 可以使用del从列表中删除一个项目或切片
    #+BEGIN_SRC python
    x = [1, 2, 3, 4, 5]
    del x[1]      # [1, 3, 4, 5]
    del x[::2]    # [3, 5]
    #+END_SRC
**** 列表的原地运算
+ 列表对象定义了+和*运算符的原地(in-place)运算版本，可以通过增量赋值语句使用
+ 增量赋值语句L+=L1具有与迭代L1中的项目添加到L的末尾相同的效果;L*=n具有将L的n-1个副本添加到L的末尾的效果，如果n<=0,L*=n将导致L中的内容为空，与L[:]=[]相同
**** 列表方法
***** 非变异方法(nonmutating method)
+ 不改变此方法应用的对象
+ 非变异方法
  L.count(x)  返回项目的数量
  L.index(x)   返回列表中出现的第一个等下x的项目的所有，如果没有等于x的项目，会引发一个异常
***** 变异方法(mutating method)
+ 可能会改变此方法应用的对象
+ 变异方法
  L.append(x)  将项目x添加到列表的末尾
  L.extend(s)  将迭代s中的所有项目添加到列表L的末尾
  L.insert(i,x)  将项目x插入到列表L中索引为i的项目之前
  L.remove(x)  从列表L中删除出现的第一个等于x的项目，如果列表L中没有等于x的项目，则引发一个异常
  L.pop([i])  返回列表L中索引为i的项目的值，并存列表L中删除该项目，如果省略i，则删除并返回最后一个项目，如果列表L为空，或i是一个无效索引，则引发一个异常
  L.reverse()  在原地反正列表L中的项目
  L.sort([f]) 
  L.sort(cmp=cmp, key=None, reverse=False)
+ 除了pop，列表对象的所有变异方法都返回None
**** 列表排序
+ 列表的sort方法可以让列表以一种保证恒定的方式(比较结果相等的元素不交换位置)在原地进行排序(对列表中的项目重新排序，按照递增顺序放置项目)，在实际应用中，sort是极快的
** 集合运算 
*** 集合成员
+ k in S运算符可以检查对象k是否是集合S中的一个项目，及 k not is S
*** 集合方法
**** 非变异方法
S.copy()  返回集合的一个简化副本(该副本中的项目是集合S中的相同对象，但不是完全的副本)
S.difference(S1)  返回在集合S中，但是不在集合S1中的所有项目组成的集合
S.intersection(S1)  返回在集合S中，同时也在集合S1中所有项目组成的集合
S.issubset(S1)  如果集合S中的所有项目也都在集合S1中，返回True；否则为False
S.issuperset(S1)  如果集合S1中的所有项目也都在集合S中，返回Treu；否则False
S.symmetric_difference(S1) 返回在集合S或S1中，但不同时在两个集合中的所有项目组成的集合
S.union(S1)  返回在集合S、S1或同时在这两个集合中的所有项目组成的集合
**** 变异方法
S.add(x)  将x添加未集合S中的一个项目，如果x已经存在于S中，则不对集合进行任何操作
S.clear() 从集合S中删除所有项目，使得S为空白集合
S.discard(x)  删除集合S中的项目x；如果x不存在于S中，则不对集合进行任何操作
S.pop()  删除并返回S中的任意一个项目
S.remove(x)  删除集合S中的项目x；如果x不是集合S中的项目，引发一个KeyError异常
+ 除了pop之外，集合对象的所有变异方法都返回None
+ pop方法可以用于对集合进行破坏性的迭代，并且几乎不消耗额外内存，当开发者想要在执行循环操作的同时“消耗掉”集合(减少集合中的项目)的话，内存的节省使得pop可以用来对巨大的集合执行循环操作
** 字典运算
*** 字典成员
+ k in D 运算符可以检查对象k是否是字典D的一个键，如果是返回True，否则返回False，还有k not in D
*** 索引字典
+ 字典D中与键k对应的值可以使用索引来表示：D[k],对不在字典中的键进行索引将引发一个异常
+ 使用还不在字典中的键对一个字典进行普通赋值(如，D[newkey]=value)是一个有效操作，将把该键和值作为一个新项目添加到字典中
+ del D[k]语句将从字典中删除键为k的项目，如果不存在，将引发一个异常
*** 字典方法
**** 非变异方法
D.copy()  返回字典的一个简化副本(该副本中的项目是字典D中的相同对象，但不是完全的副本)
D.has_key(k)  如果k是字典D的一个键，返回True，否则返回Flase，相当于k in D
D.items()  返回一个包含字典D中所有项目的新列表
D.keys()  返回一个包含字典D中所有键的新列表
D.values()  返回一个包含字典D中所有值的新列表
D.iteritems()  返回一个基于字典D中所有项目(键/值对)的迭代器
D.iterkeys()  返回一个基于字典D中所有键的迭代器
D.itemvalues()  返回一个基于字典D中所有值的迭代器
D.get(k[,x])  如果k是字典D中的一个键，则返回D[k]，否则返回x(如果没有给定x，返回None)
**** 变异方法
D.clear()  从字典D中删除所有项目，使得D为空白字典
D.update(D1)  对于字典D1中的每个k，将D[k]设置为等于D1[k]
D.setdefault(k[,x])  如果k是字典D中的一个键，返回D[k];否则将D[k]设置为等于x并返回x
D.pop(k[,x])  如果k是字典D中的一个键，则删除并返回D[k]；否则返回x(如果没有给定x，引发一个异常)
D.popitem()  删除并返回一个人员项目(键/值对)
** print语句
+ print语句后面可以带零个或多个使用逗号分隔的表达式，大多数情况下用于调试目的
+ print语句会自动在表达式之间输出一个空格，并在最后一个表达式后输出\n，除非最后一个表达式后面带一个拖尾逗号
+ print语句的输出目的地是文件和类文件对象，也就是sys模块的stdout属性的值
** 控制流语句
*** if 语句
+ 语法
  #+BEGIN_SRC python
  if expression:
     statements
  elif expression:
     statemnets
  elif expression:
     statements
  ...
  else
     statements
  #+END_SRC
+ expression部分如果使用表达式本身的布尔值进行判断，则直接使用表达式即可，不需要进行等值比较
  - 正确形式
    if x:
  - 错误形式
    if x is True:
    if x == True:
    if bool(x):
*** while 语句
+ 语法
  while expression:
      statements
+ while语句可以包含一个else子句，以及break和continue语句
+ 示例
  count = 0
  while x > 0:
    x = x // 2
    count +=1
+ 如果在一个循环体中执行return语句，则函数体中的循环也将结束
*** for 语句
+ 语法
  for target in iterable:
      statements
+ in关键字是for语句语法的一部分，并且与in运算符有明显区别：in运算符用来测试成员关系
+ for语句还可以包含一个else子句，以及break和continue语句
+ 示例
  #+BEGIN_SRC python
  for letter in "ciao":
      print "give me a", letter, "..."
  #+END_SRC
+ iterable可以是任何一个适合于作为内置函数iter的一个参数的python表达式，iter函数将返回一个迭代器对象，任何序列都是可迭代对象
+ target通常是一个标识符，可以用来命名循环的控制变量
+ for语句可以按顺序连续将这个变量重新绑定到循环器中的每个项目上，对于iterable中的每个项目，构成循环体的语句或语句块只执行一次(除非引发了异常或执行了break或return语句导致循环结束)
+ 开发者可以使用一个包含多个标识符的target，以及拆包赋值，此时，迭代器的项目必须是可迭代的，每个迭代与target中的标识符具有相同数量的项目
+ 示例
  #+BEGIN_SRC python
  for key, value in d.items():
      if not key or not value:
          del d[key]
  #+END_SRC
+ 当一个迭代器具有可变的基础对象时，不能在对其使用for循环期间改变该对象
  - 在对列表循环时，不要插入、添加或删除项目(重新绑定现有索引的项目即可)
  - 在对字典循环时，不要添加或删除项目(重新绑定现有键的值即可)
  - 在对集合循环时，不要添加或删除项目(不允许任何改变)
+ 控制变量可以在循环体中被重新绑定，但在循环的下一次迭代中将再次被重新绑定到迭代器中的下一个项目上，如果迭代器不生成项目，则循环根本不会执行，在这种情况下，控制变量不能以任何方式通过for语句绑定和重新绑定，如果迭代器生成至少一个项目，则在循环语句终止时，控制变量仍绑定到循环语句绑定的最后一个值上
*** 迭代器
+ 迭代器(iterator)是一个对象i，可以不使用任何参数调用i.next()，i.next将返回迭代器i的下一个项目，或者在迭代器i没有更多项目时，引发一个StopIteration异常，在开发者编写一个类时，可以通过定义这样一个next方法以允许类的实例成为迭代器
+ 大多数迭代器是通过隐式或显式调用内置函数iter来建立的，调用一个生成器也会返回一个迭代器
+ for语句隐含调用iter以获得一个迭代器
  #+BEGIN_SRC python
  for x in c:
      statements
  # 等于
  _temporary_iterator = iter(c)
  while True:
      try: x = _temporary_iterator.next()
      except StopIteration: break
      statements
  # 这里_temporary_iterator可以是当前未被使用过的任意名称
  #+END_SRC
  - 如果iter(c)返回一个迭代器i，并且i.next()永远都不引发StopIteration(无界迭代器)，则x in c循环将永不终止(除非循环体中的语句包含适当的break或return语句，或引发了异常)，iter(c)将按顺序调用特殊方法c.__iter__()以获得并返回一个c的迭代器
  - 开发者可以在标准库模块itertools中找到一些构建和使用迭代器的最好方法
*** rang和xrange
+ 对一个整数序列进行循环是一个很常用的任务，python提供了内置函数range和xrange以生成和返回整数序列，在python中循环n此的最简单方法是：
  #+BEGIN_SRC python
  for i in xrange(n):
      statements
  #+END_SRC
+ range(x)可以返回一个项目是从0(包含0)到x(不包含x)的连续整数列表，range(x,y)可以返回一个项目从x(包含x)到y(不包含y)的连续整数列表，如果x大于或等于y，则结果为空白列表；range(x,y,step)可以设置步长，如果step小于0，则生成倒序整数序列，step等于0，会引发异常
+ range可以返回一个可以用于所有目的的普通列表对象，而xrange将返回一个特殊目的的对象，尤其适用于像for语句一样的迭代操作(但为了保持对老版本的向后兼容，xrange并不返回一个迭代器，但如果需要，可以调用iter(xrange(...))来实现)
*** 列表推导
+ for循环通常可以用来查看可迭代对象中的每个项目，并使用一个表达式对某些或所有项目进行计算，通过添加计算的结果来建立一个新表，这种表达式的形式成为列表推导(list comprehension)，可以帮助开发者简明直接地编写这种通用习惯用法
+ 由于列表推导是一个表达式(而不是一个语句块)，开发者可以在需要一个表达式的位置(例如，作为函数调用和return语句中的一个参数，或作为某些其他表达式的子表达式)使用列表推导
+ 列表推导语法
  [ expression for target in iterable lc-clauses ]
*** break 语句
+ break语句只允许出现在循环体内，在执行break语句时，循环会被终止
+ 如果一个循环被嵌套在另一个循环体内，break语句只会终止最内侧嵌套的循环
+ break语句通常位于循环体的if语句的某些子句中，这样break才会有条件地执行
*** continue 语句
+ continu语句只允许出现在循环体内，在执行时，将会终止循环体的当前迭代操作，并使用该循环的下一个迭代继续执行
+ 在实际使用中，continue语句通常位于循环体的if语句的某些子句中，有条件的执行
*** 循环语句中的else子句
+ while和for语句可以有选择地使用拖尾的else子句，else子句之后的语句或语句块将在循环自然终止时执行，但不能在循环提前终止时执行(例如执行break和return语句或引发异常)
+ 当一个循环包含一个或多个break语句时，通常需要检查该循环时自然终止还是提前终止，可以在循环中使用else子句达到这个目的
  #+BEGIN_SRC python
  for x in some_container:
      if is_ok(x):break
  else:
      print "Warning: no satisfactory iten was found in container"
      x = None
  #+END_SRC
*** pass 语句
+ python的复合语句体不能是空白的，至少必须包含一个语句，如果没有什么要执行的操作时，可以使用pass语句作为占位符，该语句不执行任何动作
  #+BEGIN_SRC python
  if condition1(x):
      process1(x)
  elif x>23 or condition2(x) and x<5:
      pass
  elif condition3(x):
      process3(x)
  else:
      process_default(x)
  #+END_SRC
*** try和raise语句
+ python支持使用try语句进行异常处理，该语句包含try、except、finally和else子句
+ 一个程序可以使用raise语句显式引发一个异常，在引发异常时，程序的正常控制流将会停止，同时python将会寻找一个适当的异常处理程序
*** with语句
+ python添加更具可读性的with语句作为try/finally语句的另一个选择
** 函数
*** 概述
+ 典型的python程序中的大多数语句都被分组和组织成了函数(放在函数体内的代码要比放在模块的顶级更快)
+ 请求执行一个函数的操作被称为函数调用(function call)，在调用一个函数时，可以向函数传递指定数据的参数，函数将根据这些参数执行计算
+ 在python中函数总是会返回一个结果值，可以是None或表示计算结果的一个值
+ class语句中定义的函数也被称为方法(method)
+ 在python中函数是可以像其他对象那样进行处理的对象(值)，因此，可以将函数作为另一个函数调用中的一个参数，也可以返回另一个函数作为调用的结果
+ 与任何其他对象一样，函数也可以绑定到变量、容器中的一个项目或对象的一个属性上，还可以是字典中的键，例如，如果需要快速查找一个函数的反函数，可以定义一个字典，其键和值也都是函数，然后让其成为双向字典即可
+ 在python中说到函数都是普通对象，实际上是函数是第一类(first-calss)对象
*** def 语句
+ def语句时定义函数的最常用方法，语法如下
  def function-name(parameters):
      statements
  - function-name
    是一个标识符，这个标识符就是一个绑定(或重新绑定)到该函数对象的一个变量
  - parameters
    1. 是一个可选的标识符列表，称为形式参数(formal parameters)或参数，在函数被调用时，这些参数将被绑定到实际输入的值上，可以没有任何形式参数
    2. 当函数需要取得参数时，parameters包含一个或多个由逗号分隔的标识符，在这种情况下，每次调用该函数时都需要提供值，称为实际参数(arguments)，对应与函数定义中列出的形式参数，这些参数都是函数的本地变量，并且每次调用函数时将把这些本地变量绑定到调用程序提供为实际参数的值上
  - 非空语句序列被称为函数体(function body)，在执行def语句时并不执行函数体，而是在每次函数被调用时，再执行函数体
  - 函数体可以包含零个或多个return语句
*** 参数
+ 只包含标识符的形式参数表示强制参数(mandatory parameter)，每次调用函数必须为每个强制参数提供对应的值(实际参数)
+ 在使用逗号分隔的参数列表中，零个或多个强制参数后面可能会带零个或多个可选参数(optional parameter)，每个可选参数语法如下
  identifier = expression
  - def语句将计算每个这样的表达式(expression)，并保存一个到该表达式的值的引用，这个值也被称为参数的默认值，是该函数对象的一个属性，当函数调用没有提供与可选参数对应的实际参数时，该函数调用将把参数的标识符绑定到其默认值上以供该函数执行
  - 在def语句执行时，将会计算每个默认值，但在调用结果函数时，则不会计算这些默认值；特别是，这意味着只要调用程序不提供对应的实际参数，则相同的对象将以默认值绑定到可选参数上，在默认值时可变对象，且函数体将改变该参数时，处理起来比较麻烦
  - 例如
    #+BEGIN_SRC python
    def f(x, y=[]):
        y.append(x)
        return y
    print f(23)  # 输出 [23]
    print f(24)  # 输出 [23, 42]
    #+END_SRC
    - 第二个print语句将打印[23, 42]是因为第一次调用f时改变了y的默认值，y的初始默认值是一个空白列表[]，调用后添加了一个值23，如果需要每次调用都保证y绑定到一个空白列表对象上，代码如下
      #+BEGIN_SRC python
      def f(x, y=None):
          if y is None: y = []
          y.append(x)
          return y 
      #+END_SRC
+ 在参数的末尾，可以有选择地使用特殊形式*identifier1或**identifier2，或者两者都用，如果两个形式都出现了，要将带有两个星号的形式放在后面；*identifier1指定了对该函数的任何调用要提供任意数量的额外位置参数，而**identifier2指定了对该函数的任何调用要提供任意数量的额外命名参数；对该函数的所有调用都将identifier1绑定到一个项目是额外位置参数的元组(或者是空白元组，如果没有任何项目)，同样，identifier1绑定到一个项目是额外命名参数的名称和值的字典(或是空白字典，如果没有任何项目)
  - 示例：可以接受任意数量的位置参数并返回其和的函数
    #+BEGIN_SRC python
    def sum_args(*numbers):
        return sum(numbers)
    print sum_args(23, 42)  # 输出 65
    #+END_SRC
+ 一个函数的参数数量，加上这些参数的名称、强制参数的数量，及是否出现了单星号和双星号的特殊形式的信息(在参数的末尾)，共同形成了被称为函数签名(signature)的规范，函数签名定义了调用函数的方法
*** 函数对象的属性
**** func_name
+ def语句设置了函数对象的某些属性，属性func_name也可以通过__name__进行访问，是指def语句中作为函数名的标识符字符串，可以将该属性重新绑定到任何字符串值上(python2.4以后)，但试图解除绑定该属性将引发一个异常
**** func_defaults
+ 可以自由重新绑定或解除绑定的属性func_defaults是指由可选参数的默认值组成的元组(或空白元组，如果该函数没有可选参数)
**** 文档字符串(documentation string 即docstring)
+ 可以使用或重新绑定函数的docstring属性为func_doc或__doc__
+ 如果函数体的第一个语句时字符串字面常量，编译器将把该字符串绑定为该函数的docstring属性，相同的原则也可以应用于类和模块，trings大多数情况下会跨越多个物理行，因此通常以三重引用字符串字面常量的形式指定该属性
+ docstrings除了作为注释，还可以提供给矿粉环境和工具，作为该函数的使用提示，如使用方法，示例代码
+ 让docstrings尽可能有用，必须遵循几个简单的习惯用法
  - 第一行应该是该函数目的的简要说明，以大写字母开始，以句点结束
  - 如果docstrings是多行，则第二行应该是空白的，且后面的行应该构成有空白行分隔的一个或多个段落，说明该函数的参数、前提条件、返回值和负面影响
**** 其他属性
+ 除了预定义的属性，函数对象可以有其他任意属性，创建函数对象的属性，在def语句执行后，可以将一个值绑定到赋值语句中适当的属性引用上
+ 例如：计算一个函数被调用了多少次的函数
  #+BEGIN_SRC python
  def counter():
      counter.count += 1
      return counter.count
  #+END_SRC
+ 注意，这不是通常的用法，更常见的用法是将属性和方法封装成类
*** return 语句
+ python中的return语句只允许在函数体内出现，且可以有选择的带一个表达式
+ 在执行retrun语句时，函数将会终止，且表达式的值就是该函数的值，如果函数时达到了函数体的末尾，或执行了一个没有表达式的return语句而终止，则该函数返回None
+ 作为一种好的风格，开发者不应该在函数体的末尾编写一个不带表达式的return语句，可以使用return None来统一风格
*** 调用函数
**** 概述
+ 函数调用语法
  function-object(arguments)
+ function-object可以是函数对象(或其他可调用对象)的任何引用：最常见的是，function-object就是该函数的名称，圆括号表示函数调用操作本身，在最简单的情况下，arguments是一连串逗号分隔的零个或多个表达式，为该函数的对应参数提供值
+ 在执行函数调用时，这些参数将绑定到参数的值上、执行函数体，且这个函数调用的表达式的值就是该函数的返回值
**** 参数传递的语义
+ 从传统上讲，python中所有的参数都是通过值(value)来传递的，例如，如果传递一个变量作为参数，python将向该函数传递该变量当前对应的对象(值)，而不是变量本身；因此，函数不能再重新绑定调用程序的变量；但是，如果将一个可变对象传递为一个参数，该函数可能会对这个对象进行更改，因为python传递的是该对象本身，而不是一个副本，重新绑定一个变量和改变一个对象的值时完全不同的概念
  #+BEGIN_SRC python
  def f(x, y):
      x = 23
      y.append(42)
  a = 77
  b = [99]
  f(a, b)
  print(a, b)    # 输出结果 77 [99, 42]
  #+END_SRC
**** 参数的类别
***** 位置参数
+ 只有表达式的参数被称为位置参数(positional argument)，每个位置参数按照其在函数定义中的位置(顺序)为对应的参数提供值
***** 命名参数
+ 在函数调用中，零个或多个位置参数后面可能会带有零个或多个命名参数(named argument)，每个命名参数的使用语法如下
  identifier=expression
+ identifier必须是该函数的def语句中使用的一个参数名称，expression为这个名称的参数提供了值，大多数内置函数不接受命名参数，开发者只能使用位置参数调用这样的函数，但使用使用python编写的普通函数都可以接受命名参数和位置参数
+ 命名参数通常可以用于将某些可选参数绑定到特定值上，并让其他可选参数使用默认值
  #+BEGIN_SRC python
  def f(middle, begin='init', end='finis'):
      return begin + middle + end
  print f('tini', end='')  # 输出结果 inittini
  #+END_SRC
***** 特殊参数
+ 开发者可以可选使用一个或两个特殊形式*seq和**dct，如果这两种形式的参数都被使用了，带有双星的形式必须放在后面
+ *seq可以将seq中的参数作为位置参数传递给该函数，seq可以是任何可迭代对象
  #+BEGIN_SRC python
  def sum_args(*numbers):
      return sum(numbers)
  print sum_args(*d.values())
  #+END_SRC
+ **dct可以将dct中的项目作为命名参数传递给该函数，其中dct必须是所有键都为字符串的字典，每个项目的键都是一个参数的名称，该项目的值则是这个参数的值
*** 命名空间
+ 函数的参数，加上函数体中绑定的所有变量(通过赋值或其他绑定语句，比如def)，共同构成了该函数的本地命名空间(local namespace)，也称为本地范围(local scope)，所有这些变量也被称为该函数的本地变量(local variable)
+ 不是本地变量的变量称为全局变量(global variable)，全局变量都是模块对象的属性，在函数的本地变量与全局变量具有相同的名称时，则函数体内的这个名称指的是本地变量，而不是全局变量，称之为本地变量在整个函数体内隐藏了相同名称的全局变量
**** global 语句
+ 默认情况下，函数体内绑定的任何变量都是该函数的本地变量，如果一个函数需要重新绑定某些全局变量，则该函数的第一个语句必须是：
  global identifiers
  - identifiers是一个或多个使用逗号分隔的标识符，这些标识符指的是该函数需要重新绑定的全局变量
    #+BEGIN_SRC python
    _count = 0 
    def counter():
        global _count
        _count += 1
        return _count
    #+END_SRC
+ 如果函数体只是要使用一个全局变量(包括改变绑定到这个变量的对象，如果该对象时可变的)，可以不使用global，只有在函数体重新绑定一个全局变量(通常就是为变量的名称赋值)时，才使用global语句
+ 作为一种编程风格，除非确实需要，不要使用global语句
**** 内嵌函数和嵌套范围
+ 函数体内的def语句定义了一个内嵌函数(nested function)，并且函数体包含def的函数称为内嵌函数的外函数(outer function)，嵌套函数体中的代码可以访问(但不是重新绑定)一个外部函数的本地变量，也被称为这个内嵌函数的自由变量(free variable)
+ 让一个内嵌函数可以访问一个变量的最简单方法通常并不依赖于嵌套的范围，而是将这个值显式传递为该函数的一个参数，如果有必要，也就是在内嵌函数是通过使用该值作为一个可选参数的默认值来定义时，该参数的值可以被绑定
  #+BEGIN_SRC python
  def percent1(a, b, c):
      def pc(x, tatal=a+b+c): return (x*100.0) / total
      print ("Percentages are:", pc(a), pc(b), pc(c))
  #  下面是使用嵌套范围的相同功能
  def percent2(a, b, c):
      def pc(x): return (x*100.0) / (a+b+c)
      print ("Percentages are:", pc(a), pc(b), pc(c))
  #+END_SRC
+ 访问来自外部本地变量的值的内嵌函数称为闭包(closure)
  #+BEGIN_SRC python
  def make_adder(augend):
      def add(addend):
          return addend+augend
      return add
  aaa = make_adder(7)
  aaa(10)
  #+END_SRC
+ 面向对象是融合数据和代码的最佳方法的一般性原则，闭包是一个例外，在开发者需要特别构造可调用对象，且在对象构造时固定某些参数时，闭包要比类更简单、更有效率，例如，make_adder(7)的结果是一个接受单个参数并项该参数加7的函数
+ 返回一个闭包的外函数是一个可以制造由某些参数(比如上个示例中参数augend的值)区分的函数家族的成员函数的"工厂"，且经常可以帮助开发者避免重复编程
*** lambda 表达式
+ 如果函数体是一个单独的return expression语句，开发者可以选择使用特殊的lambda表达式形式替换该函数
  lambda parameters: expression
+ lambda表达式相当于函数体为单个return语句的普通函数的匿名函数，lambda语法并没有使用return关键字，开发者可以在任何可以使用函数引用的位置使用lambda表达式
+ 在开发者想要使用一个简单函数作为参数或返回值时，使用lambda表达式是很方便的
  #+BEGIN_SRC python
  aList = [1, 2, 3, 4, 5, 6, 7, 8, 9]
  low = 3
  high =7
  filter(lambda x, l=low, h=high: h>x>l, aList) # 返回： [4, 5, 6]
  #+END_SRC
  等同于
  #+BEGIN_SRC python
  aList = [1, 2, 3, 4, 5, 6, 7, 8, 9]
  low = 3
  high =7
  def within_bounds(value, l=low, h=high):
      return h>value>l
  filter(within_bounds, aList)
  #+END_SRC
+ lambda表达式只是偶尔有用，许多用户更喜欢使用def，def要更通用一些，会让代码具有更好的可读性
*** 生成器
+ 在函数体中出现了一个或多个关键字yield时，可以将该函数称为生成器(generator)，在调用一个生成器时，并不会执行该函数体，调用生成器将返回一个特殊的迭代器对象，该对象包含这个函数体、函数体的本地变量(包括函数体的参数)，以及当前的执行行位置，这个位置最初就是该函数的起始点
+ 在调用这个迭代器对象的next方法时，函数体将执行到下一个yield语句，该语句使用以下格式
  yield expression
+ 在执行yield语句时，函数的执行将被冻结，保留执行的当前位置和未经使用的本地变量，且yield后面的表达式将被返回为next方法的结果，当再次调用next方法时，函数体的执行将从其被冻结的位置开始继续执行，再次到达下一个yield语句，如果函数体运行结束或执行了return语句，该迭代器将引发一个Stoplteration异常，用以表明迭代操作已经完成，生成器中的return语句不能包含表达式
+ 生成器是用来构建迭代器的一种非常方便的方法，由于使用迭代器的最常用方法时使用for语句对其执行循环操作，开发者通常可以使用下面的代码调用生成器
  for avariable in somegenerator(arguments):
+ 示例：生成从1到N，然后从N到1的数字序列
  #+BEGIN_SRC python
  def updown(N)
      for x in xrange(1, N): yield x
      for x in xrange(N, 0, -1): yield x
  for i in updown(3): print(i)
  # 输出 1 2 3 2 1
  #+END_SRC
+ 生成器要比可以返回列表的函数更灵活，生成器可以构建无界的迭代器，这意味着可以返回一个无限的结果序列(只能在使用其他方法终止的循环操作中使用，如使用break语句终止循环操作)，更进一步，生成器构建的迭代器可以执行懒惰计算(lazy evaluation)：只有在需要时迭代器才计算每个连续项目，而相等的函数需要提前进行所有计算，且可能需要大量内存来保存结果列表
+ 如果开发者需要的是对一个计算的序列进行迭代的功能，通常最好的方法就是计算生成器中的序列，而不是可以返回一个列表的函数中的序列，如果调用程序需要一个由某些有界的生成器G(arguments)生成的所有项目组成的列表，调用程序只需要使用以下代码
  resulting_list = list(G(arguments))
**** 生成器表达式
+ python2.4引入了一种更简单的方法来特别地编写简单的生成器：生成器表达式(generator expressions)，通常称为genexp，语法类似列表推导，区别在于genexp被包含在圆括号中，而不是方括号
+ genexp的语义与对应的列表推导的语义是相同的，区别在于genexp将生成一个迭代器，一次生成一个项目，而列表推导将会在内存中产生由所有结果组成的列表
+ python2.5中生成器得到了进一步增强，开发者可以在每个yield执行时，从调用函数接收一个返回值(或异常)，在python2.5中，yield并不是一个语句，而是一个表达式，因此，yield是有值的，在调用生成器的next方法继续执行该生成器时，对应的yield的值为None
*** 递归
+ python支持递归(函数可以调用其本身)，但对于可以递归多少层是有限制的，在默认情况下，当python检测到其递归调用堆栈超过了1000层的深度时，将中断该递归调用并引发RecursionLimitExceeded异常，开发者可以使用sys模块的setrecursionlimit函数更改迭代限制
+ 更改递归限制也不能获得无限制的递归，最大限制取决于开发者程序运行的平台，特别取决于底层的操作系统和C运行时库，但通常最多也只有数千层，递归得太深，程序可能崩溃，最常见的情况时，开发者最好考虑查找一些方法来删除递归，就是限制程序所需要的递归深度
* 面向对象
+ python是一种面向对象的编程语言，但并不强迫开发者只使用面向对象的模式编写程序，同时支持使用模块和函数进行面向过程的编程，因此开发者可以为程序的每个部分选择最适当的编程范式
+ 通常，在开发者想要将状态(数据)和行为(代码)组合在一起，使之成为便于使用的功能包时，面向对象的范式是很适合的
+ python3使用了新型的对象模型，2.x使用的是传统的对象模型
** 类(class)和实例(instance)
*** python类
+ python类是一个具有以下几个特征的python对象
  - 可以像函数一样调用类对象，调用将返回另一个对象，也被称为该类的实例；这个类也被称为该实例的类型
  - 类中包含任意名称的属性，开发者绑定和引用这些属性
  - 类属性的值可以是描述符(包括函数)或普通数据对象
  - 绑定到函数的类属性也被称为该类的方法
  - 方法可以有一个特殊的、使用python定义的名称，这个名称带有两个前导下划线和两个拖尾下划线，如果一个类提供了一些特殊方法，在对该类的实例进行各种类型的操作时，python可以隐式调用这些特殊方法
  - 可以从其他类继承类，这意味着这个类可以委托其他类对象查找该类本身没有的属性
+ 类的实例是一个带有任意名称的属性的python对象，开发者可以绑定和引用这些属性，实例对象可以隐式地委托其类查找该实例本身没有的属性，反过来，如果有的话，一个类也可以委托查找继承该类的类
+ 在python中，类就是对象(值)，开发者可以像对其他对象那样处理类，开发者可以在调用函数时传递一个类作为参数，同样，函数可以返回一个类作为调用的结果；就像任何其他对象一样，类可以绑定到一个变量、容器中的一个项目或对象的一个属性上；类还可以是字典的键，类就是python中的普通对象，这个事实通常是说这些类是第一类(first-class)对象来表达
*** class 语句
+ class语句是创建一个类对象最常用的方法，class是一个实验以下语法的单子句符合语句：
  class classname(base-classes):
      statement(s)
+ classname是一个标识符，该标识符是一个在执行完class语句之后被绑定(重新绑定)到类对象的变量
+ base-classes是一个使用逗号分隔的表达式序列，这些表达式的值必须是类对象，在不同的编程语言中，这些类被命名为不同的名称；根据开发者的选择，开发者可以将这些类称之为要创建的类的基类(base)、超类(superclass)或父类(parent)，根据开发者熟悉的编程语言的类型，要创建的类可以被称为继承自或者派生自其基类，或者是其基类的扩展类或子类，这个类也被称为其基类的直接子类或子孙类
+ base-classes是可选的：要想表示正在创建一个没有基类的类，可以省略base-classes及其圆括号，将冒号直接放在类名称的右边(也可以使用空白圆括号)
+ 没有基类的类是一个老式类(除非定义了__metaclass__属性)，要创建一个没有任何"真正"基类的新型类C，可以将代码写出class C(object): 由于所有的类型都是内置对象的子类，因此，将object指定为基类的值就意味着类C是一个新型类，而不是老式类；如果开发者的类具有的都是老式类的祖先，并且没有定义__metaclass__属性，则该类是老式类；否则，具有基类的类都是新型类(即使某些基类是新型类，而另外的一些是老式类)
+ 类之间的子类关系是可以传递的：如果C1是C2的子类，而C2是C3的子类，则C1也是C3的子类；内置函数issubclass(C1,C2)可以接受两个类对象参数，如果C1是C2的子类，则返回True，否则返回False；任何类都可以看作是其自身的子类，因此，issubclass(C,C)返回True
+ class语句之后的非空语句序列被称为类体(class body),作为class语句执行的一部分，类体将在class语句之后立即执行，在类体执行完之前，新的类对象还不存在，并且classname标识符也还没有被绑定(或重新绑定)
+ class语句并不直接创建新类的任何一个实例，而是定义了在以后调用这个新类创建实例时
*** 类体
+ 类的主体就是通常指定该类的属性的位置，这些属性可以是描述符对象(包括函数)或任何类型的普通数据对象(类的属性也可以是另一个类，例如，开发者可以将一个class语句嵌入另一个class语句中)
**** 类对象的属性
+ 通常可以通过将一个值绑定到类体中的一个标识符上来指定类对象的一个属性
  #+BEGIN_SRC python
  class C1(object):
      x =23
  print(C1.x) # 输出 23
  #+END_SRC
+ class语句将隐式设置某些类属性，属性__name__是class语句中使用classname标识符字符串；属性__bases__是class语句中的基类的类对象的元组；类还包含一个属性__dict__，这个属性是该类的字典对象，被用来保存所有其他属性
  #+BEGIN_SRC python
  C1.y = 45
  C1.__dict__['z'] = 67
  print(C1.x, C1.y, C1.z) # 输出 23 45 67
  #+END_SRC
+ 在类体中创建的属性与通过在类体外为一个属性赋值或通过在类体外显示绑定__dict__中的一个项目而创建的类属性之间并没有区别，通常采用第一种方式，便于代码维护
+ 对于包含在类体中的语句，要引用该类的属性，必须使用属性的简单名称，而不是完整名称
  #+BEGIN_SRC python
  class C(object):
      x = 23
      y = x + 22 # 必须使用x，而不是C.x
  #+END_SRC
+ 在类体中定义的方法中的语句，要引用类的属性，必须使用完整名称，而不是简单名称
  #+BEGIN_SRC python
  class C(object):
      x = 23 
      def amethod(self):
          print(C.x)    # 必须使用C.x，而不是x
  #+END_SRC
**** 类体中的函数定义
+ 大多数类体包含def语句，由于函数(在当前的上下文环境下，称之为方法)对大多数类对象而言是非常重要的属性
+ 类体中定义的方法都有一个强制的第一参数，通常被命名为self，该参数对应于要对其调用方法的实例，self参数在方法调用中起着特殊的作用
**** 类私有变量
+ 当类体中的一个语句(或类体中的一个方法)使用一个以两个下划线(但不是以下划线结束)，比如__ident，python编译器将把该标识符隐式更改为_classname__ident，classname是该类的名称，这样可以让一个类的属性、方法、全局变量和其他目标对象使用"私有"名称，减少意外在其他位置使用重复名称的风险
+ 按惯例，所有以单个下划线开始的标识符表示对于他们绑定的范围而言是私有的，不管这个范围是不是一个类，python编译器并不强制执行这个私有惯例，而是取决于开发者是否遵循这个习惯用法
**** 类文档字符串
+ 如果类体中的第一个语句时一个字符串字面常量，编译器将把该字符串绑定为这个类的文档字符串属性，这个属性被被命名为__doc__，且被称为这个类的docstring
*** 描述器(descriptor)
+ 描述器是其类可以提供一个名为__get__的特殊方法的任何新型对象，作为类属性的描述器可以控制对这个类的实例的属性进行访问和设置的语法
+ 开发者访问一个实体属性时，python可以通过对相应的描述器调用__get__方法获得该属性的值
**** 覆盖和非覆盖描述符
+ 如果一个描述符的类还可以提供一个名为__set__的特殊方法，则这个描述符被称为覆盖描述符(overriding descriptor)(或称为数据描述器)；如果该描述器的类只提供__get__，而不提供__set__，则该描述器被称为非覆盖描述符(nonoverriding descriptor)(或非数据描述器)
+ 函数对象的类可以提供__get__，而不提供__set__，因此函数对象时非覆盖描述符；在使用对应的覆盖描述符为一个实例属性赋值时，python可以通过对该描述符调用__set__方法来设置该属性的值
+ 老式类可以包含描述符，但老式类中的描述器总是作为非覆盖描述器使用(如果有__set__方法，该方法将被忽略)
*** 实例
+ 要创建一个类的实例，可以调用类对象，就像该对象是一个函数一样，每个调用都返回一个类型为该类的新实例
  anInstance = C()
+ 可以使用内置函数isinstance(I, C)，如果对象I是类C或类C的任何子类的一个实例，则返回True，否则返回False
**** __init__方法
+ 当一个类定义或继承了一个名为__init__的方法时，调用该类对象将对新实例隐式执行__init__方法以执行任何需要的与实例相关的初始化，该调用中传递的参数必须对应于__init__的参数，除了参数self
  #+BEGIN_SRC python
  class C(object):
      def __init__(self, n):
          self.x = n
  # 创建实例
  anotherInstance = C(42)
  #+END_SRC
+ __init__方法通常包含绑定实例属性的语句，__init__方法不能返回一个值；否则，python将引发一个TypeError异常
+ __init__的主要目的就是绑定，并因此创建新创建的实例的属性，开发者还可以绑定或解除绑定__init__之外的实例属性
+ 在缺少__init__时，开发者调用该类时不能带参数，并且新生成的实例没有特定属性
**** 实例对象的属性
+ 开发者创建了一个实例后，可以使用点操作符访问其属性(数据和方法)
  #+BEGIN_SRC python
  anInstance.hello()
  print(anotherInstance.x)
  #+END_SRC
+ 可以通过将一个值绑定到一个属性引用为实例对象提供任意一个属性
  #+BEGIN_SRC python
  class C(object): pass
  z = C
  z.x = 23
  #+END_SRC
+ 如果存在__setattr__特殊方法，将会截断每个试图绑定一个属性的操作
+ 创建一个实例将隐式设置两个实例属性
  - __class__是实例所属的类对象
  - __dict__时实例用来保存其他属性的字典
  - 示例
    #+BEGIN_SRC python
    print(z.__class__.__name__, z.__dict__)  # 输出：C，{'x':23}
    #+END_SRC
**** 工厂函数的习惯用法
+ 一个很常见的任务就是根据某些条件创建不同类的实例，或如果已经有一个实例可供使用，则避免创建一个新实例，最常见的误解就是这样的需求可以通过让__init__返回一个特殊对象来满足，但是，这样的方法是绝对不可能实现的：当__init__返回一个不同于None的任何值时，python将引发一个异常
+ 实现灵活创建对象的最好方法就是通过使用一个普通函数，而不是直接调用该类对象，用于这个目的的函数被称为工厂函数(Factory-function)
+ 调用工厂函数是一种灵活的方法:函数可能返回一个已有的可重用实例，或通过调用适当的任何类创建一个新实例，假定有两个几乎可以互换的类(SpecialCase和NormalCase)，且想要灵活生成任意一个类，这取决于一个参数，下面的appropriageCase工厂函数正好可以实现
  #+BEGIN_SRC python
  class SpecialCase(object):
      def amethod(self): print('special')
  class NormalCase(object):
      def amethod(self): print('normal')
  def appropriateCase(isnormal=True):
      if isnormal: return NormalCase()
      else: return SpecialCase()
  aninstance = appropriateCase(isnormal=False)
  aninstance.amethod()  # 输出： ‘special’
  #+END_SRC
**** __new__方法
+ 每个新型类都有(或继承了)一个名为__new__的静态方法，当开发者调用C(*args, **kwds)来创建类C的一个新实例时，python将首先调用C.__new__(C, *args, **kwds)；python使用__new__的返回值x作为新创建的实例，然后调用C.__init__(x, *args, **kwds)，但是只有在x确实是C的一个实例，或C的任何一个子类时才会调用该方法，否则，x的状态仍然是__new__返回的状态
  #+BEGIN_SRC python
  x = C(23)
  # 等同于
  x = C.__new__(C, 23)
  if isinstance(x, C): type(x).__init__(x, 23)
  #+END_SRC
+ object.__new__可以创建其接收为第一个参数的类的一个新的和未初始化的实例，如果这个类包含一个__init__方法，则该方法将忽略其他参数，但是，如果除了第一个参数，该方法还接收了其他参数，并且第一个参数的类不包含__init__方法，则该方法将引发一个异常
+ 当开发者覆盖类体中的__new__方法时，不需要像平时所做的那样，添加__new__=staticmethod(__new__)，python可以识别名称__new__，并在这个上下文环境下对其进行特别处理；只有在开发者以后会在C的类体之外重新绑定C.__new__的极少情况下，才需要使用C.__new__=staticmethod(whatever)
+ __new__具有工厂函数的大多数灵活性，可以适当地选择返回一个已有的实例或创建一个新实例，当__new__确实需要创建一个新实例时，最常见的方法就是通过调用object.__new__或C的另一个超类的__new__方法来委托这个创建操作
+ 下面的示例显示了如何为了实现Sigleton设计模式的一个版本而覆盖静态方法__new__
  #+BEGIN_SRC python
  class Singleton(object):
      _singletons = {}
      def __new__(cls, *args, **kwds):
          if cls not in cls._singletons:
              cls._singletons[cls] = super(Singleton, cls).__new__(cls)
          return cls._singletons[cls]
  #+END_SRC
+ Singleton的任何子类(不会进一步覆盖__new__)都只有一个实例，如果这个子类定义了一个__init__方法，该子类必须确保__init__方法在被这个子类唯一的实例进行多次重复调用时(在每次请求创建时)是安全的，老式类没有__new__方法
*** 属性引用基础知识
+ 属性引用(attribute reference)是一个形式为x.name的表达式，其中x是任何表达式，name是一个调用该属性名称的标识符
**** 从类获得属性
+ 当'name'是C.__dict__中的一个键时，C.name将从C.__dict__['name']中提取v，然后，如果v是一个描述器(即type(v)提供了一个名为__get__的方法)，则C.name的值就是调用type(v).__get__(v,None,C)的结果，否则，C.name的值为v
+ 如果'name'不是C.__dict__中的一个键，C.name将委托查找C的基类，这意味着将循环查找C的祖先类，并按照"方法解析顺序"在每个祖先类中查找name
**** 从实例获得属性
+ 当使用x.name语句引用类C的实例x的一个属性时，查询将执行以下步骤
  1. 当name作为一个覆盖描述器v的名称(即type(v)提供了__get__和__set__)在类C(或C的某个祖先类中)中被找到时，C.name的值就是调用type(v).__get__(v, x, C)的结果
  2. 否则，当name是x.__dict__中的一个键时，x.name将提取并返回x.__dict__['name']的值
  3. 否则，x.name将委托查找x的类，如果找到了一个描述器值v，则属性查找的全部结果还是type(v).__get__(v, x, C)；如果找到了一个非描述器值v，则属性查找的全部结果就是v
+ 当这些查找步骤没有找到任何一个属性时，python将引发一个AttributeError异常，但是，对于x.name的查找，如果C定义或继承了特殊方法__getattr__，python将调用C.__getattr__(x, 'name')，而不是引发该异常(然后根据__getattr__返回一个合适的值或引发一个适当的异常，通常是AttributeError)
**** 设置属性
+ 注意，只有在开发者引用属性，而不是在绑定属性时，才会按照以上方式执行属性查找
+ 在绑定(对类或实例)一个名称并不特殊的属性时(除非__setattr__方法、或覆盖描述器的__set__方法截断了实例属性的绑定)，只会影响属性的__dict__条目(分别在类或实例中)，即，在属性绑定的情况下，除非检查覆盖描述符，不涉及任何查询过程
*** 绑定和解除绑定方法
+ 函数对象的__get__方法可以返回一个包围该函数的解除绑定方法对象或一个绑定方法对象，解除绑定和绑定方法之间的关键区别是，解除绑定方法不与特殊实例相关联，而绑定方法则与之相关联
+ 在对实例x运行属性引用时将得到绑定方法，而在对类C运行属性引用时将得到解除绑定的方法
+ 开发者调用解除绑定方法的频率远远低于调用绑定方法，解除绑定方法最主要的用途就是访问覆盖方法，即便是对于这个任务，通常最好使用super内置函数
**** 解除绑定方法详解
+ 当对类的属性引用涉及一个函数时，对这个属性的引用将返回一个包围该函数的解除绑定方法，除了包围的那些函数对象，解除绑定方法还有3个属性:im_class是提供该方法的类对象、im_func是包围的函数，而im_self总是None，这些属性都是只读的，这意味着试图重新绑定或解除绑定任何一个属性都将引发异常
+ 开发者可以就像调用其im_func函数那样调用一个解除绑定的方法，但任何调用中的第一个参数必须是一个im_class实例或一个子孙实例，即，对解除绑定方法的调用必须至少有一个参数，这个参数对应于包围函数的第一个形式参数(按照惯例命名为self)
**** 绑定方法详解
+ 在查找过程中，在对一个实例的属性引用找到了一个作为该实例的类的属性的函数对象时，该查找过程将调用该函数的__get__方法以获得这个属性的值，在这种情况下，这个调用将创建并返回一个包围该函数的绑定方法
+ 在属性引用的查找过程在x.__dict__中找到了一个函数对象时，该属性引用操作并不会创建一个绑定方法，因为，这个函数没有被看作是一个描述符，并且该函数的__get__方法没有被调用；而是，该函数对象本身就是这个属性的值，同样，对于不是普通函数的可调用函数，也不会创建绑定方法，比如内置函数，因为这些函数不是描述符
+ 绑定方法与解除绑定方法类似之处在于，除了包围的那些函数对象之外，这两个方法还有3个只读属性，im_class是提供该方法的类对象，而im_func是包围的函数，但在绑定方法对象中，属性im_self指的就是x，也就是获得绑定方法的实例
+ 绑定方法的使用与其im_func函数类似，但对绑定方法的调用不会显示提供一个对应于第一个形式参数(按照惯例命名为self)的参数，在开发者调用绑定方法时，绑定方法将在调用程序给定其他参数(如果存在)之前，把im_self作为第一个参数传递到im_func中
+ 绑定方法对象时第一类对象，开发者可以在任何可以使用可调用对象的位置使用该方法，由于绑定方法包含对其包围的函数的引用，还包含可供执行的self对象，使其成为闭包的一个强大和灵活的选择，其类提供了特殊方法__call__的实例对象提供了另一种可行的选择
+ 绑定方法和可调用实例要比闭包更丰富，也更灵活，但闭包是最简单的
*** 继承
+ 在对一个类对象C使用属性引用C.name，且name不是C.__dict__中的键时，将按照特定顺序(出于历史原因，这个顺序被称为方法解析顺序(MRO)，尽管这个顺序可以用于所有属性，不仅仅是方法)对C.__bases__中的每个类对象隐式执行查找操作，查找操作将按MRO逐个检查直接和间接祖先，在name被找到时停止查找
**** 方法解析顺序(MRO)
+ 查找一个类中的属性名称本质上是按照从左到右，深度优先的顺序访问其祖先类来实现的，但在存在多重继承的情况下(这使得继承成为一个普通‘有向无环图’，而不是确定的树形图)，这个简单的方法可能会导致某些祖先类被访问两次，在这种情况下，通过查询序列中只保留最右边出现的任何给定类，这样可以理清解析顺序，这个最终的、至关重要的简化并不是传统对象模型规范的一部分，这使得多重继承很难在传统对象模式中正确和有效的使用，在这一点上，新型对象模型要好得多
+ 每个新型类和内置类型都包含一个名为__mro__的特殊只读类属性，这个属性是由按顺序排列的方法解析类型组成的元组，开发者可以只对类，而不对实例引用__mro__，且因为此属性为只读属性，开发者不能重新绑定或者解除绑定该属性
**** 覆盖属性
+ 当一个子类使用超类中的一个相同名称定义了一个属性时，搜索操作将找到子类中的定义，并停止搜索，这被称为子类覆盖了超类中的定义
**** 委托超类方法
+ 当子类C覆盖其超类B的方法f时，C.f的函数体通常应该将其操作的某些部分委托给超类的方法实现
**** 合作超类方法调用
**** "删除"类属性
+ 通过添加或覆盖子类中的属性，继承和覆盖提供了一种简单有效的方法来无损地(即不会修改定义这些属性的类本身)添加或删除类属性，但是，继承并没有提供一种方法来无损地删除(隐藏)基类的属性，如果该子类只是在定义(覆盖)一个属性时失败，python将找到基类的定义，如果开发者需要执行这样的删除，可能要执行以下操作
  - 覆盖这个方法并在方法体中引发一个异常
  - 避免继承，在子类的__dict__之外的任何位置保存属性，并为选择委托定义__getattr__
  - 使用新型对象模型并将__getattribute__覆盖为类似的效果
*** 内置object类型
+ 内置object类型是所有内置类型和新型类的祖先，object类型定义了一些实现了对象的默认语法的特殊方法
  1. __new__方法
  2. __init__方法
  3. __delattr__方法
  4. __getattribute__方法
  5. __setattr__方法
  6. __hash__方法
  7. __repr__方法
  8. __str__方法
+ 开发者可以通过调用不带任何参数的object()来创建对象的一个直接实例，该调用将隐式使用object.__new__和object.__init__以创建并返回一个不包含属性的实例对象(并且甚至不包含用来保存属性的__dict__)，这样一个实例对象可以被用作“标记”，用来保证与任何其他不同对象的不相等性比较
*** 类级方法(class-level method)
+ python提供了两种内置的非覆盖描述符类型，这为一个类带来了两种不同类型的“类级方法”
**** 静态方法
+ 静态方法是可以对类的任何实例进行调用的方法，静态方法没有普通方法(绑定和解除绑定方法)的特殊行为和限制，还与第一个参数有关
+ 静态方法可能会包含任何签名，该方法可能不带任何参数，并且其第一个参数(如果有)不具备任何特殊功能
+ 开发者可以将静态方法看作是一个可以正常调用的普通函数，尽管事实上静态方法有时候会被绑定到一个类属性上，尽管调用静态方法不是必须的(开发者总是可以定义一个普通函数来替代静态方法)，但是，当一个函数的目的紧密绑定到某些特殊类时，有些程序员将静态方法看作是一个很优美的实现方法
+ 要构建一个静态方法，可以调用内置类型staticmethod，并将其结果绑定到一个类属性上，与所有的类属性绑定一样，这通常可以在类体中完成，但开发者还可以选择在任何位置执行这个绑定操作
+ staticmethod的唯一参数就是python调用静态方法时要调用的函数
  #+BEGIN_SRC python
  class AClass(object):
      def astatic(): print('a static method')
      astatic = staticmethod(astatic)
  anInstance = AClass()
  Aclass.astatic()
  anInstance.astatic()
  #+END_SRC
**** 类方法
+ 类方法是一个可以对类或该类的任何实例进行调用的方法，python将这个方法的第一个参数绑定到可以调用该方法的类，或可以调用该方法的实例的类上
+ python不会像普通绑定方法那样，将第一个参数绑定到这个实例上，类方法并没有等同于解除绑定方法的方法
+ 按照惯例，类方法的第一个参数被命名为cls，尽管定义类方法并不是必须的(开发者总是可以有选择地定义一个普通函数，并类对象作为这个函数的第一个参数)，有些程序员将类方法看作是普通函数的一个优美的实现选择
+ 构建一个类方法，可以调用内置类型classmethod，并将其结果绑定到一个类属性上，与类属性的所有其他绑定一样，通常在类体内完成，但可以选择在任何其他位置执行进行绑定，classmethod的唯一参数就是在python调用该类方法时调用的函数
*** 属性
+ python提供了一个内置覆盖描述符类型，可以用来给定类的实例属性(property)
+ 属性是一个具有特殊功能的实例属性(attribute)，开发者可以使用普通语法引用、绑定或解除绑定该属性(例如，print(x.prop)x.prop=23,del x.prop)；但是，这些访问属性可以对实例x调用指定为其内置类型property参数的各种方法，而不是遵循用于属性引用、绑定和解除绑定的常规语法
**** 为什么属性很重要
+ 属性至关重要的地方在于，属性的存在使得开发者可以非常安全且确实可行地将公共数据属性作为类的公共接口的一部分开放出来，在开发者自己的类或其他需要成为多态类的将来版本中，如果有必要让一些代码在属性被引用、重新绑定或解除绑定时得到执行，开发者知道自己将可以把普通属性(attribute)更改为一个属性，且在不影响使用这个类(又名“客户代码”)的任何其他代码的情况下获得想要的效果
+ 这可以让开发者避免遇到一些由缺失属性或同等机制的面向对象(OO)语言所要求的愚蠢的习惯用法，比如访问和变异方法
+ 在任何时候，如果开发者有兴趣编写一些像getThis或setThat这样的接近自然名称的方法，为了更清楚的使用，可以考虑将这些方法包装为属性
**** 属性和继承
+ 属性通常是继承的，就像任何其他属性(attribute)一样，但不注意的话还是会落入一个小陷阱：为了访问一个属性而调用的方法是定义该属性本身的类中定义的那些方法，本质上并不会使用可能会出现在子类中的对这些方法的进一步覆盖
*** __slots__属性
+ 通常，任何类C的每个实例对象x包含一个字典x.__dict__，python使用该字典让开发者将任意属性(attribute)绑定到x上；如果想节省内存(比如某个类运行着几百万个实例)，开发者可以在一个新型类C中定义一个名为__slots__的类属性，也就是一个由字符串(通常是一些标识符)组成的序列(通常是一个元组)
+ 当新型类C包含一个属性__slots__时，类C的直接实例x将不包含x.__dict__，且任何试图在x上绑定任何名称不存在于C.__slots__中的属性时会引发一个异常
+ 使用__slots__属性的代价是以让实例x只有一个预定义的属性名称集合为代价，灵活性减小
*** __getattribute__方法
+ 所有对新型实例中实例属性的引用都是通过特殊方法__getattribute__来进行的，这个方法是由基类对象提供的
+ 开发者可能会覆盖__getattribute__用作特殊用途，比如为子类的实例隐藏继承的类属性
*** 按实例方法
+ 
*** 从内置类型继承
+ 通常，新型类最多只能作为一个实际内置类型的子类
** 特殊方法(名称以双下划线开始和结束的方法)
+ 类可以定义或继承特殊方法，每个特殊方法都与一个特殊操作相关，任何时候对一个实例对象执行相关操作时，python将会隐式调用一个特殊方法
+ 大多数情况下，这个特殊方法的返回值就是操作的结果，并在其相关方法没有显示引发了一个异常的情况下尝试这个操作
*** 通用目的的特殊方法
+ 某些特殊方法与通用目的的操作有关，定义或继承了这些方法的类允许其实例控制这样的操作，这些操作可以分成以下几类
  1. 初始化和终止化
     - 类可以通过特殊方法__new__(只适用于新型类)和__init__控制其实例的初始化(initialization经常需要)
     - 通过特殊方法__del__控制其实例的终止化(finalization很少需要)
  2. 表现为字符串
     类可以控制python如果通过特殊方法__repr__、__str__、__unicode__将其实例表现为字符串
  3. 布尔型环境中的比较、哈希和使用
     - 类可以东芝其实例如何与其他对象进行比较(使用特殊方法__lt__、__le__、__gt__、__ge__、__eq__、__ne__、__cmp__)
     - 可以控制字典如何将其实例用作键和设置为成员(__hash__方法)
     - 布尔型环境下这些实例的计算结果是True或False(__nonzero__方法)
  4. 属性引用、绑定和解除绑定
     - 类可以特殊方法__getattribute__(只适用于新型类)、__getattr__、__setattr__、__delattr__控制对其实例属性的访问
  5. 可调用实例
     如果实例的类包含特殊方法__call__，则该实例时可调用的，就像函数对象一样
*** 容器的特殊方法
+ 实例可以是一个容器(container)(这个容器可以是序列或映射，但不能同时都是，这两个概念是互斥的)，容器不仅提供了额外的特殊方法__getitem__、__setitem__、__delitem__、__len__、__contains__、__iter__，还提供了几个非特殊的方法
**** 序列
+ 在每个项目访问特殊方法中，一个包含L个项目的序列必须接受任何一个整数key(-L<=key<L)，为了与内置序列兼容，负的索引key(0>key>=-L)应该等于key+L
+ 对于没有定义__iter__的容器类,for语句可以实现迭代需要，就像使用可迭代参数的内置函数一样
+ 序列还必须允许使用+运算符串联和使用*运算符重复，因此序列必须包含特殊方法__add__、__mul__、__radd__、__rmul__
+ .....
**** 映射
+ 
**** 集合
+ 
**** 容器切片
*** 数值对象的特殊方法
+ 
** 装饰器(decorator)
+ @
** 元类(metaclass)
+ 任何对象，即使是一个类对象，都有一个类型，在python中，类型和类也都是第一类对象，类对象的类型称为该类的元类(metaclass)
*** python如何确定一个类的元类
*** 元类如何创建类
*** 定义和使用自定义元类
** self
+ Python默认把对象本身传给了方法的第一个参数
+ self指的是类实例对象本身(注意：不是类本身),Python编写类的时候，每个函数参数第一个参数都是self,首先明确的是self只有在类的方法中才会有，独立的函数或方法是不必带有self的。self在定义类的方法时是必须有的，虽然在调用时不必传入相应的参数
+ self名称不是必须的，在python中self不是关键词，你可以定义成a或b或其它名字都可以,但是约定成俗（为了和其他编程语言统一，减少理解难度）
+ self总是指调用时的类的实例,在继承时，传入的是哪个实例，就是那个传入的实例，而不是指定义了self的类的实例
* 异常 (exception)
+ python使用异常来通告错误和不寻常的情况，异常是一个对象，表示错误或不寻常的情况，开发者可以通过执行raise语句显式引发一个异常
+ 处理(Handling)异常表示从传播机制接收异常对象，并执行所需的各种操作以处理这种异常情况，如果一个异常处理程序不处理收到的异常，则该程序将在输出错误跟踪消息之后终止运行，不过，程序可以对异常进行处理，并在出现错误或其他反常的情况下仍保持运行
** try 语句
+ try语句提供了python的异常处理机制，是一个复合语句，可以采用两种不同的形式
  - try子句后面带一个或多个except子句(和一个可选的else子句)
    #+BEGIN_SRC python
    try:
        statements
    except [expression [, target]]:
        statements
    [else:
        statements]
    #+END_SRC
  - try子句后面只带一个finally子句
    #+BEGIN_SRC python
    try:
        statements
    finally:
        statements
    #+END_SRC
*** with 语句
*** 生成器增强功能
** 异常传播
+ 在引发一个异常时，异常传播机制将取得控制权，该程序的常规控制流将会停止，python将查找一个适当异常处理程序
** raise 语句
+ 开发者可以使用raise语句显式引发一个异常
  raise [expression1[, expression2]]
** 异常对象
+ 异常时内置Exception类的子类的实例
*** 标准异常的层次结构
*** 标准异常类
+ AssertionError
  断言语句失败
+ AttributeError
  属性引用或赋值失败
......
*** 自定义异常类
*** 自定义异常和多重继承
*** 标准库中使用的其他异常
*** 错误检查策略
**** LBYL对比EAFP
**** 在大程序中处理错误
**** 日志错误
**** assert语句
* 模块(module)
** 概述
+ 一个典型的python程序是由几个源文件组成的，每个源文件对应于一个模块，模块可以将程序代码和数据组合在一起以供重用
+ 模块通常是相互独立的，因此其他程序可以重用所需的特定模块，一个模块可以使用import或from语句与另一个模块建立依赖关系
+ python还支持扩展(extension)，也就是使用其他语言编写的组件(C、C++、Java或C#)
** 模块对象
+ 模块是一个python对象，包含一个任意命名的属性以供开发者绑定和引用，名为aname的模块的python代码通常保存在名为aname.py的文件中
+ 在python中，模块都是对象(值)，可以像处理其他对象那样处理模块，这样，开发者可以将一个模块作为参数传递的函数调用中，同样，函数可以返回一个模块作为函数调用的结果，可以被绑定到一个变量、容器的一个项目或对象的一个属性上
*** import 语句
+ 开发者可以将任何python源文件用作一个模块，通过在其他一些python源文件中执行一个import语句实现，import语句为
  import modname [as varname][,...]
**** 模块体
+ 模块体就是模块的源文件中的语句序列，指示一个源文件就是一个模块并不需要特殊的语法；任何合法的python源文件都可以被用作一个模块
+ 当运行的程序第一次导入一个模块时，将立即执行该模块的模块体，在执行模块体期间，模块对象已经存在，而且sys.modules中的一个条目已经被绑定到该模块对象上，并在模块体执行时逐步进行组装
**** 模块对象的属性
+ import语句可以创建一个新的命名空间，其中包含一个模块的所有属性，要访问这个命名空间中的一个属性，可以使用这个模块的名称作为前缀
  import MyModule
  a = MyModule.f()
  或
  import MyModule as Alias
  a = Alias.f()
+ 模块对象的属性通常是使用该模块体中的语句来绑定的，当模块体中的一条语句绑定一个变量(全局变量)时，其实绑定的是该模块对象的一个属性，模块体的一般用途实际上就是创建模块的属性：def语句可以用来创建和绑定函数，class语句可以用来创建和绑定类，赋值语句可以绑定任何类型的属性
+ 开发者还可以绑定和解除绑定模块体之外(也就是，在其他模块中)的模块属性，通过使用属性引用语法M.name(其中M是任意值为该模块的表达式，而标识符name就是属性名称)，但为了让程序更清楚，通常最好将查询限定为只绑定该模块体内本身的模块属性
+ 只要import语句创建了模块对象，在模块体执行之前，该语句将隐式设置某些模块属性
  - __dict__属性是一个字典对象，该模块将把这个字典对象作为其属性的命名空间，与这个模块的所有其他属性不同，__dict__不可以作为该模块中的一个全局变量进行编程，这个模块中的所有其他属性都是该模块的__dict__中的条目，且可以作为该模块中的一个全局变量进行编程
  - __name__是这个模块的名称
  - __file__是用来加载该模块的文件的名称
+ 对于任意模块对象M、任意对象x，和任意标识符字符串S(除__dict__之外)，绑定M.S=x等同于绑定M.__dict__['S']=x
**** python内置对象
+ python提供了几种内置对象，所有内置对象都是名为__builtin__的预加载模块的属性
+ 查找是python用来使用代码访问内置对象的唯一机制，这个内置的名称不是保留的，在python中也不是固定的
**** 模块文档字符串
+ 如果模块体中的第一个语句是一个字符串字面常量，编译器将把这个字符串绑定为该模块的文档字符串属性，名为__doc__，也称为docstrings
**** 模块私有变量
+ 模块中没有变量是真正私有的，但按照惯例，以单个下划线开始的标识符，比如_name，表示这个标识符是私有的，即告知客户代码程序员，不能直接访问这个标识符
+ 开发环境和其他工具依赖于起始下划线命名惯例来辨识另一个模块的哪些属性是公有的(部分模块的接口)和哪些属性是私有的(只能在该模块内使用)
+ 使用其他人编写的模块编写客户代码时，遵循这个惯例是特别重要的，换句话说，就是在名称以下划线开始的这些模块中避免使用任何属性，毫无疑问，这些模块的将来版本将维护其公有接口，但非常有可能更改私有实现的细节，且私有属性可以确切的表明这些实现细节
*** from 语句
+ from语句可以将特定属性从一个模块导入当前命名空间，语法为两种
  from modname import attrname [as varname][,...]
  from modname import *
+ from语句指定了一个模块名，后面带有一个或多个使用逗号分隔的属性指定符，在最常见的情况下，属性指定符只是一个标识符attrname，这个标识符是python绑定到名为modname的模块中相同名称的属性的一个变量
+ modname还可以是一个由句点分隔的标识符组成的序列，用来命名包中的一个模块
**** from...import * 语句
+ 直接位于模块体内(而不是在一个函数体或类体内)的代码可以在from语句中使用*
+ 要求模块modname的所有属性被绑定为导入模块中的全局变量，在模块modname具有一个名为__all__的属性时，该属性的值就是被这种类型的from语句绑定的属性列表，否则，这种类型的form语句将绑定模块modname中除了那些以下划线开始的属性之外的所有属性
+ 由于可以绑定任意集合的全局变量，因此可能经常产生无法预料和不想发生的负面影响，比如隐藏内置对象和重新绑定仍然需要使用的变量，总体来讲，使用from语句的*号形式要非常小心，通常情况下，永远不使用这种方式
**** from对比import
+ 一般来说，import语句比from语句时更好的选择
+ 只有在交互方式python会话中，才将from，尤其是from *，看作是比较方便的方法
+ from的一个很好的用法是从包导入特定模块，但在绝大部分情况下，import要比from更好
** 模块加装
+ 模块加装操作依赖于内置sys模块的属性，开发者可以在代码中使用模块名字符串作为一个参数直接调用__import__，将返回这个模块对象，如果导入失败，则引发ImportError
+ 为了导入一个名为M的模块，__import__将首先检查字段sys.modules,并使用字符串M作为键，在键M存在于这个字典中时，__import__将返回对应值作为请求的模块对象，否则，__import__将使用M的一个__name__把sys.modules[M]绑定到一个新的空白模块对象上，然后查找正确的方法来实例化(加载)该模块
*** 内置模块
+ 在模块被加载后，__import__将首先检查该模块是否是内置模块，元组sys.builtin_module_names中列出了内置模块，但是重新绑定这个元组不会影响模块的加载
+ 在python加载一个内置模块时，且在python加载任何其他扩展时，python将调用该模块的初始化函数
+ 搜索内置模块还会在平台的特定位置查找模块(Mac上的资源和框架、windows的注册表)
*** 在文件系统中搜索模块
+ 如果模块M不是内置的，__import__将查找M的代码，就像查找文件系统中的文件，__import__将按顺序查看字符串，这些字符串是类别sys.path中的项目，每个项目都是一个目录的路径或是一个普通的zip格式压缩文件的路径
+ sys.path是程序启动的时候使用环境变量PYTHONPATH初始化的，sys.path中的第一个项目永远是主程序(脚本)被加载的目录，sys.path中的空白字符串表示当前字符串
+ 代码可以变异或重新绑定sys.path，而这样的更改将影响__import__搜索哪些目录和ZIP压缩文件来加载模块
+ 如果系统启动时在PYTHONHOME目录中找到了扩展名为.pth的文本文件，这个文件的内容将被添加到sys.path中，每行一个项目，.pth文件可以包含空白行和易字符#开始的注释行；python将忽略这些行.pth文件还可以包含import语句，但不包含其他类型的语句，python将在开发者的程序开始执行之前执行这些import语句
+ 在sys.path中的每个目录和ZIP压缩文件中的文件中查找模块M时，python将按项目列出的顺序查找以下扩展名
  1. .pyd和.dll(windows)或.so(大多数类unix平台)，这比赛python扩展模块，在大多数平台上不能从一个ZIP压缩文件中加载扩展
  2. .py 纯python源模块
  3. .pyc(或.pyo)表示编译的字节代码python模块
+ 在文件中查找模块M时，python查找文件的最后一个路径是M/__init__.py这是名为M的目录中的一个名为__init__.py的文件
+ 在查找源文件M.py时，python将把这个文件编译厂M.pyc(或M.pyo)，除非字节代码文件以及存在、要比M.py更新，且是使用python相同版本编译的
+ 一个简易的方法加载子目录中.py(自定义模块)，是使用from 子目录 import 文件名
*** 主程序
+ python应用程序的执行通常是从最顶层的脚本开始的(也被称为主程序main program)，主程序的执行就像加载任何其他模块一样，区别只是python将在内存中保存该字节代码，而不是将其保存到硬盘中
+ 主函数的模块名永远是__main__，同时作为__name__全局变量(模块属性)和sys.modules中的键
+ 开发者通常不能导入被用作主程序的相同.py文件，如果这么做了，这个模块将被再次加载，且该模块体将在一个单独的模块对象中使用不同的__name__从顶部开始再次被执行
+ python模块中的代码可以通过检查全局变量__name__是否等于__main__来测试这个模块是否被用作主程序
  #+BEGIN_SRC python
  if __name__ == '__main__':
  #+END_SRC
  这行代码通常用于守卫某些代码，因此，这行代码只有在模块作为主程序运行时才会执行
+ 如果一个模块被设计为只能被导入，则在该模块作为主程序运行时，通常必须执行单元测试
*** reload 函数
+ 在程序运行时，python只在第一次导入模块时加载该模块，在进行交互式开发时，开发者需要确保模块在每次编辑时都被重新加载，想要重新加载一个模块，可以将该模块对象(而不是模块名)作为内置函数reload的唯一参数
+ reload(M)不会对绑定到M的属性的以前值的其他现有引用产生任何影响，即已经被绑定的变量仍然是被绑定的，不会受reload的影响
+ reload不是递归的，开发者必须通过显示调用reload进行特别安排以重新加载修改的所有模块
*** 循环导入
+ python可以指定循环导入，例如开发者可以编写一个包含import b的模块a.py，而模块b.py包含import a，实际上避免循环导入通常更好一些
*** sys.modules条目
+ 内置__import__函数绝不会绑定除了模块对象之外的任何对象作为sys.modules中的值，但如果__import__找到了一个已经在sys.modules中的条目，该函数将返回这个值，不管对象的类型是什么
+ import和from语句依赖于__import__函数，因此这两条语句也可以使用不是模块的对象来结束
*** 自定义导入器
+ python提供的一个高级，但极少需要的功能就是可以更改语义，或某些或全部import和from语句
**** 重新绑定__import__
+
**** 导入钩子
+ 
** 包(package)
*** 概述
+ 包是一个包含其他模块的模块，包中的某些或所有模块也有可能是子包，这样会产生一个树形层次结构
+ 名为P的包被保存在sys.path中某些目录的一个子目录中，这个子目录也叫做P，包可以存放在ZIP文件中
+ P的模块体在文件P/__init__.py中，开发者必须有一个名为P/__init__.py的文件，即使该文件是空白的(表示一个空白模块体)，这是为了向python指示目录P确实是一个包
+ 包的模块体是在第一次导入该包(或这个包的任何模块)的时候被加载的，这些操作从所有方面看都想任何其他python模块，目录P中的其他.py文件都是包P的模块，包含__init__.py文件的P的子目录都是P的子包
+ 开发者可以在包P中导入一个名为M的模块，作为P.M；更多的句点表示可以导航到包层次结构中(包的模块体总是在包中的任何模块被加载之前被加载)
+ 使用from P import M从包P导入特定模块M是一个完全可以接受的实现方案，这种情况下，from语句时特别好的
*** 包对象的特殊属性
+ 包P的__file__属性是一个字符串，指示P的模块体的路径即文件P/__init__.py的路径
+ 包P的模块体即文件P/__init__.py中的python源代码可以有选择的设置一个名为__all__的全局变量(就像任何其他模块可以做的那样)，用来控制在其他一些模块执行了语句from P import * 时发生的操作，特别是，如果没有设置__all__，from P import *不会导入P的模块，但只导入P的模块体中设置的其他名称，但在任何情况下，使用from P import *都不是一个推荐用法
+ 包P的__path__属性是一个由目录的路径字符串组成的列表，P的模块和子包都是从这些目录被加载的
*** 绝对导入和相对导入
** 发布工具(distutils)
+ 压缩文件
  windows中的.zip文件和类unix系统的.tar.gz文件
+ 自动解包或自动安装可执行文件
  通常是windows中的.exe文件
+ 自包含的，不要求安装的预备运行可执行程序
  windows中的.exe文件、unix上带有一个小的脚本前缀的zip压缩文件、mac的.app文件
+ 平台相关安装程序
  windows上的.msi文件、linux的.rpm文件等
+ python蛋
  一个非常流行的第三方扩展
* 核心内置
** 概述
+ 在python中，术语“内置”(built-in)具有多重含义，在大多数情况下，python内置表示一个不需要使用import语句就可以直接被python代码访问的对象
** 内置类型
+ basestring
  类型str和unicode的非可实例化(抽象)公共基类型，主要用于通过测试isinstance(x, basestring)确定某个对象x是否是一个字符串(不管是纯文本还是Unicode)
+ bool
  - bool(x)如果参数x的计算结果为假，则返回False；如果参数x的计算结果为真，则返回True
  - bool是int的一个子类，内置名称False和True表示类型bool的唯一两个实例，这两个实例也是整数，分别等于0和1，但是str(True)是'True'，而str(False)是'False'
+ buffer
  - buffer(obj, offset=0, size=-1)返回一个只读缓冲区对象，表示obj数据的压缩切片，从给定的offset开始，大小(size)已经给定，obj必须是支持缓冲区调用接口的类型，比如字符串或数组
+ classmethod
  - classmethod(function)返回一个类方法对象，实际上，只能在类体中调用这个内置类型
+ complex
  - complex(real, imag=0)将任何数字或适当的字符串转换为复数
+ dict
  - dict(x={})返回一个新字典对象，包含与参数x相同的项目
+ enumerate
  - enumerate(iterable)返回一个项目为数据对的新迭代器对象
+ file,open
  - file(path,mode='r',bufsize=-1)
    open(filename,mode='r',bufsize=-1)
    打开或创建一个文件并返回一个新文件对象
+ float
  - float(x)将任何数字或适当的字符串转换为浮点型数字
+ frozenset
  - frozenset(seq=[])返回一个新的固定(不可变)集合对象
+ int
  - int(x[, radix])将任何数字或适当的字符串转换为int型
+ list
  - list(seq=[])返回一个新列表对象
+ long
  - long(x[, radix])将任何数字或适当的字符串转换为长整型
+ object
  - object()返回最基本类型的一个新实例
+ property
  - property(fget=None,fset=None,fdel=None,doc=None)返回一个属性指定符
+ reversed
  - reversed(seq)返回一个新迭代器对象
+ set
  - set(seq=[])返回一个新的可变集合对象
+ slice
  - slice([start,]stop[,step])返回一个包含只读属性start、stop、step的切片对象
+ staticmethod
  - staticmethod(fuction)返回一个静态方法对象
+ str
  - str(obj)返回obj对象的一个简洁和可读的字符串表示
+ super
  - super(cls, obj)返回适合于调用超类方法的对象obj
+ tuple
  - tuple(seq)返回一个与可迭代对象seq具有相同项目，按相同顺序排列的元组
+ type
  - type(obj)返回类型为obj的类型对象
+ unicode
  - unicode(string[,codec[,errors]])返回由解码string获得的Unicode字符串对象
+ xrange
  - xrange([start,]stop[,step=1])返回一个只读序列对象，其中的项目是等差数列中的整数
** 内置函数
*** 概述
+ 内置函数即在模块__builtin__中可用的python函数
+ 这些内置函数的名称都不是保留字，因此，开发者的程序可以出于某种目的，在本地或全局范围内绑定一个与内置函数具有相同名称的标识符，在本地或全局范围内绑定的名称要比内置范围内绑定的名称的优先级更高
+ 大多数内置函数和类型相似，通常不能使用命名参数进行调用，只能使用位置参数
*** 常用内置函数
+ __import__()
  __import__(module_name[,globals[,locals[,fromlist]]])加载以字符串module_name命名的模块，并返回结果模块对象
+ abs()
  - abs(x)返回数字x的绝对值
+ all()
  - all(seq) seq是任意一个可迭代的参数
+ any()
  - any(seq) seq是任意一个可迭代的参数
+ callable()
  - callable(obj)如果obj可以被调用，返回True，否则False
+ chr()
  - chr(code)返回一个长度为1的字符串
+ cmp()
  - cmp(x,y)在x等于y时返回0，在x小于y是返回-1，在x大于y是返回1
+ coerce()
  - coerce(x,y)返回一个数值对
+ compile()
  - compile(string,filename,kind)编译一个字符串，返回一个可以被exec或eval使用的代码对象
+ delattr()
  - delattr(obj,name)从obj中删除属性name
+ dir()
  - dir([obj])如果调用dir()时不带任何参数，返回一个包含当前范围内绑定的所有变量名称的排序列表，而dir(obj)将返回一个包含obj的所有属性名称的排序列表
+ divmod()
  - divmod(dividend,divisor)两个数字相除，返回一个数值对，分别是商和余数
+ eval()
  - eval(expr,[globals[,locals]])返回一个表达式的结果
+ execfile()
  - execfile(filename,[globals[,locals]])
+ filter()
  - filter(func,seq)构建一个由seq中的项目组成的列表，列表中的项目可以让func的结果为真
+ getattr()
  - getattr(obj,name[,default])返回由字符串name命名的obj的属性
+ globals()
  - globals()返回调用模块的__dict__
+ hasattr()
  - hasattr(obj,name)如果obj没有属性name则返回False，否则True
+ hash()
  - hash(obj)返回obj的哈希值
+ hex()
  - hex(x)将整数x转换为十六进制字符串表示
+ id()
  - id(obj)返回一个用来表示obj内存地址的标识的整数值
+ input()
  - input(prompt='')是eval(raw_input(prompt))的快捷方式，可以提示用户输入行，将结果字符串计算为一个表达式，并返回这个表达式的结果
+ intern()
  - intern(string)确保string被保存在一个由内部化字符串组成的表中，并返回string本身或一个副本
+ isinstance()
  - isinstance(obj,cls)在obj是类cls(或cls的任意子类)的一个实例，或在cls是一个类型的对象，而obj是这个类型的对象时，返回True；其中cls还可以是一个元组，其中的项目都是类或类型，在这种情况下，如果obj是元组cls中任何一个项目的实例，则返回True
+ issubclass()
  - issubclass(cls1,cls2)如果cls1是cls2的一个直接或间接子类，返回True
+ iter()
  - iter(obj)
  - iter(func,sentinel)
  - 创建并返回一个迭代器，迭代器是一个具有next方法的对象
+ len()
  - len(container)返回容器container中项目的数量，这个容器可以是序列、映射或集合
+ locals()
  - locals()返回一个表示当前本地命名空间的字典
+ map()
  - map(func,seq,*seqs)对seq中的每个项目应用func函数，并返回一个结果列表
+ max()
  - max(s,*args)返回唯一的参数s(s必须是可迭代的)或多个参数中最大的参数中的最大项目
+ min()
  - min(s,*args)返回唯一参数s(s必须是可迭代的)或多个参数中最小的参数中的最小项目
+ oct()
  - oct(x)将整数x转换为八进制的字符串表示
+ ord()
  - ord(ch)返回单字符字符串ch的0到255(包含)之间的ASCII/ISO整数代码
+ pow()
  - pow(x,y[,z])在给出了z时，pow(x,y,z)将返回x**y%z
+ range()
  - range([start,]stop[,step=1])按等差数列返回一个整数列表
+ raw_input()
  - raw_input(prompt='')向标准输出写入prompt
+ reduce()
  - reduce(func,deq[,init])从左到右对seq中的项目应用func
+ reload()
  - reload(module)重新加载和重新实例化模块对象module
+ repr()
  - repr(obj)返回obj的一个完整和明确的字符串表示
+ round()
  - round(x,n=0)返回一个浮点型数字
+ setattr()
  - setattr(obj,name,value)将obj的属性name绑定到value
+ sorted()
  - sorted(seq,cmp=None,key=None,reverse=False)返回一个按排序顺序的，与可迭代对象seq具有相同项目的列表
+ sum()
  - sum(seq,start=0)返回可迭代对象seq(seq必须是数字，特别是，不能是字符串)中项目，再加上start的值的和
+ unichr()
  - unichr(code)返回一个Unicode字符串
+ vars()
  - vars([obj])不带参数时vars()返回一个表示当前范围内(就像locals一样)被绑定的所有变量的字典；vars(obj)返回当前obj中绑定的所有属性
+ zip()
  - zip(seq,*seqs)返回一个元组列表，其中的第n个元组包含来自于每个参数序列的第n个元素，zip必须可以使用至少一个参数调用，并且所有参数必须是可迭代的
** sys模块
*** 概述
+ sys模块的属性都被绑定到可以提供python解释器的状态或直接影响python解释器的运行的数据和函数上
*** 常用属性
+ argv
+ displayhook()
  - displayhook(value)
+ execepthook()
  - execpthook(type,value,traceback)
+ exc_info()
  - exc_info()
+ exit()
  - exit(arg=0)产生一个SystemExit异常
+ getdefaultencoding()
  - getdefaultencoding()返回用来编码和解码Unicode和字符串对象(通常是ascii)的默认编码器名称
+ getrefcount()
  - getrefcount(object)返回对象object的引用次数
+ getrecursionlimit()
  - getrecursionlimit()返回python调用堆栈深度的当前限定值
+ _getframe()
  - _getframe(depth=0)返回一个来自调用堆栈的框架对象
+ maxint
  - 当前版本的python中最大的整数
+ modules
  - 一个字典，其中的项目是所有加载的模块的名称和模块对象
+ path
  - 一个字符串列表，指定了python在查找要加载的模块时搜索的字典和zip文件
+ platform
  - 一个字符串，表示这个程序正在运行的平台的名称
+ ps1，ps2
  - 指定了主要和次要解释器提示符字符串，其初始值分别是>>>和...
+ setdefaultencoding()
  - setdefaultencoding(name)设置用来编码和解码Unicode和字符串对象(通常是ascii)的默认编码解码器
+ setprofile()
  - setprofile(profilefunc)设置一个全局配置文件函数
+ setrecursionlimit()
  - setrecursionlimit(limit)设置python的调用堆栈的深度限定值(默认1000)
+ settrace()
  - settrace(tracefunc)设置一个全局跟踪函数
+ stdin,stdout,stderr
  - 都是预定义的文件对象，这些文件对象对应于python的标准输入、输出和错误流
+ tracebacklimit
  - 显示未经处理的跟踪的最大层数
+ version
  - 一个字符串，表明python的版本、编译好和日期及使用的C编译器
** copy模块
*** 概述
+ python中赋值语句并不复制被赋值的右边对象，而是，赋值语句将向右边对象添加一个引用
+ 开发者想要获得对象x的一个副本时，可以要求x创建x的一个副本、或可以要求x的类型创建从x赋值的一个新实例
+ 如果x是一个列表时，list(x)将返回x的一个副本，就像x[:]一样；如果x是一个字典，dict(x)和x.copy()将返回x的一个副本；如果x是一个集合，set(x)和x.copy(将返回x的一个副本)
+ copy模块提供了一个copy函数以创建并返回多个对象类型的一个副本，普通副本(比如，列表x的list(x)和copy.copy(x))也称为浅副本(shallow):在x具有其他对象(比如项目或属性)的引用时，x的一个普通副本也具有相同其他对象的不同引用，但有时候开发者需要一个深副本(deep)，其中引用的对象都被递归复制，这种需求极少，深副本需要花费大量的内存和时间
*** 常用方法
+ copy()
  - copy(x)为多种类型的x创建并返回x的一个浅副本(不支持几种类型的副本：模块、类、文件、框架和其他内部类型)
+ deepcopy()
  - deepcopy(x,[memo])创建x的一个深入副本
** collections模块
+ 提供了几种有趣的集合(容器)
*** deque
+ 双端队列即适合于在两端添加和删除的类似于序列的容器
*** defaultdict
+ defaultdict是dict的子类
** function模块 
+ 提供了几种有趣的函数和类型以支持python的功能编程
** bisect模块
+ 可以在项目插入到一个列表中时使用二分算法保持这个列表的排序顺序
** heapq模块
+ 可以在项目被插入到列表和从列表中提取时使用堆(heap)算法保持这个列表的近似排序顺序
** UserDict模块
+ 
** optparse模块
+ 提供了非常丰富和强大的方法以解析用户传递的用来运行python程序
** itertools模块
+ 提供了许多强大的、高性能的功能模块来建立或操作迭代器对象
* 字符串和正则表达式
** 
* 库和扩展模块
** 文件和文本操作
** 持久化和数据库
** 时间操作
** 控制执行
** 线程和进程
** 数值处理
** 数组处理
** Tkinter GUI
** 测试、调试和最优化
* 网络和web编程
** 客户端网络协议模块
*** URL访问
*** Email协议
*** HTTP和FTP
*** 网络新闻
*** Telnet
*** 分布式计算
*** 其他协议
** 套接字和服务器端网络协议模块
*** socket模块
*** SocketServer模块
*** 事件驱动套接字程序
** CGI脚本和其他解决方案
*** python中的CGI
*** Cookie
*** 其他服务器端方案
** MIME和网络编码方式
*** 将二进制数据编码为文本
*** MIME和Email格式处理
** 结构化文本HTML
*** sgmllib模块
*** htmllib模块
*** HTMLParser模块
*** BeautifulSoup扩展
*** 生成HTML
** 结构化文本XML
* 扩展和嵌入
** 扩展和嵌入经典python
*** 使用python的C API扩展python
*** 不使用python的C API扩展python
*** 嵌入python
*** Pyrex
** 扩展和嵌入Jython
*** 在Jython中导入java包
*** 在java中嵌入jython
*** 将python编译到java中
** 发布扩展和程序
*** python的distutils
*** py2exe
*** py2app
*** cx_Freeze
*** Pyinstaller
* 打包工具
** PyInstaller
+ 能够在 Windows、Linux、 Mac OS X 等操作系统下将 Python 源文件打包，通过对源文件打包， Python 程序可以在没有安装 Python 的环境中运行，也可以作为一个 独立文件方便传递和管理
*** 安装
+ pip
  #+BEGIN_SRC shell
  pip install pyinstaller
  #+END_SRC
*** 语法
#+BEGIN_SRC shell
#命令语法：pyinstaller -F 文件名（带后缀py）
#常用参数说明：
#–icon=图标路径
#-F 打包成一个exe文件
#-w 使用窗口，无控制台
#-c 使用控制台，无窗口
#-D 创建一个目录，里面包含exe以及其他一些依赖性文件
#pyinstaller -h 来查看参数

#将cmd的目录切换至（命令：cd 文件路径(注意空格)）需要打包的py文件目录下：
#有命令窗口弹出
pyinstaller -F shjys_rjjqk.py  
#无命令窗口弹出
pyinstaller -F -w shjys_rjjqk.py  
#或者
pyinstaller -F shjys_rjjqk.py  --noconsole
#+END_SRC
* python工作
** EXECL
*** Excel文档基本定义
+ 工作簿(workbook)： 一个 Excel 电子表格文档
+ 工作表(sheet)： 每个工作簿可以包含多个表, 如： sheet1， sheet2等
+ 活动表(active sheet)： 用户当前查看的表
+ 列(column): 列地址是从 A 开始的
+ 行(row): 行地址是从 1 开始的
+ 单元格(cell)： 特定行和列的方格
*** 安装 openpyxl 模块
+ 安装模块
  #+BEGIN_SRC shell
  pip install openpyxl
  #+END_SRC
*** 读取 Excel 文档
+ 使用 openpyxl.load_workbook()函数。打开 Excel 文档
  #+BEGIN_SRC python
  wb = openpyxl.load_workbook('excelDemo/example.xlsx')    # 加载工作薄
  wb.sheetnames                                       # 获取当前所有工作表的名称， 返回一个列表 
  wb.active                                           # 获取当前活跃的工作表 
  #+END_SRC
+ 从工作簿中取得工作表
  #+BEGIN_SRC python
  sheet = wb['Sheet1']                # 工作表
  sheet.title                         # 获取当前活动表的名称
  sheet.cell(row=1, column=2)         #  获取单元格指定行和指定列的内容
  #+END_SRC
+ 表中取得单元格
  - Cell 对象有一个 value 属性,不出意外,它包含这个单元格中保存的值。Cell 对象也有 row、column 和 coordinate 属性,提供该单元格的位置信息
  - row属性给出的是整数 1,column 属性给出的是'B',coordinate 属性给出的是'B1'
  #+BEGIN_SRC python
  cell = sheet['A1']
  cell_value = sheet['A1'].value
  cell.row, cell.column cell.coordinate
  #+END_SRC
*** 操作行
+ 获取最大行
  #+BEGIN_SRC python
  sheet_sumfile_sum.max_row
  #+END_SRC
+ 删除行
  #+BEGIN_SRC python
  sheet_sumfile_sum.delete_rows(5, 1)  #从第五行开始，删除1行
  #+END_SRC
*** 工作簿、工作表、单元格
+ 从电子表格文件中读取单元格涉及的所有函数、方法和数据类型。一个完整的操作过程如下
  - 导入 openpyxl 模块
  - 调用 openpyxl.load_workbook()函数
  - 取得 Workbook 对象
  - 调用 wb.sheetnames和 wb.active 获取工作簿详细信息
  - 取得 Worksheet 对象
  - 使用索引或工作表的 cell()方法,带上 row 和 column 关键字参数
  - 取得 Cell 对象
  - 读取 Cell 对象的 value 属性
#+BEGIN_SRC python
import openpyxl


# 1. 读取excel文档
wb = openpyxl.load_workbook('excelDemo/example.xlsx')

# # 返回一个workbook对象， 有点类似于文件对象;
# print(wb, type(wb))



# 2. 在工作薄中取得工作表
# print(wb.get_sheet_names())
# 返回一个列表， 存储excel表中所有的sheet工作表;
print(wb.sheetnames)

# 返回一个worksheet对象， 返回当前的活动表;
# print(wb.get_active_sheet())
# print(wb.active)



# 3. 获取工作表中， 单元格的信息
# wb.get_sheet_by_name('Sheet1')
sheet = wb['example']
print(sheet['A1'])
print(sheet['B1'].value)

cell = sheet['B1']
print(cell.row, cell.column)


print(sheet.cell(row=3, column=2))
print(sheet.cell(row=3, column=2).value)
print(sheet.cell(row=3, column=2, value='www'))


# sheet的属性

print(sheet.max_column)
print(sheet.max_row)
print(sheet.title)
sheet.title = 'example'
print(sheet.title)


for row in sheet.rows:
    for cell in row:
        print(cell.value, end='\t')
    print('\n')

wb.save(filename="excelDemo/example.xlsx")

#+END_SRC
** 文件操作
*** 导入必要模块
+ 常用模块
  #+BEGIN_SRC python
  import os 
  import os.path 
  import shutil 
  import time,  datetime
  #+END_SRC
*** 判断目录、文件是否存在
+ 判断资源是否为文件或目录
  #+BEGIN_SRC python
  os.path.isfile(sourceFile)
  os.path.isdir(sourceFile)
  #+END_SRC
+ 判断目录是否存在
  #+BEGIN_SRC python
  import os
  dirs = '/Users/joseph/work/python/'

  if not os.path.exists(dirs):
      os.makedirs(dirs)
  #+END_SRC

+ 判断文件是否存在
  - 1
    #+BEGIN_SRC python
    import os
    filename = '/Users/joseph/work/python/poem.txt'

    if not os.path.isfile(srcfile):
        print "%s not exist!"%(srcfile)
    #+END_SRC

  - 2
    #+BEGIN_SRC python
    
    #+END_SRC
  
*** 复制文件
+ shutil.copy(src_file,file_dir) 不重命名文件
+ shutil.copyfile(file1,file2) 需要指定新文件名
*** 常规操作
+ python中对文件、文件夹（文件操作函数）的操作需要涉及到os模块和shutil模块
  - 得到当前工作目录，即当前Python脚本工作的目录路径: os.getcwd()
  - 返回指定目录下的所有文件和目录名:os.listdir()
  - 函数用来删除一个文件:os.remove()
  - 删除多个目录：os.removedirs（r“c：\python”）
  - 检验给出的路径是否是一个文件：os.path.isfile()
  - 检验给出的路径是否是一个目录：os.path.isdir()
  - 判断是否是绝对路径：os.path.isabs()
  - 检验给出的路径是否真地存:os.path.exists()
  - 返回一个路径的目录名和文件名:os.path.split()     eg os.path.split('/home/swaroop/byte/code/poem.txt') 结果：('/home/swaroop/byte/code', 'poem.txt')
  - 分离扩展名：os.path.splitext()
  - 获取路径名：os.path.dirname()
  - 获取文件名：os.path.basename()
  - 运行shell命令: os.system()
  - 读取和设置环境变量:os.getenv() 与os.putenv()
  - 给出当前平台使用的行终止符:os.linesep    Windows使用'\r\n'，Linux使用'\n'而Mac使用'\r'
  - 指示你正在使用的平台：os.name       对于Windows，它是'nt'，而对于Linux/Unix用户，它是'posix'
  - 重命名：os.rename（old， new）
  - 创建多级目录：os.makedirs（r“c：\python\test”）
  - 创建单个目录：os.mkdir（“test”）
  - 获取文件属性：os.stat（file）
  - 修改文件权限与时间戳：os.chmod（file）
  - 终止当前进程：os.exit（）
  - 获取文件大小：os.path.getsize（filename）
+ 文件操作
  - os.mknod("test.txt")        创建空文件
  - fp = open("test.txt",w)     直接打开一个文件，如果文件不存在则创建文件
    关于open 模式：
    w     以写方式打开，
    a     以追加模式打开 (从 EOF 开始, 必要时创建新文件)
    r+     以读写模式打开
    w+     以读写模式打开 (参见 w )
    a+     以读写模式打开 (参见 a )
    rb     以二进制读模式打开
    wb     以二进制写模式打开 (参见 w )
    ab     以二进制追加模式打开 (参见 a )
    rb+    以二进制读写模式打开 (参见 r+ )
    wb+    以二进制读写模式打开 (参见 w+ )
    ab+    以二进制读写模式打开 (参见 a+ )
  - fp.read([size])                     #size为读取的长度，以byte为单位
  - fp.readline([size])                 #读一行，如果定义了size，有可能返回的只是一行的一部分
  - fp.readlines([size])                #把文件每一行作为一个list的一个成员，并返回这个list。其实它的内部是通过循环调用readline()来实现的。如果提供size参数，size是表示读取内容的总长，也就是说可能只读到文件的一部分。
  - fp.write(str)                      #把str写到文件中，write()并不会在str后加上一个换行符
  - fp.writelines(seq)            #把seq的内容全部写到文件中(多行一次性写入)。这个函数也只是忠实地写入，不会在每行后面加上任何东西。
  - fp.close()                        #关闭文件。python会在一个文件不用后自动关闭文件，不过这一功能没有保证，最好还是养成自己关闭的习惯。  如果一个文件在关闭后还对其进行操作会产生ValueError
  - fp.flush()                                      #把缓冲区的内容写入硬盘
  - fp.fileno()                                      #返回一个长整型的”文件标签“
  - fp.isatty()                                      #文件是否是一个终端设备文件（unix系统中的）
  - fp.tell()                                         #返回文件操作标记的当前位置，以文件的开头为原点
  - fp.next()                                       #返回下一行，并将文件操作标记位移到下一行。把一个file用于for … in file这样的语句时，就是调用next()函数来实现遍历的。
  - fp.seek(offset[,whence])              #将文件打操作标记移到offset的位置。这个offset一般是相对于文件的开头来计算的，一般为正数。但如果提供了whence参数就不一定了，whence可以为0表示从头开始计算，1表示以当前位置为原点计算。2表示以文件末尾为原点进行计算。需要注意，如果文件以a或a+的模式打开，每次进行写操作时，文件操作标记会自动返回到文件末尾。
  - fp.truncate([size])                       #把文件裁成规定的大小，默认的是裁到当前文件操作标记的位置。如果size比文件的大小还要大，依据系统的不同可能是不改变文件，也可能是用0把文件补到相应的大小，也可能是以一些随机的内容加上去
+ 目录操作
  - os.mkdir("file")                   创建目录
  - 复制文件：
    shutil.copyfile("oldfile","newfile")       oldfile和newfile都只能是文件
    shutil.copy("oldfile","newfile")            oldfile只能是文件夹，newfile可以是文件，也可以是目标目录
  - 复制文件夹：
    shutil.copytree("olddir","newdir")        olddir和newdir都只能是目录，且newdir必须不存在
  - 重命名文件（目录）
    os.rename("oldname","newname")       文件或目录都是使用这条命令
  - 移动文件（目录）
    shutil.move("oldpos","newpos")
  - 删除文件
    os.remove("file")
  - 删除目录
    os.rmdir("dir")只能删除空目录
    shutil.rmtree("dir")    空目录、有内容的目录都可以删
  - 转换目录
    os.chdir("path")   换路径
** 日期时间
+ 计算某月有多少天
  #+BEGIN_SRC python
  import calendar
  calendar.monthrange(2010,2)[1]
  #+END_SRC
