* vue安装
** vue
sudo npm install -g vue
** @vue/cli安装设置
+ sudo npm install -g @vue/cli
+ 在用户目录中的.vuerc文件中设置为"useTaobaoRegistry": false,如果此值为真，创建项目会很慢
+ 创建项目
  - vue create 项目名称
  - vue ui
+ ~/.vuerc
  被保存的 preset 将会存在用户的 home 目录下一个名为 .vuerc 的 JSON 文件里。如果你想要修改被保存的 preset / 选项，可以编辑这个文件
+ 运行项目
  npm run serve
* 官方手册
** 工具
*** 兼容性
+ Vue 不支持 IE8 及以下版本，因为 Vue 使用了 IE8 无法模拟的 ECMAScript 5 特性。但它支持所有兼容 ECMAScript 5 的浏览器
*** Vue Devtools
+ 在使用 Vue 时，我们推荐在你的浏览器上安装 Vue Devtools，它允许你在一个更友好的界面中审查和调试 Vue 应用https://github.com/vuejs/vue-devtools#vue-devtools
*** 直接用<script>引入
+ 直接下载并用 <script> 标签引入，Vue 会被注册为一个全局变量
+ 在开发环境下不要使用压缩版本，不然你就失去了所有常见错误相关的警告
+ CDN
  对于生产环境，我们推荐链接到一个明确的版本号和构建文件，以避免新版本造成的不可预期的破坏
  #+BEGIN_SRC html
  <script src="https://cdn.jsdelivr.net/npm/vue@2.6.10/dist/vue.js"></script>
  #+END_SRC
*** 不同构建版本的解释
+ 	                       UMD	                   CommonJS	                          ES Module (基于构建工具使用)	         ES Module (直接用于浏览器)
  完整版	                 vue.js	                 vue.common.js	vue.esm.js	        vue.esm.browser.js
  只包含运行时版	           vue.runtime.js	         vue.runtime.common.js	            vue.runtime.esm.js	-
  完整版 (生产环境)	       vue.min.js	             -	                                -	                                   vue.esm.browser.min.js
  只包含运行时版 (生产环境)	 vue.runtime.min.js	     -	                                -	                                   -
** 介绍
*** 声明式渲染
+ Vue.js 的核心是一个允许采用简洁的模板语法来声明式地将数据渲染进 DOM 的系统
  #+BEGIN_SRC js
  <div id="app">
    {{ message }}
  </div>
  var app = new Vue({
    el: '#app',
    data: {
      message: 'Hello Vue!'
    }
  })
  #+END_SRC
+ 除了文本插值，我们还可以像这样来绑定元素特性
  #+BEGIN_SRC js
  <div id="app-2">
    <span v-bind:title="message">
      鼠标悬停几秒钟查看此处动态绑定的提示信息！
    </span>
  </div>
  var app2 = new Vue({
    el: '#app-2',
    data: {
      message: '页面加载于 ' + new Date().toLocaleString()
    }
  })
  #+END_SRC
*** 条件与循环
+ 控制切换一个元素是否显示也相当简单
  #+BEGIN_SRC js
  <div id="app-3">
    <p v-if="seen">现在你看到我了</p>
  </div>
  var app3 = new Vue({
    el: '#app-3',
    data: {
      seen: true
    }
  })
  #+END_SRC
+ v-for 指令可以绑定数组的数据来渲染一个项目列表
  #+BEGIN_SRC js
  <div id="app-4">
    <ol>
      <li v-for="todo in todos">
        {{ todo.text }}
      </li>
    </ol>
  </div>
  var app4 = new Vue({
    el: '#app-4',
    data: {
      todos: [
        { text: '学习 JavaScript' },
        { text: '学习 Vue' },
        { text: '整个牛项目' }
      ]
    }
  })
  #+END_SRC
*** 处理用户输入
+ 处理用户输入,为了让用户和你的应用进行交互，我们可以用 v-on 指令添加一个事件监听器，通过它调用在 Vue 实例中定义的方法
  #+BEGIN_SRC js
  <div id="app-5">
    <p>{{ message }}</p>
    <button v-on:click="reverseMessage">反转消息</button>
  </div>

  var app5 = new Vue({
    el: '#app-5',
    data: {
      message: 'Hello Vue.js!'
    },
    methods: {
      reverseMessage: function () {
        this.message = this.message.split('').reverse().join('')
      }
    }
  })
  #+END_SRC
+ Vue 还提供了 v-model 指令，它能轻松实现表单输入和应用状态之间的双向绑定
  #+BEGIN_SRC js
  <div id="app-6">
    <p>{{ message }}</p>
    <input v-model="message">
  </div>

  var app6 = new Vue({
    el: '#app-6',
    data: {
      message: 'Hello Vue!'
    }
  })
  #+END_SRC
*** 组件化应用构建
+ 组件系统是 Vue 的另一个重要概念，因为它是一种抽象，允许我们使用小型、独立和通常可复用的组件构建大型应用。仔细想想，几乎任意类型的应用界面都可以抽象为一个组件树[[file:Vue_HandBook_Pic/%E7%BB%84%E4%BB%B6%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84.tif][组件树形结构图例]]
+ 在 Vue 里，一个组件本质上是一个拥有预定义选项的一个 Vue 实例。在 Vue 中注册组件很简单
  #+BEGIN_SRC js
  // 定义名为 todo-item 的新组件
  Vue.component('todo-item', {
    template: '<li>这是个待办项</li>'
  })
  #+END_SRC
+ 我们应该能从父作用域将数据传到子组件才对。让我们来修改一下组件的定义，使之能够接受一个 prop
  #+BEGIN_SRC js
  Vue.component('todo-item', {
    // todo-item 组件现在接受一个
    // "prop"，类似于一个自定义特性。
    // 这个 prop 名为 todo。
    props: ['todo'],
    template: '<li>{{ todo.text }}</li>'
  })
  #+END_SRC
+ 现在，我们可以使用 v-bind 指令将待办项传到循环输出的每个组件中
  #+BEGIN_SRC js
  <div id="app-7">
    <ol>
      <todo-item
        v-for="item in groceryList"
        v-bind:todo="item"
        v-bind:key="item.id"
      ></todo-item>
    </ol>
  </div>
  
  Vue.component('todo-item', {
    props: ['todo'],
    template: '<li>{{ todo.text }}</li>'
  })

  var app7 = new Vue({
    el: '#app-7',
    data: {
      groceryList: [
        { id: 0, text: '蔬菜' },
        { id: 1, text: '奶酪' },
        { id: 2, text: '随便其它什么人吃的东西' }
      ]
    }
  })
  #+END_SRC
+ 在一个大型应用中，有必要将整个应用程序划分为组件，以使开发更易管理
  #+BEGIN_SRC js
  <div id="app">
    <app-nav></app-nav>
    <app-view>
      <app-sidebar></app-sidebar>
      <app-content></app-content>
    </app-view>
  </div>
  #+END_SRC
** Vue 实例
*** 创建一个 Vue 实例
+ 每个 Vue 应用都是通过用 Vue 函数创建一个新的 Vue 实例开始的
  #+BEGIN_SRC js
  var vm = new Vue({
    // 选项
  })
  #+END_SRC
+ 当创建一个 Vue 实例时，你可以传入一个选项对象, 一个 Vue 应用由一个通过 new Vue 创建的根 Vue 实例，以及可选的嵌套的、可复用的组件树组成
  根实例
  └─ TodoList
     ├─ TodoItem
     │  ├─ DeleteTodoButton
     │  └─ EditTodoButton
     └─ TodoListFooter
        ├─ ClearTodosButton
        └─ TodoListStatistics
+ 所有的 Vue 组件都是 Vue 实例，并且接受相同的选项对象 (一些根实例特有的选项除外)
*** 数据与方法
+ 当一个 Vue 实例被创建时，它将 data 对象中的所有的属性加入到 Vue 的响应式系统中。当这些属性的值发生改变时，视图将会产生“响应”，即匹配更新为新的值
  #+BEGIN_SRC js
  // 我们的数据对象
  var data = { a: 1 }

  // 该对象被加入到一个 Vue 实例中
  var vm = new Vue({
    data: data
  })

  // 获得这个实例上的属性
  // 返回源数据中对应的字段
  vm.a == data.a // => true
  
  // 设置属性也会影响到原始数据
  vm.a = 2
  data.a // => 2
  
  // ……反之亦然
  data.a = 3
  vm.a // => 3
  #+END_SRC
+ 值得注意的是只有当实例被创建时就已经存在于 data 中的属性才是响应式的
+ 也就是说如果你添加一个新的属性，比如：vm.b = 'hi'那么对 b 的改动将不会触发任何视图的更新
+ 如果你知道你会在晚些时候需要一个属性，但是一开始它为空或不存在，那么你仅需要设置一些初始值
  #+BEGIN_SRC js
  data: {
    newTodoText: '',
    visitCount: 0,
    hideCompletedTodos: false,
    todos: [],
    error: null
  }
  #+END_SRC
+ 唯一的例外是使用 Object.freeze()，这会阻止修改现有的属性，也意味着响应系统无法再追踪变化
  #+BEGIN_SRC js
  var obj = {
    foo: 'bar'
  }

  Object.freeze(obj)

  new Vue({
    el: '#app',
    data: obj
  })
  <div id="app">
    <p>{{ foo }}</p>
    <!-- 这里的 `foo` 不会更新！ -->
    <button v-on:click="foo = 'baz'">Change it</button>
  </div>
  #+END_SRC
+ 除了数据属性，Vue 实例还暴露了一些有用的实例属性与方法。它们都有前缀 $，以便与用户定义的属性区分开来
  #+BEGIN_SRC js
  var data = { a: 1 }
  var vm = new Vue({
    el: '#example',
    data: data
  })

  vm.$data === data // => true
  vm.$el === document.getElementById('example') // => true

  // $watch 是一个实例方法
  vm.$watch('a', function (newValue, oldValue) {
    // 这个回调将在 `vm.a` 改变后调用
  })
  #+END_SRC
*** 实例生命周期钩子
+ 每个 Vue 实例在被创建时都要经过一系列的初始化过程——例如，需要设置数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等。同时在这个过程中也会运行一些叫做生命周期钩子的函数，这给了用户在不同阶段添加自己的代码的机会
+ 比如 created 钩子可以用来在一个实例被创建之后执行代码：
  #+BEGIN_SRC js
  new Vue({
    data: {
      a: 1
    },
    created: function () {
      // `this` 指向 vm 实例
      console.log('a is: ' + this.a)
    }
  })
  // => "a is: 1"
  #+END_SRC
+ 也有一些其它的钩子，在实例生命周期的不同阶段被调用，如 mounted、updated 和 destroyed。生命周期钩子的 this 上下文指向调用它的 Vue 实例
+ 不要在选项属性或回调上使用箭头函数，比如 created: () => console.log(this.a) 或 vm.$watch('a', newValue => this.myMethod())。因为箭头函数并没有 this，this 会作为变量一直向上级词法作用域查找，直至找到为止，经常导致 Uncaught TypeError: Cannot read property of undefined 或 Uncaught TypeError: this.myMethod is not a function 之类的错误
+ [[file:Vue_HandBook_Pic/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%A4%BA%E6%84%8F%E5%9B%BE.tif][生命周期示意图]]
** 模板语法
*** 插值
**** 文本
+ 数据绑定最常见的形式就是使用“Mustache”语法 (双大括号) 的文本插值
  #+BEGIN_SRC js
  <span>Message: {{ msg }}</span>
  #+END_SRC
+ Mustache 标签将会被替代为对应数据对象上 msg 属性的值。无论何时，绑定的数据对象上 msg 属性发生了改变，插值处的内容都会更新
+ 通过使用 v-once 指令，你也能执行一次性地插值，当数据改变时，插值处的内容不会更新。但请留心这会影响到该节点上的其它数据绑定
  #+BEGIN_SRC js
  <span v-once>这个将不会改变: {{ msg }}</span>
  #+END_SRC
**** 原始 HTML
+ 双大括号会将数据解释为普通文本，而非 HTML 代码。为了输出真正的 HTML，你需要使用 v-html 指令
  #+BEGIN_SRC js
  <p>Using mustaches: {{ rawHtml }}</p>
  <p>Using v-html directive: <span v-html="rawHtml"></span></p>
  #+END_SRC
+ 这个 span 的内容将会被替换成为属性值 rawHtml，直接作为 HTML——会忽略解析属性值中的数据绑定。注意，你不能使用 v-html 来复合局部模板，因为 Vue 不是基于字符串的模板引擎。反之，对于用户界面 (UI)，组件更适合作为可重用和可组合的基本单位
+ 站点上动态渲染的任意 HTML 可能会非常危险，因为它很容易导致 XSS 攻击。请只对可信内容使用 HTML 插值，绝不要对用户提供的内容使用插值
**** 特性
+ Mustache 语法不能作用在 HTML 特性上，遇到这种情况应该使用 v-bind 指令
  #+BEGIN_SRC js
  <div v-bind:id="dynamicId"></div>
  #+END_SRC
+ 对于布尔特性 (它们只要存在就意味着值为 true)，v-bind 工作起来略有不同,如果 isButtonDisabled 的值是 null、undefined 或 false，则 disabled 特性甚至不会被包含在渲染出来的 <button> 元素中
  #+BEGIN_SRC js
  <button v-bind:disabled="isButtonDisabled">Button</button>
  #+END_SRC
**** 使用 JavaScript 表达式
+ 实际上，对于所有的数据绑定，Vue.js 都提供了完全的 JavaScript 表达式支持
  #+BEGIN_SRC js
  {{ number + 1 }}

  {{ ok ? 'YES' : 'NO' }}
  
  {{ message.split('').reverse().join('') }}
  
  <div v-bind:id="'list-' + id"></div>
  #+END_SRC
+ 这些表达式会在所属 Vue 实例的数据作用域下作为 JavaScript 被解析。有个限制就是，每个绑定都只能包含单个表达式，所以下面的例子都不会生效
  #+BEGIN_SRC js
  <!-- 这是语句，不是表达式 -->
  {{ var a = 1 }}

  <!-- 流控制也不会生效，请使用三元表达式 -->
  {{ if (ok) { return message } }}
  #+END_SRC
+ 模板表达式都被放在沙盒中，只能访问全局变量的一个白名单，如 Math 和 Date 。你不应该在模板表达式中试图访问用户定义的全局变量
*** 指令(Directives)
+ 指令 (Directives) 是带有 v- 前缀的特殊特性。指令特性的值预期是单个 JavaScript 表达式 (v-for 是例外情况，稍后我们再讨论)。指令的职责是，当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM
** 单文件组件
+ 在<script>标签中为了方便编辑可以导入单独.ts文件中的代码
  #+BEGIN_SRC html
  <template>
    <div  class='warpper'>
    </div>
  </template>
  <script lang="ts">
    import { Component, Prop, Vue } from 'vue-property-decorator';

    @Component
    export default class HelloWorld extends Vue {
      @Prop() private msg!: string;
    }
  </script>
  <style scoped lang='less'>  属性scoped表面下面的样式只适用于该组件，限定样式的作用域
  </style>
  #+END_SRC
* Vue Router
** 前端路由原理
+ 目前前端路由通常使用hash来实现，hash的优点是可以兼容低版本的浏览器，即在URI中使用#，WEB服务并不会解析hash，会自动忽略#后面的内容，但JavaScript可以通过window.location.hash读取到，并加以解析相应不同路径的逻辑处理
+ HTML5新增加的history API，用来操作浏览器的session history，实现同样的功能，但需要后端的支持
+ 前端路由多应用于单页面应用(SPA)上，因为SPA基本都是前后端分离，后端自然不会为前端提供路由
+ 将SPA分割为功能合理的组件或局部页面，路由起到一个非常重要的作用，是链接单页面应用中各页面的链条
** Vue Router基本使用
*** 安装
+ 在项目根目录下使用npm安装
  npm install vue-router --save
+ 也可以在使用vue/cli创建项目时，通过选项添加vue-router
  vue create 项目名称
*** 相关目录及配置文件
+ 在项目src/router目录中的index.ts文件是路由的主配置文件，进行路由的配置
  #+BEGIN_SRC typescript
  import Vue from 'vue'
  import VueRouter from 'vue-router'
  import Home from '../views/Home.vue'
  
  Vue.use(VueRouter)
  
  const routes = [
    {
      path: '/',
      name: 'home',
      component: Home
    },
    {
      path: '/about',
      name: 'about',
      // route level code-splitting
      // this generates a separate chunk (about.[hash].js) for this route
      // which is lazy-loaded when the route is visited.
      component: () => import(/* webpackChunkName: "about" */ '../views/About.vue')
    }
  ]

  const router = new VueRouter({
    routes
  })

  export default router
  #+END_SRC
+ 在vue项目的入口文件main.ts中导入router中的index.ts文件即可使用路由配置的信息
  #+BEGIN_SRC typescript
  import Vue from 'vue'
  import App from './App.vue'
  import './registerServiceWorker'
  import router from './router'
  import store from './store'
  
  Vue.config.productionTip = false
  
  new Vue({
    router,
    store,
    render: h => h(App)
  }).$mount('#app')
  #+END_SRC
*** 建立路由
+ 一条路由有三个组成部分
  - path
  - name
  - component
    在指定组件名称时，实际上指定的是项目目录中component/组件名.vue，可以省略.vue
*** 启动路由
+ 在main.ts入口文件中导入路由模块，创建Vue实例时配置上router参数即可启动路由
  #+BEGIN_SRC typescript
  import router from './router'
  
  new Vue({
    router,
    store,
    render: h => h(App)
  }).$mount('#app')
  #+END_SRC
*** 路由重定向
+ 项目应用通常会有一个首页，默认首先打开的是首页，要跳转到哪个页面都可以设置路由路劲发生跳转；有时候也需要路由器定义全局的重定向规则，全局重定向会在匹配当前路径之前执行，重定向也是通过routes配置来完成
+ 具体示例
  #+BEGIN_SRC typescript
  const router = new VueRouter({
    routes:[
      { path:'/a', redirect:'/b' }
    ]
  })
  #+END_SRC
+ 重定向的目标也可以是一个命名的路由
  #+BEGIN_SRC typescript
  const router = new VueRouter({
    routes:[
      { path:'/a', redirect:{ name:'foo' } }
    ]
  })
  #+END_SRC
+ 重定向的目标也可以是一个方法，动态返回重定向目标
  #+BEGIN_SRC typescript
  const router = new VueRouter({
    routes:[
      { path:'/a', redirect: to => { 
        //方法接收"目标路由"作为参数
        //return重定向的"字符串路径/路径对象"
      }}
    ]
  })
  #+END_SRC
*** 路由懒加载
+ 在打包构建应用时，JavaScript包会变得非常大，影响页面加载速度，把不同路由对应的组件分割成不同的代码块，当路由被访问到时才加载对应的组件是比较高效的
+ 结合Vue的异步组件和webpack的代码分割功能，可以轻松实现路由的懒加载
+ 异步组件时Vue允许将组件定义为一个返回Promise工厂函数(该函数返回的Promise应该是resolve组件本身)，异步解析组件的定义，Vue只在组件需要渲染时触发工厂函数，并且把结构缓存起来，用于后面的再次渲染
  #+BEGIN_SRC typescript
  const Foo = () => Promise.resolve({/*组件定义对象*/})
  #+END_SRC
+ 在webpack中使用动态import语法定义代码分块点(split point)
  #+BEGIN_SRC typescript
  import('./Foo.vue') //返回Promise
  #+END_SRC
+ 结合以上两点就是定义一个能够被webpack自动进行代码分割的异步组件的过程
  #+BEGIN_SRC typescript
  const Foo = () =>import('./Foo.vue')
  #+END_SRC
+ 在路由配置中不需要改变，只需要想往常一样使用Foo组件即可
  #+BEGIN_SRC typescript
  const router = new VueRouter({
    routes:[
      {path:'foo', component:Foo }
    ]
  })
  #+END_SRC
+ 通过懒加载不会一次性加载所有组件，而是访问到组件的时候才加载，对组件比较多的应用会提高首次加载速度
  #+BEGIN_SRC typescript
  //引入组件header
  const Header =()=> import('@/component/header');
  //引入页面中的首页
  const Index =()=>import('@/pages/index');
  const Login =()=>import('@/pages/login');
  #+END_SRC
*** <router-link>
+ 此组件支持用户在具有路由功能的应用中单击导航，通过to属性可以指定目标地址，默认渲染成带有正确链接的<a>标签，通过配置tag属性可以生成别的标签
+ 当目标路由成功激活时，链接元素会自动设置一个表示激活的CSS类名
+ 语法
  #+BEGIN_SRC html
  <!-- 使用v-bind的js表达式 -->
  <router-link v-bind:to="'home'">Home</router-link>
  <!-- 渲染结果 -->
  <a href="home">Home</a>
  
  <!-- 不使用v-bind也可以，就像绑定其他属性一样 -->
  <router-link :to="'home'">Home</router-link>
  <!-- 同上 -->
  <router-link :to={path:'home'}>Home</router-link>
  
  <!-- 命名的路由 -->
  <router-link :to={name:'user', params:{ userId:123 }}>User</router-link>
  <!-- 带查询参数，下面的结果为/register?plan=private -->
  <router-link :to="{path:'register', query:{ plan:'private' }}">Register</router-link>
  #+END_SRC
+ 使用<router-link>而不使用<a href="...">的原因
  - 无论HTML5 history还是hash模式，它们表现的行为一致，所以当切换路由模式或在IE9降级使用hash模式时，无须任何改动
  - 在HTML5 history模式下，<router-link>会守卫单击事件，让浏览器不再重新加载页面
  - 在HTML5 history模式下使用base选项之后，所有的to属性都不需要写基路径
*** 路由对象属性
+ $route.path
  字符串，对应当前路由的路径，总是解析为绝对路径，如/foo/bar
+ $route.params
  一个key/value对象，包含了动态片段和全匹配片段，如果没有路由参数，就为空对象
+ $route.query
  一个key/value对象，表示URL查询参数，例如，对于路径/foo?user=1，则有$route.query.user=1；如果没有查询参数，则为空对象
+ $route.hash
  当前路由的hash值(不带#)，如果没有hash值，则为空字符串
+ $route.fullPath
  完成解析后的URL，包含查询参数和hash的完整路径
+ $route.matched
  一个数组，包含当前路由的所有嵌套路径片段的路由记录，路由记录就是routes配置数组中的对象副本(还有一些children数组)
** 页面间导航
*** router.push()
+ 语法
  router.push(location)
+ 要导航到不同的URL，则使用router.push方法，该方法会向history栈添加一个新的记录，当用户单击浏览器的后退按钮时，回到之前的URL
+ 当单击<router-link>时，会在内部调用router.push(...)方法，所有单击<router-link :to="...">等同于调用router.push(...)
+ 该方法的参数可以是一个字符串路径，也可以是一个描述地址的对象
  #+BEGIN_SRC typescript
  router.push('home') //字符串
  router.push({ path: 'home' }) //对象

  //命名的路由
  router.push({ name: 'user', params:{ userId: 123 }}) // -> /user/123
  //带查询参数，变成/register?plan=private
  router.push({path: 'register', query: { plan: 'private'}})
  //由一个页面跳转到另一个页面时，需要携带一些数据，这时就需要用到这种带参数的路由跳转方式
  #+END_SRC
*** router.replace()
+ 语法
  router.replace(location)
+ router.replace与router.push很像，唯一不同的是它不会向history栈添加新记录，而是替换掉当前的history记录
+ router.replace(...)等同于<router-link :to="..." replace>
*** router.go()
+ 语法
  router.go(n)
+ router.go方法的参数是一个整数，表示在history记录中向前进多少步或向后退多少步，类似于window.history.go(n)
  #+BEGIN_SRC typescript
  //在浏览器记录中前进一步，等同于history.forward()
  router.go(1)
  //后退一步，等同于history.back()
  router.go(-1)
  //前进三步
  router.go(3)
  //如果history记录不够，就会失败
  #+END_SRC
* Vuex
** 状态管理
+ 一个组件可以分为数据(Model)和视图(View)两部分，数据更新时，视图也会随之更新；在视图中又可以绑定一些事件，用于触发methods里指定的方法，从而可以改变数据、更新视图，这是一个组件基本的运行模式
+ 组件中的数据和方法只能在当前组件中访问和使用，其他组件是无法读取和修改，但在实际业务中，经常有跨组件共享数据的需要，Vuex就是设计用来统一管理组件状态的，它定义了一系列规范来使用和操作数据，使组件的应用更加高效
+ vuex的主要使用场景是大型单页应用，更适合多人协作的开发
** 基本用法
+ 经典的使用场景就是记录用户的登录状态
+ 安装
  npm install vuex --save
+ 可以在src文件夹中建立store目录存放整个项目需要的共享数据，新建index.ts
  #+BEGIN_SRC typescript
  import Vue from 'vue';
  import Vuex from 'vuex'
  Vue.use(vuex)
  
  export default new Vuex.Store({
      //state 存放所有的共享数据
      state: {
          count: 0
      },
      //状态变化
      mutations: {
          increment: state => state.count++,
          decrement: state => state.count--
      }
  })
  #+END_SRC
+ 在main.ts中引入store数据源，并在vue实例中使用
  #+BEGIN_SRC typescript
  import Vue from 'vue';
  import App from './App';
  import store from '@/store';
  import router from './router';

  Vue config.productionTip = false;
  new Vue({
      el: '#app',
      router,
      store,
      components: {App},
      template: '<App/>'
  })
  #+END_SRC
+ 在components文件夹下新建父组件
  #+BEGIN_SRC html
  <template>
    <div class="page">
      <p>{{count}}</p>
      <p>
        <button @click="increment">+</button>
        <button @click="decrement">-</button>
      </p>
    </div>
  </template>
  
  <script>
      export default{
           data(){
               return{};
           },
           computed: {
               count(){
                   return this.$store.state.count;
               }
           },
           methods: {
               //改变store中的状态的唯一途径就是显示的提交(commit)mutation
               increment(){
                   this.$store.commit("increment");
               },
               decrement(){
                   this.$store.commit("decrement")
               }
           }
      };
  </script>
  #+END_SRC
* 常用插件
** QRCode(二维码)
+ 安装
  npm install qrcode --save
+ 示例
  #+BEGIN_SRC html
    <template>
      <div class="hello">
          <!-- 生成二维码区域 -->
          <canvas id="canvas"></canvas>
      </div>
    </template>

    <script>
        import Vue from "vue";
        //引入qrcode插件
        import QRCode form "qrcode";
        Vue.use(QRCode);
        export default{
            data(){
                return{};
            }，
            mounted(){
                //组件挂载时，调用生成二维码函数
                this.useqrcode();
            },
            methods: {
                useqrcode(){
                    //盛放二维码的容器
                    let canvas = document.getElementById("canvas");
                    //调用函数生成二维码，参数依次为：盛放的容器、要生成的内容、回调函数
                    QRCode.toCanvas(canvas,"http://www.baidu.com", function(error){
                        if (error) {
                            console.error(error);
                        }else{
                            //成功之后可回调的函数
                            console.log("success");
                        }
                    });
                }
            }
        };
    </script>
  #+END_SRC
* 从入门到项目实战
** 基本介绍
*** 安装和引入
**** 下载后引入
+ 通过官网现在Vue.js文件，并通过<script>标签引入，此时Vue会被注册为全局变量
**** 安装后引入
+ 通过npm安装vue(npm install vue -g)后引入
  #+BEGIN_SRC js
  import Vue from 'vue'
  #+END_SRC
**** 使用Vue Devtools工具
+ 在官网中下载chrome或firefox对应的扩展，进行安装
+ 此工具提供了一个界面，可以查看Vue组件和全局状态管理器Vuex中记录的数据
*** Vue实例介绍
+ 示例
  #+BEGIN_SRC html
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8"/>
    <title>test</title>
  </head>
  <body>
    <div id="app">
      {{ activeKey }}
    </div>

    <script src="../js/vue.js"></script>
    <script>
        let app = new Vue ({
          el: '#app',
          data: {
            activeKey: '12345'
          }
        })
    </script>
  </body>
</html>
  #+END_SRC
+ 在上面的示例中，初始化了带有activeKey数据的app对象，并将其绑定到id为app的DOM节点上
+ 初始化时，中实例上绑定的常规数据对象会被vue转化为被观察的拥有可响应行为的对象，即当数据变化时，会同步更新其数据链和作用域中所有的相关状态，最常见的情况就是，当实例数据发生变化时，视图也随之改变
*** 生命周期
+ vue实例中初始化时需要经历一系列的过程，如编译模板、渲染虚拟DOM数、将实例挂载到DOM上、设置数据监听和数据绑定等，在这些过程中也会运行一些钩子函数，允许开发者中不同的阶段注入自己的代码
+ 示例：绑定钩子函数打印标识信息，用以观察这些钩子函数的执行时机
  #+BEGIN_SRC html
  <div id="app">
    <h1>{{ title }}</h1>
    <button @click="randomTitle()">改变title</button>
    <button @click="destoryVm()">销毁实例</button>
  </div>
  <script scr="./js/vue.js"></script>
  <script>
      let app = new Vue({
          el: '#app', //mount到DOM上
          data () {
              return {
                  title: 'Hello World'
              }
          },
          
          methods: {
              randomTitle () {
                  this.title = 'Hello' + ['China', 'World', 'Universe'][Math.floor(Math.random() * 2.999)]
              },
              destoryVm () {
                  this.$destory()
              }
          },

          //实例初始化之后，数据观测和事件绑定之前
          beforeCreate () {
              console.log('before create')
          }，

          //实例初始化之后，挂载尚未开始时
          created () {
              console.log('created')
          },

          //挂载之前，render函数首次被调用时
          beforeMount () {
              console.log('before mount')
          },

          //在实例挂载到DOM节点上之后
          mounted () {
              console.log('mounted')
          },

          //数据更新时，在虚拟DOM状态变化之前
          beforeUpdate () {
              console.log('before update')
          },

          //虚拟DOM被重新渲染之后
          updated () {
              console.log('updated')
          },
          
          //实例销毁之前，此时实例依然可用
          beforeDestory () {
              console.log('before destory')
          },

          //实例销毁之后，此时vue实例及其子实例将完全解绑
          destoryed () {
              console.log () {'destoryed'}
          }
      })
  </script>
  #+END_SRC
*** 数据响应式原理
**** 数据链
+ 数据链即连通数据的链路，其中有一个到多个数据起点(元数据)，并通过该点衍生拓展新的节点(衍生数据)，形成一个庞大的网状结构，当修改数据起点时，所有存在于网上的节点都将同步更新
+ vue中可以通过修改元数据的值来触发一系列数据的更新
**** 函数式编程
+ 函数式编程是一种结构化编程方式，力求将运算过程写成一系列嵌套的函数调用，源于javascript的万物皆对象的理念，函数式编程认定函数是第一等公民，可以赋值给其他变量、用作另一个函数的参数或作为函数的返回值使用
+ 函数式编程的核心是根据元数据生成新的衍生数据，提供唯一确定的输入，函数将返回唯一确定的输出，它并不会修改原有变量的值，这在运用JS闭包概念进行开发时尤为重要，在函数作用域内调用域外或全局变量时并不会修改它们的值，安全无污染
+ 函数式编程就是建立了一条数据流通的链路，开发者只需要关注输入和输出两端的内容就可以，这是封装复用的一种最佳实践，在高效开发中举足轻重
**** vue中的数据链
+ vue实例提供了computed计算属性选项，以供开发者生成衍生数据对象，虽然计算属性以函数形式声明，却并不接受参数，也只能以属性的方式调用，计算属性的this指向vue实例，可以获取实例上所有已挂载的可见属性
+ 当然vue也可以使用methonds中的方法来实现数据链
**** 数据绑定视图
+ 在vue中，把普通的javascript对象传给vue实例的data选项时，vue将遍历对象属性，使用Object.defineProperty将其全部转化为getter/setter，并中渲染组件时将属性记录为依赖，之后当依赖项的setter函数被调用时，会通知watcher重新计算并更新其关联的所有组件
** Vue语法
*** 插值绑定
**** 文本插值
+ 文本插值是用双大括号将要绑定的变量、值、表达式包含其中，vue会获取计算后的值，并以文本的形式将其展示出来
+ 文本插值常见形式
  #+BEGIN_SRC html
  <p>变量：{{ num }}</p>
  <p>表达式：{{ 5 + 10 }}</p>
  <p>三目运算符：{{ true ? 15 : 10 }}</p>
  <p>函数：{{ getNum() }}</p>
  <p>匿名函数：{{ (() => 5 + 10 )() }}</p>
  <p>对象：{{ num: 15 }}</p>
  <p>函数对象：{{ getNum }}</p>
  <p>html代码(表达式){{ '<span>15</span>' }}</p>
  <p>html代码(变量){{ html }}</p>
  #+END_SRC
**** HTML插值
+ HTML插值可以动态渲染DOM节点，常用于处理开发者无可预知和难以控制的DOM结构，如渲染用户随意书写的文档结构
+ 文本插值中的代码被解释为节点的文本内容，HTML插值中的代码则被渲染为视图节点
+ 实际上，HTML插值是对文本插值的补充和扩展，vue可以解析被绑定的内容为DOM节点，从而实现动态渲染视图的效果
+ 使用HTML插值的原则
  - 尽量多的使用Vue自身的模板机制，减少HTML插值的使用
  - 只对可信内容使用HTML插值
  - 绝不相信用户输入的数据
*** 属性绑定
**** 指令v-bind
+ DOM节点的属性基本都可以使用指令v-bind进行绑定
  #+BEGIN_SRC html
  <style>
    .italic { font-style: italic; }
  </style>
  <div id="app" style="margin-left: 300px;">
    <p v-bind:class="className" v-bind:title="title">危险勿触</p>
    <button v-bind:disable="10 + 10 === 20">点击有奖</button>
    <input v-bind:type="'text'" v-bind::placeholder="true ? '请输入':'请录入'">
  </div>
  <script>
      let vm = new Vue({
          el: '#app',
          data () {
              return {
                  className: 'italic',
                  title: '危险勿触'
              }
          }
      })
  </script>
  #+END_SRC
+ v-bind可以省略不写
  #+BEGIN_SRC html
  <p :class="className" :title="title">危险勿触</p>
  #+END_SRC
+ 属性也可以绑定变量、表达式、执行函数等内容，但都要求满足属性自身的约束
**** 类名和样式绑定
+ 类名class和样式style中节点属性中是两个比较特殊的，虽然他们可接收的类型都是字符串，但类名实际上是由数组拼接而成的，样式则是由对象键值对拼接而成的，所以vue绑定类名和样式时采用了不一样的机制
+ 可以通过字符串、数组、对象三种方式为节点动态绑定类名属性
  #+BEGIN_SRC html
  <style>
    .color-gray { color: gray; }
    .size-18 { font-size: 18px; }
    .style-italic { font-style: italic; }
  </style>
  <div id="app">
    <p class="color-gray size-18 style-italic"></p>
    <p :class="classStr"></p>
    <p :class="classArr"></p>
    <p :class="classObj1"></p>
    <p :class="classObj2"></p>
  </div>
  <script>
      let vm = new Vue({
          el: '#app',
          data () {
              return {
                  classStr: 'color-gray size-18 style-italic', //拼接字符串
                  classArr: ['color-gray', 'size-18', 'style-italic'], //数组
                  classObj1: { //对象，绑定类名
                      'color-gray': true,
                      'size-18': true,
                      'style-italic': true
                  },
                  classObj2: { //对象，未绑定类名
                      'color-gray': 0,
                      'size-18': '',
                      'style-italic': false
                  }
              }
          }
      })
  </script>
  #+END_SRC
+ 在使用对象绑定类名时，应将类名作为对象键名，当键值为真时，类名将被绑定到节点上
+ 样式绑定的方式于类名相似，不过样式是以键值对的形式，所以不能像类名一样使用数组进行绑定
*** 事件绑定
***** 指令v-on
+ vue使用v-on指令监听DOM事件，可以将事件代码通过v-on指令绑定到DOM节点上
  #+BEGIN_SRC html
  <div id="app">
    <button v-on:click="loginfo()">打印信息(default: Hello World)</button>
    <br>
    <button v-on:click="loginfo('Self Message')">打印信息(Self Message)</button>
    <br>
    <button v-on:click="console.log('A Vue App')">打印信息(A Vue App)</button>
  </div>
  <script>
      let vm = new Vue({
          el: '#app',
          methods: {
              loginfo (msg) {
                  console.log(msg || 'Hello World')
              }
          }
      })
  </script>
  #+END_SRC
+ v-on指令可以简写为@
+ 有时在处理事件时，也会用到事件对象本身，可以使用如下两种方法获取事件对象
  #+BEGIN_SRC html
    <div id="app">
      <!--   1. 在事件函数不必传参时，可以如下写法，注意不能带() -->
      <input type="text" @keyup="handleKeyUp">
      <br>
      <!--   2. 手动传入$event对象 -->
      <input type="text" @keyup="handleKeyUp($event)">
    <div>
    <script>
        let vm = new Vue({
            el: '#app',
            methods: {
                handleKeyUp (event) {
                    console.log(event.key, event)
                }
            }
        })
    </script>
    <!-- 两种方式都能打印出事件对象 -->
  #+END_SRC
***** 常见修饰符
****** 事件修饰符
+ 常见事件修饰符
  |----------+----------+----------------------------------------------|
  | 名称     | 可用事件 | 说明                                         |
  |----------+----------+----------------------------------------------|
  | .stop    | 任意     | 当事件触发时，阻止事件冒泡                   |
  |----------+----------+----------------------------------------------|
  | .prevent | 任意     | 当事件触发时，阻止元素的默认行为             |
  |----------+----------+----------------------------------------------|
  | .capture | 任意     | 当事件触发时，阻止事件捕获                   |
  |----------+----------+----------------------------------------------|
  | .self    | 任意     | 限制事件仅作用于节点自身                     |
  |----------+----------+----------------------------------------------|
  | .once    | 任意     | 事件被触发一次后即解除监听                   |
  |----------+----------+----------------------------------------------|
  | .passive | 滚动     | 移动端，限制事件永不调用preventDefault()方法 |
  |----------+----------+----------------------------------------------|
+ 当事件后缀多个修饰符时，要注意排列顺序，响应代码会根据排列顺序依次执行
****** 按键修饰符
+ 常见按键修饰符别名
  |------------+------------+-----------|
  | 别名修饰符 | 键值修饰符 | 对应按键  |
  |------------+------------+-----------|
  | .delete    |     .8/.46 | 回退/删除 |
  | .tab       |         .9 | 制表      |
  | .enter     |        .13 | 回车      |
  | .esc       |        .27 | 退出      |
  | .space     |        .32 | 空格      |
  | .left      |        .37 | 左        |
  | .up        |        .38 | 上        |
  | .right     |        .39 | 右        |
  | .down      |        .40 | 下        |
  |------------+------------+-----------|
****** 鼠标修饰符
+ 常见鼠标按键修饰符
  |---------+----------|
  | 修饰符  | 对应按键 |
  |---------+----------|
  | .left   | 左键     |
  | .right  | 右键     |
  | .middle | 中键     |
  |---------+----------|
****** 组合修饰符
+ 组合键使用方式，vue提供了组合修饰符的机制，但必须配合系统按键修饰符
+ 系统按钮修饰符
|--------+--------------------------|
| 修饰符 | 对应按键                 |
| .ctrl  | Ctrl键                   |
| .alt   | Alt键                    |
| .shift | Shift键                  |
| .meta  | meta键(windows中为win键) |
|--------+--------------------------|
*** 双向绑定
**** 指令v-model
+ 使用v-model可以为可输入元素(input & textarea)创建双向数据绑定，它会根据元素类型自动选取正确的方法来更新元素
  #+BEGIN_SRC html
    <div id="app">
      <h3>单行文本框</h3>
      <input type="text" v-model="singleText" style="width: 240px;">
      <p>{{ singleText }}</p>

      <h3>多行文本框</h3>
      <textarea v-model="multiText" style="width: 240px;"></textarea>
      <pre>{{ multiText }}</pre>

      <h3>单选框</h3>
      <!--   由于点击被选中的单选项无法取消被选中状态，基本不会出现单独使用一个单选选的情况，通常都是设置一个变量(radioValue)可实现RadioGroup的效果 -->
      <input id="ra" type="radio" value="杨玉环" v-model="radioValue">
      <label for="ra">A.杨玉环</label>
      <input id="rb" type="radio" value="赵飞燕" v-model="radioValue">
      <label for="rb">B.赵飞燕</label>
      <p>{{ radioValue }}</p>

      <h3>单个复选框</h3>
      <!--   单个复选框被用于true和false的切换 -->
      <input id="c" type="checkbox" v-model="toggleValue">
      <label for="c">天生丽质</label>
      <p>{{ toggleValue }}</p>

      <h3>多个复选框</h3>
      <!--   多个复选框，v-model接收数组类型的变量 -->
      <input id="ca" type="checkbox" value="漂亮" v-model="checkedValues">
      <label for="ca">A.回眸一笑百媚生</label>
      <input id="cb" type="checkbox" value="瘦弱" v-model="checkedValues">
      <label for="cb">B.体轻能为掌上舞</label>  
      <input id="cd" type="checkbox" value="得宠" v-model="checkedValues">
      <label for="cd">C.三千宠爱在一身</label>
      <p>{{ checkedValue.join(',') }}</p>
    <div>
    <script>
        let vm = new Vue({
            el: '#app',
            data () {
                return {
                    singleText: '',
                    multiText: '',
                    radioValue: '',
                    toggleValue: false,
                    checkedValue: []
                };
            }
        })
    </script>
    <!--   在实际项目中由于自身的限制很少直接使用select制作下拉列表，而是使用div进行模拟 -->
  #+END_SRC
**** v-model与修饰符
+ 在使用v-model时，可以使用修饰符丰富用户输入时的行为
|---------+--------------------------------------------------------|
| 修饰符  | 说明                                                   |
| .lazy   | 将用户输入的数据赋予变量的时机由输入时延迟到数据改变时 |
| .number | 自动转换用户输入为数值类型                             |
| .trim   | 自动过滤用户输入的首尾空白字符                         |
|---------+--------------------------------------------------------|
**** v-model与自定义组件
+ 不只有原生的输入元素可以使用v-model进行双向绑定，vue允许开发者将v-model用于自定义组件
  #+BEGIN_SRC html
    <div id="app">
      <!--   自定义组件v-model -->
      <custom-screen v-model="text"></custom-screen>
      <bt>
      <!--   原生元素v-model -->
      <input type="text" v-mode="text">
    <div>
    <script>
        Vue.component('custom-screen', {
            //使用value属性接收外部传入的值
            props: ['value'],
            methods: {
                handleRest () {
                    console.log('重置为\'\'');
                    this.%emit('input', '') //使用$emit发送input事件，并将目标值作为参数传出
                }
            },
            template: '
                <div>
                  <h2>输入值为: {{ value }}</h2>
                  <button @click="handleReset">重置为空</button>
                </div>
            '
        })
        
        let vm = new Vue({
            el: '#app',
            data: () => ({ text: '' })
        })
    </script>
  #+END_SRC
+ 自定义组件中，value属性和input事件尤为重要，它们分别负责不同方向的数据传递，value属性用于接收外部传入的值以更新组件内部的状态；input事件由开发者决定在什么时候调用，并负责将组件内部的状态同步到外部
*** 条件渲染和列表渲染
**** 指令v-if和v-show
+ v-if、v-else-if、v-else命令组合，后两个必须跟v-if一起使用，否则不会被识别
  #+BEGIN_SRC html
  <div id="app">
    <h2 v-if="order === 0">站在前排的v-if</h2>
    <h2 v-else-if="order === 1">不上不下的v-elseif</h2>
    <h2 v-else>负责殿后的v-else</h2>
    <button @click=toggleTitle>切换标题</button>
  </div>
  <script>
      let vm = new Vue({
          el: '#app',
          data () {
              return {
                  order: 0
              };
          },
          methods: {
              toggleTitle () {
                  this.order = ++this.order % 3;
                  console.log('order的值为：' ,this.order)
              }
          }
      })
  </script>
  #+END_SRC
+ v-show也是用于实现条件渲染，但它只是简单的切换元素的CSS属性(display)，当条件为假时，display被设置为none
+ 相对于v-if来说v-show并不能算作真正的条件渲染，因为挂载它的多个元素之间并没有条件上下文关系
+ v-if会在切换中将组件上的事件监听器和子组件销毁和重建，当组件被销毁时，它将无法被任何方式获取，因为它已经不存在与DOM中
+ 在创建父组件时，如果子组件的v-if被判断为假，vue不会对子组件做任何事情，直到第一次判定为真时，这在使用生命周期的钩子函数时要注意，如果生命周期已经走过组件的创建阶段，却无法获取组件对象，就有可能是使用v-if的原因
+ v-show有更高的初始渲染开销，v-if有更高的切换开销，需要根据具体场景进行选用
**** 指令v-for
+ v-for用于实现列表渲染，可以使用item in items或item of items的语法
  #+BEGIN_SRC html
    <div id="app">
      <div style="float: left; width: 160px;">
        <h2>用户列表</h2>
        <ul>
          <!-- index作为第二个参数，用以标识下标 -->
          <li v-for="(item, index) in users">{{ index }}.&nbsp;{{ item.name }}</li>
        </ul>
      </div>
      <div style="margin-left: 170px; over flow: hidden">
        <h2>用户列表</h2>
        <ul>
          <!-- uIndex作为第二个参数，用以标识下标 -->
          <li v-for="(user, uIndex) of users">{{ uIndex }}.&nbsp;{{ item.name }}</li>
        </ul>
      </div>
    </div>
    <script>
        let vm = new Vue({
            el: '#app',
            data () {
                return {
                    users: [
                        {
                            name: 'Clark',
                            age: 18,
                            city: 'BeiJing'
                        },
                        {
                            name: 'Tom'
                            age: 25,
                            city: 'Tangshan'
                        }
                    ]
                };
            }
        })
    </script>
  #+END_SRC
+ v-for除了渲染数组，还可以渲染对象的键值对
  #+BEGIN_SRC html
    <div id="app">
      <div style="float: left; width: 160px;">
        <h2>用户列表</h2>
        <ul>
          <!-- index作为第二个参数，用以标识下标 -->
          <li v-for="(user, index) in users">用户{{ index + 1 }}
            <ul>
              <!-- key作为第二个参数，用以标识键名 -->
              <li v-for="(value, key) of users">{{ key }}.&nbsp;{{ value }}</li>
            </ul>
          </li>
        </ul>
      </div>
    </div>  
  #+END_SRC
+ vue会把数组当作被观察者加入响应式系统中，当调用一些方法修改数组时，对应的视图将会同步更新，以下为与数据响应有关的数组方法
  |---------+---------------------------------------------------------|
  | 名称    | 说明                                                    |
  | push    | 将一个或多个元素添加至数组末尾，并返回新数组的长度      |
  | pop     | 从数组中删除并返回最后一个元素                          |
  | shift   | 从数组中删除并返回第一个元素                            |
  | unshift | 将一个或多个元素添加到数组头部，并返回新数组的长度      |
  | splice  | 从数组中删除元素或向数组添加元素                        |
  | sort    | 对数组元素排序，默认按unicode编码排序，返回排序后的数组 |
  | reverse | 将数组中的元素位置颠倒，返回颠倒后的数组                |
  |---------+---------------------------------------------------------|
+ 注意使用下标或键名为数组或对象设置成员的值时，vue并不会将其加入数据响应系统，此种方法修改数据时，视图不会进行更新，此类操作可以使用新数组替换就数组实现视图刷新或使用 Vue.set()或$set()方法
  - arr[0] = 99
  - obj['key'] = 'value'
**** 列表渲染中的key
+ 使用v-for时，最好为每个迭代元素提供一个值不重复的key，当列表渲染被重新执行(数组内容发生改变)时，如果不使用key，vue会为数组成员就近复用已存在的DOM节点
+ 实质上，key的存在是为DOM节点标注了一个身份信息，让vue能够有迹可循到数据对应的节点，中vue2.0以上的版本使用v-for时没有附加key的话，vue会给出一个警告
** Vue选项
*** 数据和方法
**** 数据选项(data)
+ 数据(data)选项可接受的类型有对象和函数两种，不过在定义一个组件时，只能使用函数类型
  #+BEGIN_SRC js
  //创建一个vue组件时data选项必须使用函数类型
  Vue.component('button-counter', {
      data () {
          return {
              counter: 1
          }
      }
  })

  //非定义组件的情况下可以使用对象类型
  let vm = new Vue ({
      el: '#app',
      data: {
          title: 'A Vue App'
      }
  })
  #+END_SRC
+ Vue会递归将data选项中的数据加入到响应式系统，但这些数据应该是声明时即存在的
  #+BEGIN_SRC html
  <template>
    <div>
      <h2>{{ title }}</h2>
      <p>{{ pro file }}</p>
    </div>
  </template>
  <script>
      export default {
          name: 'instance',
          data () {
              return {
                  title: 'A Vue App'
              };
          }
      },
      created () {
          Object.assign(this.$data, {
          //为对象赋值属性，没有则添加属性，有则覆盖原有属性值，但此处定义的数据不会被加入到响应式系统，而只是一个普通的js属性                                                                                                                                                                                                                                                                                                                                                                  
          pro file: 'This is a Vue App'
          })
          console.log(this.$data)
      }
  </script>
  #+END_SRC
+ 在实际开发时，应将可能中实例中被观察的对象预先中data选项中声明，任何浏览器所支持的原生API都无法将数据动态加入响应式系统，但vue针对这一需求提供了相应的机制
+ 开发者可以使用Vue.$set(target, key, value)
**** 属性选项(props)
+ 使用属性选项(props)可以为组件注册动态特性，以处理业务间的差异，使代码可以复用于相似的应用场景
+ props选项可以是数组或对象类型，用于接收从父组件传递过来的参数，并允许开发者为其设置默认值、类型检测、校验规则等
  #+BEGIN_SRC html
  <div id="app">
    <color-text text="Hello World"></color-text>
    <br>
    <color-text></color-text>
    <br>
    <color-text color="#f78" text="Hello World"></color-text>
    <br>    
    <color-text color="#43dt" text="Hello World"></color-text>
    <br>
  </div>
  <script>
      Vue.component('color-text', {
          props: {
              text: String,
              color: {
                  type: String,
                  default: '#000',
                  required: true,
                  valdator(value){
                      //校验规则，判断颜色数值是否合法
                      return /^#([0-9a-fA-F]{6}|[0-9a-fA-f]{3})$/.test(value)
                  }
              }
          },
          template: '<span :style="{ color: color }">{{ text }}</span>'
      })
  </script>
  #+END_SRC
**** 方法选项(methods)
+ 注意不要使用箭头函数在其中定义方法，在创建组件时，methods中的方法将被绑定到Vue实例上，方法中的this将自动指向Vue实例，此时如果使用箭头函数的话，this无法正确指向Vue实例，带来不必要的麻烦
**** 计算属性选项(computed)
+ 计算属性(computed选项)设计的初衷在于减轻模板上的业务负担，当数据链上出现复杂衍生数据时，我们更期望以一种易于维护的方式使用它，可以避免中模板部分写入过分复杂的业务逻辑，不利用维护
+ 与methods一样，计算属性不能使用箭头函数
+ 计算属性依赖于响应式属性，当且仅当响应式属性变化时，计算属性才会被重新计算，且结果将会被缓存，一直到响应式属性被再次修改，相比于使用methods函数求值，这是一直更高效的机制
+ vue也允许开发者为computed属性赋值，开发者有权定义可被赋值的computed属性，方法类似于定义对象属性描述符中的setter和getter，但此项功能不长用
**** 侦听属性选项(watch)
+ Vue允许开发者使用侦听属性(watch选项)为实例添加被观察对象，并在对象被修改时调用开发者自定义的方法
+ 由于watch更注重于处理数据变化时的业务逻辑，而computed更注重于衍生数据，因此，与computed相比，watch还优于可以异步修改数据，可以用于为组件异步获取ajax请求的返回值，而computed无法实现这种效果
*** DOM渲染
**** 指定被挂载的元素(el)
+ el选项用于指定vue实例的挂载目标，属性值仅限于CSS选择器或DOM节点对象
+ 可以使用$mount方法手动挂载实例 
**** 视图的字符串模板(template)
+ vue可以使用字符串作为实例的模板，模板字符串由template选项接收
+ 模板节点将替换掉原有DOM节点
**** 渲染函数(render)
+ render函数同样也可以用于渲染视图，它提供了回调方法createElement创建DOM节点
+ template和render选项均是用于增加JS代码以减少HTML代码的开发
**** 选项优先级
+ 当el、template、render的功能是一致的，当它们同时存在时就存在优先级问题
+ 当el、template、render同时存在时render优先
+ 当el、template共存时，template优先
*** 封装复用
**** 过滤器选项(filter)
+ filter选项用于定义中当前组件或实例作用域中可用的过滤器，可中双大括号插值中添加在javascript表达式尾部，以管道符|与表达式隔开，表达式的值将作为参数传入filter中
+ 除了在组件内定义filter外，还可以定义全局filter
  #+BEGIN_SRC js
  Vue.filter('supplyTitle', value => {
      console.log('SupplyTitle');
      return value.replace(/%/g, '')
  })
  #+END_SRC
**** 自定义指令选项(directives)
+ vue为自定义指令提供了如下钩子函数(均为可选)
  - bind：指令与元素绑定时调用
  - inserted：指令绑定的元素被挂载到父元素上时调用
  - update：指令所在VNode更新时调用，可能发生在其子VNode更新之前
  - componentUpdated：指令所在VNode及其子VNode全部更新后调用
  - unbind：指令与元素解绑时调用
+ 钩子函数会被传入以下参数
  - el：指令所绑定的元素，可用于操作DOM
  - binding：包含指令相关属性的对象
+ 可以定义全局的自定义指令
**** 组件注册选项(components)
+ components选项用于为组件注册从外部引入的组件，由于子组件并非在全局定义，因此不可能直接在父组件的作用域中使用，此选项常见的应用场景是引入第三方库中的组件和自定义组件
**** 混入选项(mixins)
+ 与components选项相似，mixins选项也用于注册外部封装好的代码，不过这些代码更加碎片化，并不如组件一样成体系，混入的目的在于灵活地分发组件中一些可复用的功能
+ mixins可以将一些封装好的选项混入到另一个组件中，在混入过程中，如果没有发生冲突，则执行合并；如果发生冲突且用户没有指定解决策略，vue将采用默认策略
** Vue内置组件
*** 组件服务
+ 
