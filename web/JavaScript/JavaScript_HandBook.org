* 基本语法
** 注释
+ 单行注释 //
+ 多行注释 /*  */
** 语句分隔符
+ 应该在每条语句的末尾加上;作为结束标识 
+ 忽略空白符和换行符
+ 使用\进行折行操作
  document.write('hello\
  world');
** 命名规范
+ 严格区分大小写
+ 变量名必须以字母或_或$开头，余下可以是任意字母、数字或_或$
+ 变量名不能用关键字或保留字
+ 命名规范：驼峰命名法：getElementById (多用于函数、对象、方法、属性)
* HTML文件使用JavaScript
+ 在引用外部JS文件的<script src="*.js"></script>标签对中不要包含JS代码，即使写入了代码也不会被执行，而只会执行外部文件中的代码
+ 可以在HTML页面的任何位置调用,最好的做法是放置在HTML文档的最后，</body>标签之前，可以使浏览器更快的加载页面.
+ 如果存在多个<script>标签，所有标签将被顺序加载，依次执行，作为一个整体，相互联系，相互影响.
+ 常见放置在<head>标签中,如果JS代码中调用某些标签元素，则需要使用window.onload（页面加载完成事件）,
  当一个Web页面加载完成后就会触发执行window.onload 里的代码，一般可以用这个事件做一些页面数据初始化之类的工作.
+ 可以在超链接或是重定向href属性值调用javascrip
  <a href="javascript:confirm('您确认吗？');">报名</a>
+ 可以在事件后面进行调用
  1. 格式：onclick="alert('我是事件')"
     <p onclick="javascript:alert('测试');">事件测试</p>
  2. <script charset="gb2312" src="a.js"></script>解决JavaScript的alert()函数无法显示中文
+ 代码屏蔽
  - 对于不支持js或屏蔽js的浏览器，以下代码将被忽略，而支持的浏览器将正常执行
    <script type='text/javascript'>
    <!--
        js代码
    //-->
    </script>
  - 使用<noscript></noscript>标签提示用户浏览器不支持JavaScript
    <noscript>
      您的浏览器不支持JavaScript，请更换
    </noscript>

* 输出工具
+ alert(); 一般用于调试逻辑错误
+ console.log();  一般用于调试语法错误
+ document.write();
+ prompt("","");
* 严格模式
强烈建议使用严格模式
** 严格模式的作用
  + 消除js语法的一些不合理、不严谨、不安全的问题，减少怪异行为并保证代码运行安全
  + 提高编译器效率，增加运行速度
** 使用方式
  + 全局使用严格模式
    1. "use strict"; 放在脚本文件的第一行，则整个脚本都将以"严格模式"运行。如果这行语句不在第一行，则无效整个脚本以"正常模式"运行，
       如果不同模式的代码文件合并成一个文件，这一点需要特别注意.
  + 函数内部使用严格模式
    1. "use strict"; 放在函数体的第一行，则整个函数以"严格模式"运行.
  + 变通写法(更好的方式)
    1. 因为第一种调用方法不利于文件合并，所以更好的做法是，借用第二种方法，将整个脚本文件放在一个立即执行的匿名函数之中
** 严格模式的语法和行为
  + 全局变量显式声明
    - 在正常模式中，如果一个变量没有声明就赋值，默认是全局变量。严格模式禁止这种用法，全局变量必须显式声明。
    - 严格模式下，变量都必须先用var命令声明，然后再使用，不能隐式声明或定义变量
  + 静态绑定
    - Javascript语言的一个特点，就是允许"动态绑定"，即某些属性和方法到底属于哪一个对象，不是在编译时确定的，而是在运行时（runtime）确定的。
    - 严格模式对动态绑定做了一些限制。某些情况下，只允许静态绑定。也就是说，属性和方法到底归属哪个对象，在编译阶段就确定。这样做有利于编译效率的提高，也使得代码更容易阅读，更少出现意外。
  + 创设eval作用域
    - 正常模式下，Javascript语言有两种变量作用域（scope）：全局作用域和函数作用域。严格模式创设了第三种作用域：eval作用域。
    - 正常模式下，eval语句的作用域，取决于它处于全局作用域，还是处于函数作用域。严格模式下，eval语句本身就是一个作用域，不再能够生成全局变量了，它所生成的变量只能用于eval内部。
  + 增强的安全措施
    - 禁止this关键字指向全局对象，因此使用构造函数时，如果忘了加new，this不再指向全局对象，而是报错。
    - 禁止在函数内部遍历调用栈
  + 禁止删除变量
    - 严格模式下无法删除变量。只有configurable设置为true的对象属性，才能被删除。
  + 显式报错
    - 正常模式下，对一个对象的只读属性进行赋值，不会报错，只会默默地失败。严格模式下，将报错。
    - 严格模式下，对一个使用getter方法读取的属性进行赋值，会报错。
    - 严格模式下，对禁止扩展的对象添加新属性，会报错。
    - 严格模式下，删除一个不可删除的属性，会报错。
  + 重名错误
    - 对象不能有重名的属性    
          正常模式下，如果对象有多个重名属性，最后赋值的那个属性会覆盖前面的值。严格模式下，这属于语法错误。
    - 函数不能有重名的参数
          正常模式下，如果函数有多个重名的参数，可以用arguments[i]读取。严格模式下，这属于语法错误。
  + 禁止八进制表示法
    - 正常模式下，整数的第一位如果是0，表示这是八进制数，比如0100等于十进制的64。严格模式禁止这种表示法，整数第一位为0，将报错。
  + arguments对象的限制
    - 不允许对arguments赋值
    - arguments不再追踪参数的变化
    - 禁止使用arguments.callee，这意味着，你无法在匿名函数内部调用自身了。
  + 函数必须声明在顶层
    - 将来Javascript的新版本会引入"块级作用域"。为了与新版本接轨，严格模式只允许在全局作用域或函数作用域的顶层声明函数。也就是说，不允许在非函数的代码块内声明函数。
  + 保留字
    - 为了向将来Javascript的新版本过渡，严格模式新增了一些保留字：implements, interface, let, package, private, protected, public, static, yield。使用这些词作为变量名将会报错。
* 变量
** 声明方式
*** var关键字
+ 先声明后赋值 
  var bbs; 
  var="bbs.abbs.com";
+ 同时声明和赋值 var url="www.sohu.com";
+ 同时声明多个变量并赋值 var name="zpbird",age=38,sex="man"; 
  var a=b=c=d=5;
+ 通过var声明的变量都是局部变量，在变量所在的函数退出后就会被销毁.
*** 直接通过赋值操作声明变量
+ 不使用var声明，通过赋值直接创建变量，则该变量会被定义为全局变量，不建议这种操作
  例如:url="www.aboutcg.com";
** 知识点
+ 如果出现变量同名的情况，后者会覆盖前者
+ 当变量声明但未赋值时，此时变量的默认值为undefined
+ js中可以通过赋值更改变量的数据类型，但不建议这么做.
+ 在声明变量的同时最好赋予初始值，这样就可以通过typeof操作符来检测一个变量是否已经被声明，
  否则typeof检测声明未赋值和根本未声明的变量时返回的都是undefined，无法区分.
** 变量类型
*** 基本类型
+ 基本类型是指简单的数据段
+ 
*** 引用类型
+ 引用类型是指那些可能由多个值构成的对象，所有引用类型的值都是Object的实例
+ 将一个值赋予变量时，解析器必须判断这个值是基本类型值或引用类型值，
  基本类型是按值访问，可以操作保存在变量中的实际值；引用类型的值是指向保存在内存中对象的指针，
  js不允许直接访问内存中的位置，在操作对象时，实际上是在操作对象的引用而不是实际的对象，因此引用类型的值是按引用访问的。
+ 基本类型的变量可以进行多种操作，引用类型的变量可以为其添加删除属性和方法。
** 复制变量值
+ 复制基本类型的变量值时，两个变量保存的是两个不同的副本，在后续的运算和操作中互相独立，不会相互影响
+ 复制引用类型的变量值时，复制的是对象的指针，两个变量保存的指针指向的是内存中的同一个对象，所以通过一个变量改变对象，另一个变量也会相应改变
** 参数传递
+ js中所有函数的参数都是按值传递的，也就是说，把函数外部的值复制给函数内部的参数，就和把值从一个变量复制到另一个变量一样
** 检测类型
+ 检测变量是否为基本类型 typeof
+ 检测变量是否为某一类型的对象 instanceof
  - alert(person instanceof Object); //由于所有引用类型的值都是Object的实例，所以始终返回为true
  - alert(color instanceof Array); //变量color是数组对象吗？
  - alert(pattern instanceof RegExp); //变量pattern是RexExp对象吗？
** 作用域
*** 全局变量
+ 在代码的任何地方都能访问的变量
+ 函数外面定义的变量
+ 没有通过var定义而直接通过赋值产生的变量，为全局变量
+ 尽可能少的使用全局变量，容易出现bug
*** 局部变量
+ 函数内部定义的变量就是局部变量
+ 可以提高程序的逻辑性和安全性，减少名字的冲突
+ 局部变量只能在固定的代码段(一般指函数内部)访问的变量
*** 作用域链
*** 延长作用域链 
+ try-catch语句的catch块
+ with语句
*** 没有块级作用域
+ if(){}; for(){};while(){};等语句中定义的变量不是局部变量
*** 变量声明 
+ 使用var关键字声明的变量为局部变量(自动添加到最近的环境中)
+ 不使用var关键字声明，直接使用的变量为全局变量
** 垃圾回收
+ 解除变量的引用不仅有助于消除循环引用的现象，对垃圾回收也有好处。
  为了确保有效回收内存，应该及时解除不再使用的全局对象，全局对象属性及循环引用变量的引用
  例如：vMan=null；
* 数据类型
** 基本类型
+ 为了便于操作基本类型值，JS提供了3个特殊的引用类型：Boolean、Number、String。实际上每当读取一个基本类型值的时候，后台就会创建一个对应的基本包装类型的对象，从而可以调用对应的方法操作这些数据。
+ 引用类型与基本包装类型的主要区别就是对象的生存周期。使用new操作符创建的引用类型的实例，在执行流离开当前作用域之前一直都保存在内存中。而自动创建的基本包装类型的对象，则只存在于一行代码的执行瞬间，然后立即被销毁，这就意味着不能在运行时为基本类型值添加属性和方法。
*** number 
+ 包括整型和浮点型，支持二进制、八进制、十进制、十六进制、科学计数法、还包括一些特殊的值
+ 所有数值都以双精度浮点型存储
+ 永远不要测试某个特定的浮点数值，由于浮点数都隐含有四舍五入，所以无法进行a+b==0.3这种判断
+ 八进制   必须以"0",后面的数字不能超过“7”,如果后面的数字超过8,那么会把这个数  字当成十进制的数字来处理。
+ 十六进制  从0-9  A-F  ,必须以"0x"开头.
+ 最大值 Number.MAX_VALUE  alert(Number.MAX_VALUE );
+ 最小值 Number.MIN_VALUE  alert(Number.MIN_VALUE);
+ Infinity无穷大、Infinity无穷小
  - alert(Number.POSITIVE_INFINITY===Infinity)
  - alert(Number.NEGATIVE_INFINITY===-Infinity)
  - isFinite()  判断一个数字是否是无穷的
+ NaN  不能转换为数字时用于系统提示，任何涉及NaN的操作例如（NaN/10）都会返回NaN，NaN与任何值都不相等包括NaN本身，NaN==NaN 的结果是false
+ isNaN() not a  number  不能转换成数字返回为真，能转换为数字返回为假
+ 类型转换
  - boolean : 0、NaN false    1、infinity true
  - string : 0、1 "0"、"1"     infinity "infinity"     NaN "NaN"
+ 与Boolean类型同理，不要使用Number对象
*** string
+ 用单双引号来说明，所包围的值都是字符串
+ 用单双引号运行效率是一样的（php中单引号比双引号运行效率高）
+ 用单双引号必须成对出现，可以嵌套使用
+ 特殊字符(转义符)：\n 换行   \t 制表符  \b 空格   \r 回车   \' '    \" "    \\ \
+ 类型转换
  - boolean : 非空字符串 true      ""空字符串 flase 
  - number :  非空字符串纯数字型"1234" 1234       
              非空字符串非纯数字性"1abc23de"   NaN    
              ""空字符串 0
**** 字符串属性和方法
+ str.length 字符串的长度
+ str.charAt(); 显示指定位置的字符
+ str.charCodeAt(); 显示指定位置字符的编码值
  - 0～9(48~57) a~z(97~122) A~Z(65~90)
  - 这个方法可以用于输入检测，如非数字等
  - 使用String.fromCharCode();这个静态方法可以显示编码值显示的字符
+ str.indexOf(); 显示指定字符(字符串)在字符串中的位置，从左向右找
+ str.lastIndexOf(); 从右向左找
+ str.substring(); 截取字符串
  - str.substring(5); 删除第五个及其之前的字符，保留之后的字符
  - str.substing(0,3); 保留从第一个到第三个的字符串，删除后面的
+ str.slice(); 与substring()总体相同，主要区别在于起始值可以为负数，当为负数时，从后向前数
+ str.toUpperCase(); 转换为大写
+ str.toLowerCase(); 转换为小写
+ str.split(); 把字符串通过指定的分割字符分割为几段，存放在数组中，使用''作为分割符，则会拆分出每一个字符
+ arr.join(); 将数组中的元素拼接为一个字符串，默认数组元素之间会增加',',使用''作为参数会去掉这个','
*** boolean 
+ 理解基本类型的布尔值与Boolean对象之间的区别是非常重要的，但永远不要使用Boolean对象。
+ true、false
+ 条件语句导致系统执行的隐式类型转换
+ 类型转换
  - number : true 1        false 0
  - string : true "null"   false "false"
*** undefined
+ 已声明未赋值的变量
  - var a; alert(a); 
  - 默认为Undefined类型，并且值为"undefined"
+ 隐式声明的变量(直接使用，之前未曾声明)
  - alert(b);
+ 获取对象不存在的属性
  - var obj = {a:1,b:2}; alert(obj.c);
+ 无返回值的函数的执行结果
+ 函数的参数没有传入
  - function f(i,j){alert(i); alert(j);} f(1); 此时j的值就是undefined
+ void(expression)
+ 类型转换
  - boolean : false
  - number : Nan
  - string : "undefined"
*** null
+ null表示对象不存在 alert(document.getElementById("不存在的id选择器"))返回的结果为null
+ null表示一个空对象的指针，所以使用typeof检测null时返回的是"object"
+ 如果定义的变量准备用于保存对象，那么在声明时应该明确的初始赋值为null，而不是其它值，这样就可以检测变量是否已经保存了一个对象的引用
+ null类型的变量，值为null，但是在typeof时显示为object
+ 实际上undefined是派生自null，所以alert(null==undefined)； 结果为true
+ 类型转换
  - boolean : false
  - number : 0
  - string : "null"
** 引用类型
对象是某个特定引用类型的实例。新对象是使用new操作符跟一个构造函数来创建的，构造函数本身就是一个函数，此函数是出于创建新对象的目的而定义的
*** object 对象
**** Object是使用最多的一个类型，虽然Object的实例不具备多少功能，但对于在应用程序中存储和传输数据而言，是非常理想的选择。
**** Object类型是一个基础类型，其他所有的类型都从Object继承了基本的行为
**** 创建Object的实例有两种方法
***** 构造函数方式：var person = new Object();
                        person.name="Tom";
                        person.age=29;
                      
***** 对象字面量方式：var person = {
                         name : "Tom",
                         age : 29
                         };
         对象字面量方式更为常用，一是可以减少代码量，同时也是向函数传递大量可选参数的首选方式，在函数中最好的做法是对那些必需值使用命名参数，使用对象字面量来封装多个可选参数。
         function displayinfo(args){
             var output = "";
             if (typeof args.name == "string"){
             output += "Name: " +　args.name + "\n";
             }
             if (typeof args.age == "number"){
             output += "Age: " + args.age + "\n";
             }
             alert(output);
         }
     
         displayinfo({
             name : "Tom",
             age : 29
         });
         displayinfo({
         name : "Jack"
         });
     
**** 对象属性和方法的引用方式
      "." 通常使用"."的形式访问对象属性或方法
      "[]" 优点是可以使用变量动态访问对象的属性或方法
**** 所有对象都包含如下方法
toLocaleSting()
toString()
valueOf()
*** array 数组
**** 数组常规操作
+ 创建数组,下标从0开始
  . 通过对象方式创建,javascript语言是基于对象的，可以用对象方式创建变量
       var a = new String("大家好")；
       var b = new Number(9);

       直接赋值，如果括号中只有一个成员并且为数值型，则默认是创建了一个指定长度的数组
       var c = new Array(成员1、成员2、成员3...);

       创建后再赋值
       var c = new Array();
       c[0]=1; c[1]=2;c[2]=3;
  . 隐形声明方式
       var a = [];
       直接赋值 var a = [1,2,3,4];
+ 数组长度 数组.length属性
  这个属性可读可写、通过指定数组.length=0;可以快速清空数组
+ 数组可以存储任何类型的值
+ 遍历数组成员
   . 通过for循环
        for (var i=0;i<arr.length;i++){alert(arr[i]);}
   . for in 一般专用于数组和对象的遍历
        for (var i in arr){alert(arr[i]);}
+ 多维数组(主要用到的是二维数组)
   var a = [[1,2,3],[4,5,6]];
+ 数组长度动态可变
+ 向数组尾部追加数据 arr.push("我是最后一位")，添加的数据时数组中的最后一位
**** JS数组的特点
***** 数组的每一个元素都可以分别保存不同的任何类型的数据
***** 数组的大小可以动态的调整，可以随着数据的增加自动增长以容纳新增数据，如果预先知道数组的长度，也可以在声明时指的(不是必须的)。
**** 创建数组变量
***** 构造函数 var colors = new Array(); 
        var colors = new Array(20);(指定了数组的长度而不是第一个元素为数字20)
        var color = new Array("red","green","blue");
        使用构造函数创建数组变量时可以省略new关键字 var color = Array();
***** 字面量  var color = [];
       var name = ["Tom","Jack"];
**** 引用数组元素
***** 在读取、设置数组元素的值时，要使用[]并提供元素对应的基于0的数字索引
alert(colors[0]);
colors[3] = "black";
如果指定的数字索引大于数组长度，数组会自动增加到该索引值+1的长度
***** 数组的length属性保存数组的长度，而且这个属性是可以修改的，通过修改length属性可以从数组的末尾删除或添加元素。
var color = new Array("red","green","blue");
color[color.length] = "black";
alert(color.length); //显示结果为4
**** 检测数组
***** 对于一个网页或全局作用域而言，使用instanceof操作符就能得到满意的结果。 
if(value instanceof Array){
        //对数组执行某个操作；
}
***** 如果网页中包含多个框架，那实际上就存在多个不同的全局作用域，从而存在多个不同版本的Array构造函数。当从其中一个框架向另一个框架传递数组时，由于构造函数不同，可能会造成冲突和错误，使用Array.isArray();方法可以跨多个全局作用域确认某个值是否为数组。
if(Array.isArray(value)){
    //对数组执行某个操作；
}
 
**** 转换方法
**** 栈方法
+ 数组可以表现的像栈一样(后进先出) ，在栈中元素的插入(推入)和删除(弹出)，只发生在一个位置---栈的顶部(数组的尾部)。
  JS提供了push()和pop()方法来实现类似栈的行为方式。
+ push() 可以接收任意数量的参数，逐个添加到数组的末尾，返回修改后数组的长度
+ pop() 从数组末尾删除最后一个元素，返回被删除元素的值
**** 队列方法
+ 队列方法的规则是先进先出，在末尾添加数据，从头部删除数据
+ shift() 删除数组中的第一个元素，返回被删除元素的值
+ unshift() 在数组头部插入任意多个元素，返回数组新的长度值
**** 重排序方法 
+ reverse() 反转数组中元素的排序
+ sort() 按升序排列数组中的元素，为了实现排序sort()方法会调用toString()转换方法转换数组中所有元素的值为字符串，然后进行排序
  - sort()默认的排序规则可能不会得到期望的结果，此时可以传递一个比较函数来指定排序规则，下面的比较函数compare()可以适用于大多数数据类型
    #+BEGIN_SRC 
      function compare (value1,value2){
           if(value1<value2){
               return -1;
           }
           else if(value1>value2){
               return 1;
           }
           else { return 0; }
      }
      var values = [0,1,5,10,15];
      values.sort(compare);
      alert(values); //0,1,5,10,15 数值型数值排序时，默认转换为字符串时，得到的结果不正确
    #+END_SRC
  - 针对数字排序的简化版
    #+BEGIN_SRC 
      var arr = [4,3,5,7666,2,0,8,9];
      arr.sort(function(a,b){ 
               return a-b; //从小到大
             //return b-a; //从大到小
             });
      alert(arr);
    #+END_SRC
  - 字符串形式的数字(带有单位)
    #+BEGIN_SRC 
      var arrWidth = ['100px','34px','568px','22px','999px'];
      arrWidth.sort(function(a,b){ 
               return parseInt(a)-parseInt(b); //从小到大
             });
      alert(arr);
    #+END_SRC
  - 随机排序
     #+BEGIN_SRC 
      var arr = [4,3,5,7666,2,0,8,9];
      arr.sort(function(a,b){ 
               return Math.random()- 0.5;
             });
      alert(arr);
    #+END_SRC
**** 操作方法
***** concat() 基于当前数组创建一个新的数组，具体过程为先创建当前数组的一个副本，然后将接收的参数添加到这个副本的尾部，最后返回新构建的数组。如果没有给concat()传递参数，则只是复制当前数组返回副本；如果参数为一个或多个数组，则将参数数组中的所有元素添加到结果数组中；如果参数不是数组，则简单的将值添加到结果数组中。
***** slice(开始序列号，结束序列号) 截取数组，参数中可以只包含开始序列号，则截取到数组末尾。如果参数为负数，则实际数值为数组长度加上负数的结果；如果结束序列号小于开始序列号，则返回空数组。
***** splice() 最强大的数组方法，主要用途是向数组中部插入元素。splice()始终返回一个数组包含从原始数组中删除的元素，如果没有删除任何元素，返回空数组，使用方式主要有以下3种：
****** 插入：可以向指定位置插入任意数量的元素，需要提供3个参数：起始位置、0(要删除的项数)、要插入的元素(这里可以是任意多个元素)
****** 删除：可以删除任意数量的元素，需要指定2个参数：要删除的起始位置、要删除的个数
****** 替换：向指定位置插入任意数量的元素，同时删除任意数量的元素，需要指定3个参数：起始位置、删除个数、插入的元素(任意多个)。删除和插入的个数可以不必相同。
**** 位置方法
indexOf()、lastIndexOf() 用于查找某个元素在数组中的位置，参数：所要查找的元素、开始查找的起点(可选)，当查找不到时返回-1，当进行查找时，使用的是全等操作符(===),要求值和数据类型全部相等。
**** 迭代方法
JS定义了5个迭代方法，每个方法都接收2个参数：要在数组中某个元素上运行的函数、运行该函数的作用域对象--影响this的值(可选)。传入方法中的函数会接收三个参数：数组元素的值、该元素在数组中的位置、数组对象本身。根据使用方法不同，这个函数执行后的返回值可能会也可能不会影响访问的返回值。
****** every() 对数组中的每个元素运行给定函数，如果每个返回值都为true，则返回true，一般用于查询数组中的元素是否满足某个条件。
****** filter() 对数组中的每个元素运行给定函数,返回该函数返回true的元素组成的数组
****** forEach() 对数组中的每个元素运行给定函数,此方法没有返回值
****** map() 对数组中的每个元素运行给定函数,返回每次函数运行结果组成的数组
****** some() 对数组中的每个元素运行给定函数,任何一个运行结果为true，则返回true，一般用于查询数组中的元素是否满足某个条件
**** 缩小方法
reduce()、reduceRight() 这两个方法都会迭代数组中的所有元素，然后生成一个最终的返回值。这两个方法接收两个参数：某个元素都会运行的函数、作为缩小基础的初始值(可选)。传递函数接收4个参数：前一个值、当前值、元素的索引、数组对象。这个函数返回的任何值都会作为第一个参数自动传递给下一个元素。第一次迭代发生在数组的第二个元素上，因此第一个参数是数组的第一个元素，第二个参数就是数组的第二个元素。
例如：可以执行数组使用元素值求和操作
var values = [1,2,3,4,5];
var sum = values.reduce(function(prev,cur,index,array){
    return prev+cur;
});
alert(sum);
**** 数组去重方法
***** 双for循环方法
#+BEGIN_SRC 
  var arr = [1,2,2,5,2];
  for (var i=0; i<arr.length; i++){
      for (var j=i+1; j<arr.length; j++){
          if (arr[i] == arr[j]){ 
              arr.splice(j,1);
              j--;
          }
      }
  }
  alert(arr);
#+END_SRC
***** 哈希值(hash)方法
#+BEGIN_SRC 
   var arr1=[1,5,4,2,2,2,6,2,2,2,4,8];
        function uique(arr){
            for(var i=0,hash=[],res=[];i<arr.length;i++){
                if(hash[arr[i]]===undefined){
                  hash[arr[i]]=true;
                  res[res.length]=arr[i];
                }
            }
            return res;
        }
        res=uique(arr1);
#+END_SRC
**** 连接数组方法
+ arr1.concat(arr2,arr3);
+ 返回的是一个新的数组
*** Json格式数据
**** 格式说明
+ 名:值对中名字的部分可以不加引号，但使用引号更加稳定、安全，尤其使用[]调用属性时，属性名称必须加引号
**** 声明方式
var json = { 'name' : 'zpbird',
             'age' : 38,
             'aihao' : ['football','draw','eat']
};
**** 调用方式
+ 通过'.'调用，alert(json.name);
+ 通过[]调用，alert(json['name']); 这里必须要求加引号
**** fon-in 遍历json
+ for ( var attr in json ) {
      alert(attr);         显示属性名
      alert(json[attr]);   显示属性值        
  };
*** function 函数
**** JS中最有特点的地方就是函数，函数实际上是对象，每个函数都是Function类型的实例，而且与其他引用类型一样具有属性和方法。由于函数是对象，因此函数名实际上也是一个指向函数对象的指针，不会与某个函数绑定。
**** 函数的创建
***** 函数声明语法
function sum (num1,num2){
    return num1+num2
}

***** 创建函数变量
var sum = function(num1,num2){
    return num1+num2
};
- 此处不需要函数名，而是通过变量引用函数，由于函数名仅仅是指向函数的指针，因此函数名与包含对象指针的其他变量没有什么不同，也就是说一个函数可能会有多个名字。
- 语句的结尾要有分号

***** 构造函数不推荐
var sum = new Function();
***** 定义两个同名函数时，后面的函数名会覆盖前一个

**** 没有重载
函数名仅仅就是指向函数的指针，即使是在不同的环境中执行，全局的saycolor()函数和o.saycolor()(对象的方法)引用的仍然是同一个函数，也就解释了为什么JS没有函数重载的概念。

**** 函数声明与函数表达式 
- 函数声明
  alert(sum(10,20));
  function sum(num1,num2){
      return num1+num2;
  }
- 函数表达式
  var sum = function(num1,num2){
                return num1+num2;
            }
  alert(sum(10,20));
- 函数声明与函数表达式在解析器向执行环境中加载数据时是有区别的，解析器会率先读取函数声明，并使其在执行任何代码之前可用(可以访问)；而函数表达式必须等到解析器执行到它所在的代码行时，才会真正被解释执行。

**** 作为值的函数
- 在JS中函数名本身就是变量，使用函数也可以作为值来使用。不仅可以把函数作为参数传递给另一个函数，还可以作为另一个函数的结果返回。
- 要访问函数的指针而不执行函数的话，必须去掉函数名后面的圆括号，直接执行函数名()就是执行函数。

**** 函数内部的属性
- arguments对象
  arguments是一个类数组的对象，包含传入函数的所有参数。arguments的主要用途是保存函数参数，它有一个callee属性，该属性是一个指针，指向拥有这个arguments对象的函数，常用于递归函数的编写。
- this对象
 . this对象引用的是函数据以执行的环境对象(this的值)，当在网页的全局作用域中调用函数时，this对象引用的就是windows。
 . 在调用函数之前，this的值并不确定，因此可能会在代码执行过程中引用不同的对象。
- 函数的caller属性 这个属性中保存着调用当前函数的函数的引用，如果是在全局作用域中调用当前函数，它的值为null。

**** 函数属性和方法
- length属性 表示函数希望接收的命名参数的个数。
- prototype属性
  对于引用类型而言，prototype是保存他们所有实例方法的真正所在。换句话说，toString()和valueOf()等方法实际上都保存在prototype名下，只不过是通过各自对象的实例访问罢了。在创建自定义引用类型以及实现继承时，prototype属性的作用是极为重要的。此属性是不可枚举的，无法使用for-in遍历。
- apply()方法 在特定的作用域中调用函数，实际上等于设置函数体内this对象的值。
  接收两个参数：一个是在其中运行函数的作用域；另一个是参数数组，即可以是Array的实例，也可以是arguments对象。
- call()方法 在特定的作用域中调用函数，实际上等于设置函数体内this对象的值。与apply()方法的作用相同，区别仅在于接收参数的方式不同：一个是在其中运行函数的作用域；其余为逐个列举的参数，而不是数组。
- apply()和call()方法真正强大的地方是能够扩充函数赖以运行的作用域，这样做的的最大好处是对象不需要与方法有任何耦合关系。
- bind()方法 这个方法会创建一个函数的实例，其this值会被绑定到传给bind()函数的值。
*** Date类型
**** 常规使用
***** 创建日期 var now = new Date(); 在不传递参数的情况下，自动获取当前日期和时间。
***** parse() 接收一个表示日期的字符串参数，然后尝试根据这个字符串返回相应日期的毫秒数，如果该字符串不正确返回NaN，此方法可以省略直接写入Date()构造函数中。
var someDate = new Date(Date.parse("May 25 2014"));
var someDate = new Date("May 25 2014");
***** UTC()
***** 常用方法
+ getFullYear()
+ getMonth() 从0开始需要加1
+ getDate()
+ getDay() 星期几
+ getHours()
+ getMinutes()
+ getSeconds()
+ 例如： var myDate = new Date(); var myMonth = myDate.getMonth(;)
**** 继承的方法
- 与其他引用类型一样，包含有toLocalString()、toString()、valueOf()方法，但Date类型重写了这些方法。
- toLocalString()方法会按照与浏览器设置的地区相适应的格式返回日期和时间，一般包含AM或PM，但不包含时区；toString()通常返回带有时区的日期和时间，这两个的差别只有在调试代码时比较有用，在显示时间和日期时则没有什么价值。
- valueOf() 返回日期的毫秒数表示，因此可以用于比较两个日期的大小(早晚)
**** 日期格式化方法 专门用于将日期格式化为字符串的方法
- toDageString() 以特定实现的格式显示星期、月、日、年
- toTimeString() 时、分、秒、时区
- toLocaleDateString() 以特定地区实现的格式显示星期、月、日、年
- toLocaleTimeString() 
- toUTCString() 
**** 日期/时间组件方法
- getTime() 与valueOf()返回的值相同
- ......
*** RegExp类型
**** 创建正则表达式
***** 字面量 var expression = / pattern / flags ;
构造函数 var expression = new RegExp("pattern","flags");
***** pattern 可以是任何简单或复杂的正则表达式，可以包含字符类、限定符、分组、向前查找、反向引用。
***** flags 每个正则表达式可以带一个或多个标志(flags)，用以标明正则表达式的行为。正则表达式的匹配模式支持以下3个标志
- g：表示全局模式(global)，应用于所有字符串，而非在发现第一个匹配项时立即停止
- i：表示不区分大小写
- m：表示多行模式
***** 模式中所有元字符都必须用"\"进行转义，这些元字符包括() [] {} \ ^ $ | ? * + .
在使用构造函数创建正则变量时传递给构造函数的参数必须时字符串，在某些情况下需要进行双重转义，例如：/\[bc\]at/    "\\[bc\\]at"
***** 字面量和构造函数创建的正则表达式有一个重要的不同点：字面量始终共享同一个RexExp实例，而通过构造函数创建的每个都是新的不同的RexExp实例。
**** 实例属性
RegExp的每个实例都具有下列属性，通过这些属性可以取得有关模式的各种信息。
- global：布尔值，表示是否设置了g标志
- ignoreCase：布尔值，表示是否设置了i标志
- lastIndex：整数，表示开始搜索下一个匹配项的字符位置，从0算起
- multiline：布尔值，表示是否设置了m标志
- source：正则表达式的字符串表示，按照字面量形式而非传入构造函数中的字符串模式返回
**** 实例方法
RegExp对象的主要方法是exec()，该方法是专门为捕获组而设计的。
- exec()接收一个参数，既要应用模式的字符串，然后返回包含第一个匹配项信息的数组，没有匹配项返回null。返回的数组虽然是Array的实例，但包含两个额外的属性：index和input。index为匹配项在字符串中的位置，input表示应用正则表达式的字符串
- 对应exec()而言，即使在模式中设置了全局模式(g),它每次也只会返回一个匹配项。在不设置全局模式的情况下，在同一字符串上多次调用exec()将始终返回第一个匹配项的信息；设置全局模式的情况下，多次调用exec()则都会在字符串中继续查找新的匹配项。
**** 构造函数属性
构造函数的属性适用于作用域中所有的正则表达式，并且基于所执行的最近一次正则表达式操作而变化。使用这些属性可以从exec()或test()执行的操作中提取出更具体的信息。
- input 最近一次要匹配的字符串
- lastMatch 最近一次的匹配项
- lastParen 最近一次匹配的捕获组
- leftContext input字符串中lastMatch之前的版本
- multiline 布尔值，表示是否所有表达式都使用多行模式
- rightContext  input字符串中lastMatch之后的版本
**** 模式的局限性
不支持某些正则表达式的高级特性
  
** 基本类型与引用类型的区别
*** 存储区别
+ 基本类型的变量保存在栈内存中(包括变量名称+变量值)，而引用类型的变量则在栈内存中只保存变量名称+引用指针(指向堆内存)
*** 复制操作区别
+ 复制基本类型变量的操作(var num1=123; var num2=num1;)，会在栈内存中生成新的变量名+变量值
+ 复制引用类型变量的操作(var obj1={a:1}; var obj2=obj1;)，只是在栈内存中生成新的变量名+引用指针，
  这两个变量的引用指针指向堆内存中相同的代码段，更改obj2会同步影响obj1
** 单体内置对象
由JS实现提供的、不依赖于宿主环境的对象，这些对象在程序执行之前就已经存在了。开发人员不必显示的实例化内置对象，因为它们已经实例化了，内置对象有Object、Array、String、Global、Math
**** Global对象
JS中最特别的一个对象，因为从任何角度看，这个对象都是不存在的。它是一个终极的"兜底儿对象"，所有全局变量和函数都是Global对象的属性和方法。
***** URI编码方法
- encodeURI()、encodeURIComponent() 
***** eval()方法
JS中最强大的一个方法，它就像一个完整的解析器，它只接收一个参数，即要执行的JS字符串
***** Global对象的属性
***** window对象
JS中window对象除了扮演Global对象的角色外，还承担了很多别的任务
**** Math对象
Math对象提供的计算功能比自己编写的计算功能执行起来要快的多
** 类型识别的方法
*** typeof 操作符
+ typeof 操作符
  var name="张三";    
  alert(typeof name);
*** Object.prototype.toString
*** constructor
*** instanceof
* 数据类型转换
** 强制转换
*** 转换为数值类型
**** Number(参数)
+ 把任何类型转换为数值类型，此函数在转换时比较复杂且不够合理，所以在处理整数时更为常用的是parseint()
+ 布尔类型 true->1,false->0
+ 数值类型 转换为本身，会将无意义的后导0去掉(例如2.30)
+ Null    转换为0
+ undefined 转换为NaN
+ 对象类型 会先调用对象的valueof()方法，如果返回值的是NaN，则再调用对象的toString()方法
+ 字符串类型 
  - 如果字符串中只有数字，则转换为十进制数字，会忽略无意义的前导0和后导0
  - 如果是有效规范的浮点形式，则会转换为浮点数值
  - 空字符串，则转换为0
  - 其他字符串，则返还NaN
**** parseInt()
+ 将字符串转换为整数，当首字母为字母时，则返回NaN，数字前面可以为空格或"-"负号
**** parseFloat()
+ 将字符串转换为浮点数，字符串中的第一个小数点是有效的，如果字符串是有效的整数，返回的是整数而非浮点数
*** 转换为字符串类型
**** String()
+ 将任何类型转换为字符串类型
+ Null和undefined 直接转换为字面字符
+ 布尔类型 返回true和false
**** toString()
+ 每个对象默认包含此方法，调用格式：对象.toString()，作用是将对象以字符串的方式来表示
+ 数组.toString() 返回以逗号分隔的字符串
+ Boolean.toString() 返回true和false
+ String.toString() 返回本身
+ Number.toString() 返回本身的字符串形式
+ Null和undefined 没有此方法
*** 转换为布尔类型
**** Boolean()
+ 将任何类型转换为布尔类型
+ false  "" 0 NaN undefined false
+ true   其他全部为真
** 隐性转换
*** 函数类
**** isNaN()
+ 该函数对参数进行隐性的Number()转换，如果不成功返回true
**** alert()
+ 该函数会将参数隐性的转换为字符串
*** 运算符类
**** 算术运算符 
+ 运算符"- * / %" 如果操作数不是数值，将隐性的调用Number()转换为数值类型，如果转换不成功返回NaN
+ 运算符"+"如果两边操作数都是数值类型则直接相加，任何数据类型和字符串相加，都会隐性调用他们的toString()方法，
  返回拼接的结果，如果操作数都是布尔类型，则调用Number()进行转，true为1，false为0，进行相加
**** 关系运算符
+ 关系运算符的操作数可以是任意类型，如果不为数值类型，将进行隐性转换
*** 语句类    
**** if(表达式){}else{}
+ if语句中的表达式会隐性的调用Boolean()进行类型转换
* 运算符
** 算术运算符
+ "+" (1)数值计算
      (2)字符串连接  任何的数据类型与字符串相加都是等于字符串
+ "-" 
+ "*" 
+ "/" 
+ "%"(取余) 一般用于取一段范围的值，并且不用于小数，因为结果不确定
+ 自增自减 var++ var-- ++var --var 
** 关系运算符 
+ 运算的结果都是布尔值
+ 都是字符串的时候，会先转换成ASCII码然后进行比较，如果字符串含有多个字符也只是比较第一个字符的ASCII码大小
+ 当一个字符串与数值进行比较时，会把字符串尝试转换成数值类型进行比较，如果不能转换成数值类型，则会返回NaN，然后返回false
+ undefined与null比较，会认为是相等的
+ 数值类型与布尔类型比较时，会将布尔类型转换为数值类型再进行比较，true=1 false=0
+ "< > <= >=" 
+ "==  !=" 只比较值是否相等
+ "===  !==" 比较值是否相等的同时比较类型是否相等
** 赋值运算符
+ "=" 
+ "+="
+ "-="
+ "*="
+ "/="
+ "%="
** 逻辑运算符
+ "and &&"
+ "or  ||"
+ "not !"
+ 逻辑运算符可以对任何类型的数据进行运算，但需要转换为对应的布尔值
  - undefined   false
  - null        false
  - 数值类型     除0以外都是true
  - 字符类型     除空字符串以外都是true
  - 对象类型     true
+ 逻辑运算符表达式本身遵循从左到右的执行顺序，当左边不成立时，右边压根不执行
+ 特殊用法
  - &&和|| 可以直接使用替代简单的if语句
    1<2 && function ( ) { document.write('hello world');}();
  - && 用于判断赋值，左边为真时，将右边的值赋予变量，左边为假时，将false赋予变量
    || 则左边为假时，将右侧值赋予变量
    var a = 12<25 && 'good';
** 一元运算符
+ "typeof"
+ "+ -" 正数 负数
+ "delete" 删除对象的方法或属性
+ "new" 用来创建对象
+ "void" 用来指明一个表达式无返回结果
** 三元运算符
+ "= ? :"根据表达式的计算结果有条件的为变量赋值
+ "= || "
  可以实现函数参数默认值的效果，x=x||0;(如果x有传值，则x为传入值，如果x没有传值，默认为0)
+ "= && "
** 特殊运算符
+ "，"用来一次声明多个变量
+ () 更改运算中的优先级
     运行一段函数
** 位运算符
* 运算符优先级(由高到低)
1. . [] ()
2. ++ -- -~ ! delete new typeof void
3. * / %
4. + -
5. << >> >>>
6. < <= > >= instanceof
7. == != === !==
8. &
9. ^
10. |
11. &&
12. ||
13. ? :
14. = oP =
15. ,
* 分支结构
+ if(条件){代码块}
+ if(条件){代码块}
   else{代码块}
+ if(条件1){代码块}
   else if(条件2){代码块}
   else if(条件3){代码块}
   ...
   else{代码块}
+ switch(值){

     case 值1:
     表达式 1；
     break；

     case 值2:
     表达式 2；
     break；
     ...
     defalut:
     表达式；
     break；
   }

* 循环结构
+ for(var 变量=初始值;变量<=结束值；变化值){代码段}
   用于事先知道循环次数时
+ while(条件){代码段}
   用于无法判断循环次数时
+ do{代码段}while(条件)
   先执行后判断，至少会执行一次
+ for in 用于遍历对象的属性和方法，也可以用于数组
  for ( var attr in obj ) { 
       alert(attr);       显示属性名
       alert(obj[attr]);  显示属性值
  };
* 跳转语句 
在循环结构中，当满足特定条件时，退出循环或当前循环的语句
+ break
  - 跳出且终止循环，如果后面存在代码，则继续往下执行
  - 作用于单层循环
+ continue 
  - 跳出且终止当前循环，如果下个值仍然满足条件，循环将继续
  - 作用于单层循环
+ 退出多层循环
  - 设置标签  标签名: 此种标签只能用于break或continue，否则会出错
  - out:
    break out;
+ with(){} 用于设置代码在特定对象中的作用域，此语句效率比较低下且容易造成混乱，不建议使用
* 函数
** 基础知识
将完成某一特定功能的代码集合封装起来，以便可以重复使用
*** 声明方式
**** 基本语法 此种声明方式浏览器会在执行代码前，进行预先扫、描编译并加载到内存中，可以在任何位置调用
使用驼峰或下划线命名法
function 函数名([参数1],[参数2]...)
                  {
                    代码段
                    [return]
                  }
**** 字面量定义(匿名函数，变量是作为这个函数的一个引用） 
只有执行到当前位置时才会被创建，必须在创建变量的位置后面调用，如果存在与基本语法定义名称相同的函数，会覆盖基本语法声明的函数
var 变量名=function ([参数1],[参数2]...)
                  {
                    代码段
                    [return]
                  }
**** 匿名函数 不给函数起名字，通常用于直接赋予事件
+ 匿名函数可以作为参数传递给其他函数，接收方函数就可以通过所传递进来的函数完成某些功能
+ 可以通过匿名函数来执行某些一次性的任务
window.onload = function(){}
**** 对象(构造函数)形式 
不常用
var 变量名=new Function([参数1],[参数2]..."代码段"); 
**** 在同名的情况下，局部变量的优先级高于全局变量，会依次从最局部的变量依次向全局变量调用，无法调用子级别的变量或函数
*** 调用方式
**** 作为普通函数调用
+ 函数名();
+ 变量名();函数表达式可以存储在变量中，变量也可以作为一个函数使用
+ (function (){})(); 直接通过()调用未定义的函数
+ 浏览器中的全局对象是页面对象即浏览器窗口(window对象)，所以函数会自动变为window对象的函数，也可以通过window.函数名()进行调用
+ 函数不调用不执行
**** 作为全局对象调用
+ 当函数没有被自身的对象调用时，this的值会变成全局对象，浏览器中即为window对象
+ 函数作为全局对象调用，this的值就会变成全局对象，使用window对象作为一个变量容易造成程序崩溃
**** 作为对象的方法调用
+ 可以将函数定义为对象的方法进行调用
**** 作为回调函数调用函数
+ call()
+ apply()
**** 使用构造函数调用函数
+ 如果在函数调用前使用new关键字，则调用了构造函数
**** 自调用匿名函数
+ 不会产生任何全局变量
+ 函数无法重复执行，适合于一次性或初始化的任务
+ (function(x,y){return x+y;})(3,5);
*** 参数
+ 函数可以有或者没有参数，如果定义了参数，但调用时没有传参，在默认值为undefined
+ 在调用函数时，如果传参个数超过了定义时的参数个数，js会忽略多余的参数
+ js中不能直接指定默认值，可以通过arguments对象来实现默认值效果
+ 通过变量值传递参数在函数体内对变量做修改不会影响变量本身
+ 通过对象传递参数在函数体内对变量做修改会影响到本身
+ 可以动态改变函数内对应变量的类型或值，而得到不同的结果
+ 形参可以是任意的数据类型，最多可以有25个参数
+ 实参与形参数量可以相等，也可以不相等
+ 形参多于实参，多出的形参会自动赋值为undefined
+ 实参多于形参，要得到多出实参的值，要使用arguments对象
*** arguments对象
+ 每创建一个函数，该函数会隐性的创建一个arguments对象，他包含实际传入参数的信息
+ length 属性 检测实际传入参数的个数
+ callee 属性 对该函数本身的调用
+ 访问传入参数的值
+ 实现函数重载

*** 函数重载
   同一函数因为参数的类型或数量不同，可以对应多个函数的实现，每种实现对应一个代码段

*** return 语句
  + 停止并跳出当前函数
  + 一个函数可以有多个return,但只会执行其中一个
  + 给函数提供一个返回值 return [返回值]，如果没有返回值则默认为undefined

** 回调函数
通过函数的指针来调用函数，是把一个函数的指针作为另一个函数的参数
  + 通过指针来调用，即不包括()的函数名
  + 通过匿名函数调用
  + call();
  + apply();
** 递归函数
在函数内部直接或简介的调用自己
** 全局函数 顶层对象(window对象)的函数，可以作用于任何对象
+ escape() 对字符串进行编码
+ unescape() 对编码的字符串进行解码
+ Number()
+ String()
+ Boolean()
+ parseInt()
+ parseFloat()
+ isNaN()
+ isFinite() 判断一个数是否为有穷的数字
+ eval() 将字符串转换成JavaScript命令执行
+ encodeURI()
** 闭包(内嵌函数)
. 闭包是指有权访问另一个函数作用域中的变量的函数，创建闭包的常见方式，就是在一个函数内部创建另一个函数。在函数中访问一个变量时，就会从作用域链中搜索具有相应名字的变量。一般来讲，当函数执行完毕后，局部活动对象就会被销毁，内存中只保存全局作用域，但是闭包的情况有所不同。
. 由于闭包会携带包含它的函数的作用域，因此会比其他函数占用更多的内存。过度使用闭包会占用过多的内存，建议只在绝对必要的时候考虑使用闭包。
*** 闭包与变量
**** 作用域链的这种配置机制有一个值得注意的副作用，即闭包只能取得包含函数中任何变量的最后一个值。闭包保存的是整个变量对象，而不是某个特殊的变量。
**** 关于this对象，在闭包中使用this对象有可能导致一些问题
**** 内存泄漏
** 模仿块级作用域
*** 多次声明同名变量，JS会忽略后续的声明，但会执行后续声明中的初始化赋值。
*** 匿名函数可以用来模仿块级作用域，通常称为私有作用域
*** 无论什么地方，只要临时需要一些变量，就可以使用私有作用域
*** 这种技术经常在全局作用域中被用在函数外部，从而限制在全局作用域中创建过多的变量和函数。应该尽量少的在全局作用域中创建变量和函数。在多人开发的项目中容易导致命名冲突，通过使用私有作用域，每个开发者既可以使用自己的变量，又不必担心弄乱全局作用域。
** 私有变量
*** 严格来讲，JS中没有私有成员的概念，所有对象属性都是公有的，但存在一个私有变量的概念。任何函数中定义的变量，都可以认为是私有变量，因为不能在函数外部访问这些变量。
*** 私有变量包括函数的参数、局部变量和函数内部定义的其他函数。
*** 私有变量只有在定义它的函数内部可以访问，函数外部无法访问。如果在这个函数内部创建一个闭包，那么闭包通过自己的作用域链也可以访问这些变量，利用这一点，可以创建用于访问私有变量的公有方法。
*** 有权访问私有变量和私有函数的公有方法被称为特权方法，有两种在对象上创建特权方法的方式
**** 在构造函数中定义特权方法
**** 静态私有变量
**** 模块模式
前面两种方式都是针对自定义类型创建私有变量和特权方法，而模块模式是为单例创建私有变量和特权方法。
**** 增强的模块模式
* 面向对象
** 理解对象
*** 面向对象的语言有一个标志，那就是它们都有"类" 的概念，通过类可以创建任意多个具有相同属性和方法的对象。JS中没有类的概念，因此它的对象也与其他基于类的语言中的对象有所不同。
*** JS把对象定义为：无序属性的集合，其属性可以包含基本值、对象和函数。严格来讲，这就相当于说对象是一组没有特定顺序的值。对象的每个属性或方法都有一个名字，而每个名字都映射到一个值。因此，JS中的对象可以想象为散列表，无非就是一组名值对，其中值可以是数据或函数。
*** 每个对象都是基于一个引用类型创建的，这个引用类型可以是原生类型，也可以是自定义的类型。
*** 属性类型
**** 数据属性 数据属性包含一个数据值的位置，这个位置可以读取和写入值
**** 访问器属性
*** 定义多个属性
Object.defineProperties()方法
*** 读取属性的特性
** 对象分类
*** 原生对象
**** 特殊类型(没有构造函数)
***** Undefined
***** Null
**** 构造器对象
***** Number
***** String
***** Boolean
***** Object
+ object是一组属性和方法的集合
+ string/number/boolean/array/date/error构造器都是object的子类对象，继承object原型对象的属性和方法
+ 实例化对象的方式
  - var obj = {name:"jerry", age:12}; 常用方式
  - var obj = new Object({name:"jerry", age:12});
+ 属性和方法
  - prototype(原型对象)
    + constructor
    + toString
    + valueOf
    + hasOwnProperty
  - Object.create
    + 基于原型对象创建新对象
    + Object.create(proto[,propertiesObject]);
  - Object.prototype.toString
    + 获取方法调用者的标准类型
    + objectObj.toString();
***** Function
***** Array
***** Date
***** Regexp
***** Error
**** 其他对象
***** Math
***** JSON
***** 全局对象
***** arguments
*** 宿主对象
**** DOM
***** window
***** document
**** BOM
***** ActiveXObject
***** Debug
***** VBArray
** 创建对象
*** 基本方式
**** 对象字面量方式
+ var person = {
    name:"Kevin",
    age:31,
  };
**** 使用Object构造函数
+ var person = new Object();
  person.name="kevin";
  person.age=31;
**** 自定义构造函数方式
+ function Person(name,age,job){
    this.name = name;
    this.age = age;
    this.job= job;
    this.sayName = function(){
        alert(this.name);
        };
  }
  var person1 = new Person("Tom",34,"worker");
  var person2 = new Person("Jack",33,"writer");
*** 属性及方法名称的要求
**** 支持三种形式
+ var obj={prop:1,name="zp"};
+ var obj={'prop':1,name="zp"};
+ var obj=("prop":1,name="zp");
**** 必须放在引号之间的情况
+ 名称是保留字
+ 名称包含特殊字符(字母、数字、下划线以外的字符)
+ 名称以数字开头
*** 高级知识
虽然Object构造函数或对象字面量都可以用来创建单个对象，但这些方法有明显的缺点，使用同一接口创建很多对象，会产生大量的重复代码。
**** 工厂模式
***** 工厂模式是软件工程领域一种广为人知的设计模式，这种模式抽象了创建具体对象的过程。
+ 由于JS中没有类，开发人员可以使用一种函数，用函数来封装特定接口创建对象的细节。
+ 缺点：
  - 工厂模式虽然解决了创建多个相似对象的问题，但没有解决对象的识别问题(即怎样知道一个对象的类型)
  - 使用同一接口创建很多对象，会产生大量的重复代码
***** funtion createPerson(name,age,job){
    var o = new Object();
    o.name = name;
    o.age = age;
    o.job = job;
    o.sayName = function(){
        alert(this.name);
    };
    return o;
}
var person1 = createPerson("Tom",23,"student");
var person2 = createPerson("Jack",33,"teacher");
**** 构造函数模式
***** JS中的构造函数可以用来创建特定类型的对象。像Object和Array这样的原生构造函数，在运行时会自动出现在执行环境中。通过创建自定义的构造函数，从而定义自定义对象类型的属性和方法。
function Person(name,age,job){
    this.name = name;
    this.age = age;
    this.job= job;
    this.sayName = function(){
        alert(this.name);
    };
}
var person1 = new Person("Tom",34,"worker");
var person2 = new Person("Jack",33,"writer");
与工厂模式相比有如下不同：
. 没有显示的创建对象
. 直接将属性和方法赋给了this对象
. 没有return语句
***** 构造函数名以大写字母开头，而非构造函数以小写字母开头。
***** 对象的constructor属性最初是用来标识对象类型的，但检测对象类型最可靠的方法是通过instanceof操作符来判断。
***** 将构造函数当作函数
构造函数与其他函数的唯一区别，就在于调用他们的方式不同。任何函数，只要通过new操作符来调用，那它就可以作为构造函数。
***** 创建新的对象实例，必须使用new操作符，而这个过程实际上经历了以下4个步骤：
1、创建一个新对象
2、将构造函数的作用域赋给新对象(因此this指向了这个新对象)
3、执行构造函数中的代码(为新对象添加属性和方法)
4、返回新对象
***** 构造函数的问题
使用构造函数的主要问题是每个方法都要在每个实例上重新创建一遍，产生大量的重复代码
**** 原型模式
***** 我们创建的每个函数都有一个prototype(原型)属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。prototype就是通过调用构造函数而创建的那个对象实例的原型对象。使用原型对象的好处是可以让所有对象实例共享它所包含的属性和方法。换句话说，不必在构造函数中定义对象实例的信息，而是可以将这些信息直接添加到原型对象中。
function Person(){}
Person.prototype.name = "Tom"；
Person.prototype.age = 24;
Person.prototype.job = "worker";
Person.prototype.sayName = function (){
    alert(this.name);
};
在此，将所有属性和方法直接添加到了Person的prototype属性中，构造函数成了空函数。即使如此，仍然可以通过调用构造函数来创建新对象，而新对象还会具有相同的属性和方法。但与构造函数模式不同的是，新对象的这些属性和方法是由所有实例共享的，
***** 理解原型对象
****** 创建新的函数时，会根据一组特定的规则为该函数创建一个prototype属性，这个属性指向函数的原型对象。默认情况下，所有原型对象都会自动获得一个constructor(构造函数)属性。这个属性包含一个指向prototype属性所在函数的指针。
****** 创建自定义构造函数之后，其原型对象默认只会取得constructor属性，其他方法都是从Object继承而来的。
****** 可以通过isPrototype()方法来确定对象之间是否存在这种关系。
****** 通过Object.getPrototype()方法来获取prototype中属性的值
****** 虽然可以通过对象实例访问保存在原型中的值，但不能重写原型中的值。如果在对象实例中定义了相同名称的属性，则该属性会屏蔽原型中的同名属性值，而不是改写。
***** 原型与in操作符
***** 更简单的原型语法
function Person(){}
Person.prototype = {
    name = "Tome",
    age = 23,
    job = "fisher",
    sayName = function(){
        alert(this.name);
    }
};
在这里相当于将Person.prototype属性设置为一个以对象字面量形式创建的新对象。这种写法，本质上完成重写了默认的prototype对象，因此constructor属性也就变成了新对象的constructor属性(指向Object构造函数)，不再指向Person函数了。尽管instanceof操作符还能返回正确的结果，但通过constructor已经无法确定对象的类型了。通过添加constructor : Person, 来修正。
***** 原型的动态性
***** 原生对象的原型
***** 原型对象的问题
****** 由于省略了为构造函数传递初始化参数这一环节，结果所有实例在默认情况下都取得相同的属性值。
****** 原型对象的最大问题是其共享的本质造成的。而这点上是很少有人单独使用原型模式的原因。
**** 组合使用构造函数模式和原型模式
创建自定义引用类型最好的方式是组合使用构造函数模式和原型模式。构造函数模式用于定义实例属性，原型模式用于定义方法和共享的属性。每个实例都拥有自己的一份实例属性的副本，同时又共享着对方法的引用，最大限度节省了内存。另外，这种混合模式还支持向构造函数传递参数。
+ function Person(name,age,job)
  {
    this.name=name;
    this.age=age;
    this.job=job;
　　 this.friends=["Jams","Martin"];
  }
  Person.prototype.sayFriends=function()
  {
    alert(this.friends);
    };
  var person1 = new Person("kevin",31,"SE");
  var person2 = new Person("Tom",30,"SE");
  person1.friends.push("Joe");
  person1.sayFriends();//Jams,Martin,Joe
  person2.sayFriends();//Jams,Martin
**** 动态原型模式
这个模式的好处在于看起来更像传统的面向对象编程，具有更好的封装性，因为在构造函数里完成了对原型创建。这也是一个推荐的创建对象的方法
+ function Person(name,age,job)
  {
    //属性
    this.name=name;
    this.age=age;
    this.job=job;
    this.friends=["Jams","Martin"];
    //方法
    if(typeof this.sayName !="function")
    {
        Person.prototype.sayName=function()
        {
            alert(this.name);
        };
        
        Person.prototype.sayFriends=function()
        {
            alert(this.friends);
        };
    }
  }

var person = new Person("kevin",31,"SE");
person.sayName();
person.sayFriends();
**** 寄生构造函数模式
**** 稳妥构造函数模式
** 继承
*** OO语言都支持两种继承方式：接口继承和实现继承。JS只支持实现继承，而且其实现继承主要依靠原型链来实现的。
*** 原型链
**** 原型链是JS实现继承的主要方法，其基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法
**** 构造函数、原型对象、实例关系
***** 每个构造函数都有一个原型对象，原型对象包含一个指向构造函数的指针，而实例包含一个指向原型对象的内部指针。
***** 如果让原型对象等于另一个类型的实例，此时的原型对象将包含一个指向另一个原型的指针，相应的另一个原型中也包含着一个指向另一个构造函数的指针，假如另一个原型又是另一个类型的实例，那么上述关系依然成立，如此层层递进，就构成了实例与原型的链条，这就是原型链的基本原理。
**** 别忘记默认的原型(Object)
**** 确定原型和实例的关系
***** instanceof操作符 只要用这个操作符来测试实例与原型链中出现的构造函数，结果就会返回true
***** isPrototypeOf()方法 作用同上
**** 谨慎的定义方法
***** 子类型有时候需要重写超类型中的某个方法，或者需要添加超类型中不存在的某个方法。但无论如何，给原型添加方法的代码一定要放在替换原型的语句之后。
***** 通过原型链实现继承时，不能使用对象字面量创建原型方法，否则会重写原型链。
**** 原型链的问题
***** 最主要的问题来自包含引用类型值的原型，包含引用类型值的原型会被所有实例共享，而这也是为什么要在构造函数中，而不是在原型对象中定义属性的原因。在通过原型来实现继承时，原型实际上会变成另一个类型的实例
***** 原型链的第二个问题是，在创建子类型的实例时，不能向超类型的构造函数中传递参数，实际上是没有办法在不影响所有对象实例的情况下，给超类型的构造函数传递参数
***** 鉴于以上的问题，实践中很少会单独使用原型链。
*** 借用构造函数
**** 为了解决原型中包含引用类型值所带来的问题，出现了借用构造函数的技术，也叫伪造对象。这种技术的基本思想非常简单，即在子类型构造函数的内部调用超类型的构造函数。因为函数只不过是在特定环境中执行代码的对象，因此通过使用apply()和call()方法也可以在(将来)新创建的对象上执行构造函数。
**** 传递参数
相对于原型链而言，借用构造函数有很大的一个优势，可以在子类构造函数中向超类构造函数传递参数。
**** 借用构造函数的问题
方法都是在构造函数中定义的，无法进行函数复用，在超类原型中定义的方法，对于子类而言也是不可见的，结果所有类型都只能使用构造函数模式。因此借用构造函数很少单独使用。
*** 组合继承
**** 也叫经典继承，是将原型链和借用构造函数的技术组合到一起，从而发挥二者长处的技术。其思路是使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。这样即实现了在原型上定义方法的复用，又保证每个实例都有自己的属性。
**** 组合继承时JS中最常用的继承模式。
*** 原型式继承
*** 寄生式继承
*** 寄生组合式继承
开发人员普遍认为寄生组合式继承是引用类型最理想的继承范式。
** 对象常规操作
1、javascript中不存在类(class),是通过构造函数来替代
    . 构造函数
     function human (){
     }
    . 创建对象实例
     var zpbird = new human();
    . javascript内置了Object()构造函数，可以直接创建对象实例
     var aaa = new Object();
2、json方法(javascript object notation)，原生格式
     var bbb = {};
3、添加属性和方法
   . 创建构造函数的时候添加
        function human (){
           this.name="张鹏";
           this.run=function(){
               alert("跑步");
           }
     } 
      
   . 声明对象实例后添加
       function human (){
     }
     var zpbird = new human();
     zpbird.name="张鹏";
     zpbird.run=function(){
         alert("跑步");
     }
  
   . 使用json方法时
       声明时添加  var obj = {name:"张三",talk:function(){alert("说话");}
                      }
   
4、访问属性和方法
    . 属性 zpbird.name 或 zpbird["name"]
    . 方法 zpbird.run();

5、销毁对象实例  
    . javascript有自己的垃圾回收机制，当检测到没有引用该对象时会自动将其销毁
    . 手动销毁对象实例
      obj=null;
6、删除对象实例的属性和方法
    delete zpbird.name 属性
    delete zpbird.run  方法
7、对象属性和方法的遍历
   for (var i in zpbird){
       alert(zpbird[i]);
   }
8、prototype是函数的一个方法，可以实现创建多个对象实例时将共用的方法放到代码段中，节省内存，可以共享属性和方法函数，无法共享对象，但一个实例的修改会影响其他实例
9、对象的继承
   子类.prototype = new 父类();
* 事件
** 事件流
   事件流描述的是从页面中接受事件的顺序。注：IE的事件流是事件冒泡流，Netscape的事件流是事件捕获流。
*** 事件冒泡
**** 事件开始时由最具体的元素(文档中嵌套层次最深的那个节点)接收,然后逐级向上(父级)传播到顶层(window)
**** 阻止事件冒泡
***** 在当前要阻止冒泡的事件函数中调用 event.cancelBubble = true ;
*** 事件捕获
与事件冒泡的区别在于触发的顺序相反，首先触发最外层的元素的事件，然后向内(子级)传递
** 事件绑定函数的方式
*** 绑定一个指定函数
obj.onclick = function () {} 或 obj.onclick = fn ;
*** 绑定多个函数
**** ie: obj.attachEvent(事件名称,事件函数)
+ 一个事件可以多次attachEvent不同的函数，事件执行时会依次执行所有的事件函数
+ 在事件函数中的this不指向调用对象，而是指向window
+ 使用call()方法，call()的第一个参数可以改变函数执行过程中函数内部this的指向，如果第一个参数为null，
  则this将恢复原本的指向
**** 标准浏览器: obj.addEventListener(事件名称(名称中不使用on)，事件函数，是否捕获)
+ 一个事件可以多次attachEvent不同的函数，事件执行时会依次执行所有的事件函数
+ 是否捕获的默认值为false，false:冒泡 true：捕获
+ 通过使用obj.addEventListener()可以为冒泡和捕获指定不同的函数，即false绑定一次，true绑定一次
**** 兼容性处理，及解决this指向问题的函数封装
function bind (obj,evname,fn){
    if (obj.addEventListener){
        obj.addEventListener(evname,fn,false);
    }
    else {
        obj.attachEvent('on'+evname,function(){
            fn.call(obj);
        })
    }
}
** 取消事件绑定函数的方式
*** 赋值为null
obj.onclick = null;
*** 取消多个函数绑定
**** ie：obj.detachEvent(事件名称，事件函数)
**** 标准浏览器：obj.removeEventListener(事件名称，事件函数，是否捕获)
** Event对象(事件对象)
当某一事件发生时，event对象会临时保存当前对象发生的这个事件相关的详细信息
*** event对象必须在一个事件调用函数里面才能查看其内容
此时event对象的具体内容是根据调用事件的对象和具体事件变化的
document.onclick = function(){ alert(event); }
*** 兼容性问题
**** ie9以下
事件调用函数不需要使用参数
document.onclick = function(){ alert(event); }
**** 标准浏览器
事件调用函数需要指定第一个参数来调用event对象，这个参数的名称随意
document.onclick = function(ev){ alert(event); }
**** 兼容写法
function fn1 (ev) {
    var ev = ev || event;
    alert(ev);
}
*** 查看event对象中的详细信息
for (var attr in ev ) {
    console.log( attr + '=' + ev[] );
}
** 事件绑定
** 事件捕获
** 事件取消
** 键盘事件
** 事件默认行为
*** 阻止事件默认行为，在事件函数中使用return false；
+ 找准要修改的触发事件
+ document.onkeydown = function () { return false; }
*** 自定义右键菜单
document.oncontextmenu = function (){
    oDiv.style.display = 'block';
    .....
    return false;
}
document.onclick = function () {
    oDiv.style.display = 'none';
}

** 默认事件
** 常用事件
*** 焦点事件
用于区分用户输入的对象，不是所有元素都会获得焦点，能够响应用户操作的元素才能获得焦点，如<a>、<input>等
**** onfocus 当元素获得焦点时触发
**** onblur  当元素失去焦点时触发
**** obj.focus() 给指定的元素设置焦点
**** obj.blur()  取消指定元素的焦点
**** obj.select() 全选指定元素的文本内容，只能是用户交互输入的内容，无法操作<p>、<div>等标签的文本内容
* DOM 
DOM是针对HTML文档的一个API(应用程序编程接口)，它描述了一个层次化的节点树，允许开发人员添加、修改、删除页面的某一部分。
** 节点层次
DOM将HTML文档描述成一个由多层次节点组成的结构。节点分为几种不同的类型，每种类型分别表示文档中不同的信息或标记。每种节点都拥有各自的特点、数据、方法，另外也与其他类型的节点存在某种联系。节点之间的关系构成了层次，而所有页面标记则表现为一个以特定节点为根节点的树形结构。
*** Node的类型
**** 节点关系
**** 操作节点
**** 其他方法
*** Document类型
JS通过Document类型可以表示HTML或其他基于XML的文档，但最常见的应用还是作为HTMLDocument实例的document对象，通过这个对象不仅可以取得与页面相关的信息，还能操作页面的外观及其底层结构。document对象是window对象的一个属性，因此可以将其作为全局对象来访问。
**** 文档结构
+ document
  + html
    + head
    + body
      + div1
        + p
        + ul
          + li1
          + li2
          + li3
      + div2
**** 节点特征
***** nodeType的值为9；
***** nodeName的值为"#document";
***** nodeValue的值为null;
***** parentNode的值为null;
***** ownerDocument的值为null;
***** 其只有一个子节点，为下列类型之一：DocumentType、Element、ProcessingInstruction、Comment
**** 文档的子节点属性
 获取Document节点的子节点
- documentElement属性，该属性始终指向HTML页面中的<html>元素。
**** 文档信息
***** title属性
***** URL属性
***** domain属性
***** referrer属性
**** 查找(获取)元素
***** getElementByID()方法
***** getElementByTagName()方法
- 可以使用通配符 *
- 此方法返回一个包含零个或多个元素的HTMLCollection对象，可以使用索引[]或item()方法访问
**** 特殊集合
除了属性和方法，document对象还有一些特殊的集合，这些集合都是HTMLCollection对象，为访问文档常用的部分提供了快捷方式
**** DOM一致性检测
**** 文档写入
***** write()
***** writeIn()
***** open()
***** close()
*** Element类型
**** 节点特征
- nodeType 的值为1;
- nodeName 的值为元素的标签名;
- nodeValue 的值为null;
- parentNode 可能是Document或Element
- 其子节点可能是：Element、Text、Comment、ProcessingInstruction、CDATASection、EntityReference
**** 获取标签名
- nodeName属性和tagName属性
- 在HTML中标签名始终是用大写表示的，所以在进行比较时最好统一转换为小写或大写，防止出现错误
**** HTML元素
***** 所有HTML元素都由HTMLElement类型表示，即使不是直接通过这个类型，也是通过它的子类型来表示。
***** HTMLElement类型直接继承自Element类型并添加了一些特有属性
- id 元素在文档中的唯一标识符
- title 附加说明信息
- lang 元素内容的语言代码，很少使用
- dir 语言方向
- className 类名
**** 取得特性
- getAttribute() 方法 
- setAttribute() 方法
- removeAttribute() 方法
**** 设置特性
**** attributes属性
**** 创建元素 
createElement()方法
**** 元素的子节点
*** Text类型
**** 包含的是可以照字面解释的纯文本内容，纯文本中可以包含转义后的HTML字符，但不能包含HTML代码,包括回车换行符也被当做是文本内容
一般情况下，每个元素最多只有一个文本节点，而且必须保证存在实际内容，如果内容为空，则Text节点也不会被创建
**** 节点特征
- nodeType 值为3;
- nodeName 值为"#text";
- nodeValue 值为节点包含的文本;
- parentNode 是一个Element;
- 没有子节点
- length 保存节点中字符的数目
**** 操作文本
- appendData(text); 将text添加到文本末尾
- deleteData(offset,count); 删除指定位置的文本
- insertData(offset,text); 插入
- replaceData(offset,count,text); 替换
- splitText(offset); 分割
- substringData(offset,count); 提取
**** 创建文本节点
createTextNode()方法
**** 规范化文本节点
在一个包含多个文本节点的父元素上调用normalize()方法，则会将所有文本节点合并成一个节点。
**** 分割文本节点
splitText()方法
*** Comment类型
*** CDDATASection类型
*** DocumentType类型
*** DocumentFragment类型
虽然不能把文档片段直接添加到文档中，但可以作为“仓库”来使用，保存将来可能会添加到文档中的节点。
*** Attr类型
** 节点的属性和方法
*** 属性
**** nodeType属性
每个节点都拥有一个nodeType属性，只读,用于表明节点的类型。节点类型由在Node类型中定义的12个数值常量来表示的，任何节点类型必居其一
ELEMENT_NODE                     = 1
ATTRIBUTE_NODE                   = 2
TEXT_NODE                        = 3
CDATA_SECTION_NODE               = 4
ENTITY_REFERENCE_NODE            = 5
ENTITY_NODE                      = 6
PROCESSING_INSTRUCTION_NODE      = 7
COMMENT_NODE                     = 8
DOCUMENT_NODE                    = 9
DOCUMENT_TYPE_NODE               = 10
DOCUMENT_FRAGMENT_NODE           = 11
NOTATION_NODE                    = 12
**** nodeName属性
**** nodeValue属性
**** attributes[]属性
+ 只读,一般为ELEMENT节点的属性，例如div标签的id、class、style等
+ 获取节点的特定属性的名称
  oDiv.attributes[0].name  => 'style'
+ 获取节点的特定属性的值
  oDiv.attributes[0].value =>  'border: 1px solid red;'
**** childNodes[]属性 只读
其中包含元素节点和文本节点
**** children[] 属性 只读  工作中常用
只包含元素节点，其他方面与childNodes属性相同
**** firstChild属性 (lastChild属性)
只读，第一个子节点，其中包含元素节点和文本节点
由于兼容性的问题，通常使用children[0]来代替
**** firstElementChild属性 (lastElementChild属性)
只读，第一个元素子节点，其他方面与firstChild相同
由于兼容性的问题，通常使用children[0]来代替
**** nextSibling属性/nextElementSibling属性
只读，下一个兄弟节点
**** previousSibling属性/previousElementSibling属性
只读，上一个兄弟节点
**** parentNode属性
只读，父节点
**** offsetParent属性
只读，有定位的父节点(使用了position:relative样式的父节点)
如果每层父级节点都没有定位样式，则默认为body节点，在IE7以下，如果节点自身有定位样式的话，默认会变为HTML
**** offsetLeft、offsetTop 
只读，当前元素到定位父级的距离(偏移值)，即到当前元素的offsetParent的距离
**** offsetWidth
style.width 样式款
clientWidth 可视宽 = style.width + padding
offsetWidth 站位宽 = style.width + padding + border
**** 结合offsetLeft和offsetParent计算元素到页面的绝对位置
var iLeft = 0;
var obj = oDiv3;
while (obj){
    iLeft += obj.offsetLeft;
    obj = obj.offsetParent;
}
alert( iLeft );
**** 表格相关属性
***** tHead 表格头
***** tBodies[] 表格体
***** tFoot 表格尾
***** rows[] 行
***** cells[] 列
*** 方法
**** document.createElement() 创建的新节点，但没有添加到页面中(不显示)
var oLi = document.createElement('li');
oLi.innerHTML = 'hello world'; 
**** 父级.appendChild() 追加子节点
oUl.appendChild(oLi);
**** 父级.insertBefore() 插入子节点
insertBefore(新子节点,已有子节点);
oUL.insertBefore(oLi,oUl.children[0]);
**** 父级.removeChild()
**** 父级.replaceChild(新节点，被替换的节点)
** DOM操作技术
*** 动态脚本
动态脚本是指在页面加载时不存在，但将来的某一时刻通过修改DOM来动态加载的脚本。
*** 动态样式
*** 操作表格
*** 使用NodeList
** DOM扩展
** 选择符API(Selectors API) 
*** querySelector()方法
**** 
*** querySelectorAll()方法
*** matchesSelector()方法
** 元素遍历
** HTML5
*** HTML5新增了很多API，致力于简化CSS类的用法
**** getElementsByClassName()方法
**** classList属性
*** 焦点管理
activeElement属性
*** HTMLDocument的变化
**** readyState属性
**** 兼容模式
**** head属性
*** 字符集属性
- charset属性
- defaultCharset属性
*** 自定义数据属性
*** 插入标记
**** innerHTML属性
**** outerHTML属性
**** insertAdjacentHTML()方法
**** 内存与性能问题
*** scrollIntoView()方法
** DOM2和DOM3
** DOM1级主要定义的是HTML文档的底层结构。DOM2和DOM3级则在这个结构的基础上引入了更多的交互能力，也支持了更高级的XML特性。DOM2和DOM3分为许多模块(模块之间具有某种联系)，分别描述了DOM的某个非常具体的子集。
** DOM的变化
*** 针对XML命名空间的变化 但HTML不支持XML命名空间
*** DocumentType类型的变化
*** Document类型的变化
*** Node类型的变化
*** 框架的变化
** 样式
*** 访问元素的样式
**** DOM样式属性和方法
**** 计算的样式
*** 操作样式表
**** CSS规则
**** 创建规则
**** 删除规则
*** 元素大小
**** 偏移量
**** 客户区大小
**** 滚动大小
**** 确定元素大小
** 遍历
*** NodeIterator
*** TreeWalker
** 范围
*** createRange()方法
*** 用DOM范围实现复杂选择
*** 操作DOM范围中的内容
*** 插入DOM范围中的内容
*** 折叠DOM范围
*** 比较DOM范围
*** 复制DOM范围
* BOM
BOM提供了很多对象，用于访问浏览器的功能，这些功能与任何网页内容无关。
** window对象
*** BOM的核心对象是window，它表示浏览器的一个实例。在浏览器中，window对象具有双重角色，它既是通过JS访问浏览器窗口的一个接口，又是JS规定的Global对象。这意外着在网页中定义的任何一个对象、变量、函数，都是以window作为其Global对象，因此有权访问pareInt()等方法。
*** 全局作用域
***** 由于window对象在JS扮演Global对象的角色，因此所有在全局作用域中声明的变量、函数都会变成window对象的属性和方法。需要注意的一点是定义全局变量与在window对象上直接定义的属性还是有一点差别：全局变量不能使用delete操作符删除，而直接在window对象上定义的属性可以删除。
***** 尝试访问未声明的全局变量会报错，但通过查询window对象，可以知道某个可能未声明的变量是否存在。
*** 窗口关系及框架
如果窗口中包含框架(<frameset>标签)，则每个框架都拥有自己的window对象，保存在Frames集合中。
*** 窗口位置
*** 窗口大小
*** 导航和打开窗口
*** 间歇调用和超时调用
*** 系统对话框
** location对象
*** location是最有用的BOM对象之一，它提供了与当前窗口中加载的文档有关的信息，还提供了一下导航功能。location是一个特别的对象，它既是window对象的属性，又是document对象的属性。location对象不止保存着当前文档的信息，还将URL解析为独立的片段。
*** 查询字符串参数
*** 位置操作
** navigator对象
*** 检查插件
*** 注册处理程序
** screen对象
** history对象
* cookie
+ 不同浏览器存放cookie的位置不一样，而且不通用
+ cookie的存储以域名进行区分
+ cookie的数据可以设置名称
  document.cookie = 'username=leo'
  document.cookie = 'age=32'
+ cookie默认浏览器关闭时数据销毁，如果需要长期保存cookie数据，要指定时间
  documnet.cookie = 'local=tangshan;expires' + 字符串格式的时间oDate.toGMTString()
* JS预解析
+ 解析并执行html文档中<script></script>标签对的代码，完成后会同样处理下一个script标签对
  前面标签对中的语句无法调用后面标签对中定义的变量或函数，但反过来可以
+ 解析完成全局作用域的javascript代码后，逐条执行代码，遇到函数调用、对象等会创建局部作用域，解析其中代码后逐条执行
+ 对所有的关键字包括函数内部进行扫描解析var、function、参数 ，但此处的解析只是让系统知道存在这个变量或函数，
  但变量的赋值操作是要到执行赋值语句时才生效，之前变量存在但值为undefined
+ 解析时出现重名
  - 变量与函数重名：保留函数名
  - 变量与变量或函数与函数重名：保留后定义者
+ 当执行到函数调用语句时，会进行函数内部的预解析与代码执行即局部的作用域
* JS标签属性操作注意事项
1、JS中不允许出现"-"，所以在操作属性时，如果属性名称中包含"-"，例如font-size,则需要去除"-"，第二个单词首字母大写，fontSize
2、JS操作CSS中的"class"类选择器时，由于"class"时JS的保留字，需要改写为className
3、JS中所有的相对路径（图片）不可以用于比较判断(绝对路径可以)，颜色值、innerHtml也不能用于比较判断，但可以读写，可以使用一个开关变量来实现
4、JS中标签的属性名表述有两种方式"."和[]，例如div.style.width或div.style['width'],其中"."的方式无法修改，而[]的方式可以动态修改，在[]中可以使用字符串或变量
5、JS中所有的"."都可以替换成[]的表述方式，没有任何兼容性的问题，而且可以使用变量动态改变
6、JS的读操作无法返回相对路径的正常表示形式，但写操作可以，所以相对路径无法用于比较，但可以用于给变量赋值
* this 
指的是调用当前方法(函数)的那个对象
** 函数只要是通过()进行立即执行，则this一定指向window对象，不管该函数在何处执行
** this对象指向会有问题的情况(主要是IE兼容性问题)
行间、套一层、定时器、事件绑定函数中this的指向会有问题
*** abc.call(指定this对象,参数1,参数2) 
*** abc.apply(指定this对象，[参数1,参数2]) 其他与call()完全一样
*** 当对象中使用了定时器和事件时需要特别注意this的值
需要在外面定义_this变量保存真正想要指向的对象
在定时器和事件调用时通过匿名函数执行方法来解决
var _this = this
setInterval(function(){ _this.show() }, 1000 );
oBtn.onclick=function(){ _this.show(); }
* 闭包
* JSON管理命名空间
var miaov = {};
miaov.common = {
    getByClass: function (){},
    myAddEvent: function (){}
};
miaov.fx = {
    startMove: function (){},
    drag: function (){}
};
miaov.fx.drag();
* JS操作HTML小知识点
** innerHTML属性可以读写html文件中开始与结束标签之间的内容
** HTML的任何元素都可以添加自定义属性
+ 自定义属性一般是为便于js编程使用的，如状态开关、索引值、临时存储数据等
+ <div class="good" zpbird="zp"></div>
* Ajax
** 请求数据流程
+ 创建Ajax对象
  var xhr = new XMLHttpRequest();
  IE6以下使用new ActiveXObject('Micosoft.XMLHTTP')
  if (window.XMLHttpRequest){
     xhr = new XMLHttpRequest();
  } else {
    xhr = new ActiveXObject('Micosoft.XMLHTTP');
  }
  或者
  try {
      xhr = new XMLHttpRequest();
  } catch(e) {
      xhr = new ActiveXObject('Micosoft.XMLHTTP');
  }
+ 指定请求内容
  xhr.open('get','1.txt',true);
  - 打开方式
    get
    post (enctype)
  - 地址
  - 是否异步
+ 执行，发送请求
  xhr.send();
+ 等待服务器返回内容
  - responseText属性 存放服务器返回的内容
  - readyState属性 ajax的工作状态
  - status属性 服务器状态(http状态码)，用于容错处理
  xhr.onreadystatechange=function(){
      if( xhr.readyState==4 ){
          if (xhr.status==200){
              alert(xhr.responseText);
          }
      }
  }
** 获取数据后的处理
+ JSON对象
  - 提供两个方法来处理ajax的responseText属性中的纯文本数据
  - 如果时IE7以下的浏览器，需要引入json.org官网上的json2.js文件
  - JSON.stringify方法
    可以把一个对象转换成对应的字符串形式
  - JSON.parse方法
    可以把字符串转换成对应的对象
    需要注意，json格式的字符串名字部分必须加双引号，'{"name":leo,"age":18}'
** 缓存问题
+ get
  增加一个随机元素，从而避免缓存问题
  xhr.open('get','2.get.php?username=leo&age=18&'+new Date().getTime(),true);
+ post 方式没有缓存问题
** 中文乱码问题
+ get方式使用encodeURI处理中文乱码
  xhr.open('get','2.get.php?username='+encodeURI('刘伟')+'&age=18&'+new Date().getTime(),true);
+ post方式由于指定来url编码，不存在中文乱码问题
** post方式注意问题
+ 指定请求头,声明发送数据的编码类型
  xhr.setRequestHeader('content-type','application/x-www-form-urlencoded');
+ post方式的发送数据与get方式不同，是作为send()方法的参数进行发送的
  xhr.send('username=leo&age=18');
** 跨域
+ Jsonp
  - script标签
    <script src=""></script>
  - 在加载资源之前，即加载资源的script标签之前，定义好接收资源的函数
* 模块化
** 模块
*** JavaScript中模块是以文件的形式保存的，不同模块会保存在不同模块名.js文件中
*** 组成部分
**** 封装实现（功能的封装）
**** 暴露接口（与其他模块或代码联系、交互的部分）
**** 声明依赖（实现本模块的功能需要调用的其他模块的描述部分，主要是提供给模块系统用）
** 模块系统
*** 由于目前JavaScript本身语言级别不支持模块化技术，所以只能通过特定的模块系统来实现
*** 作用
**** 处理依赖管理
+ 加载
+ 分析
+ 注入
+ 初始化
**** 决定模块的写法
+ 不同的模块系统会有不同的模块编写规范，某个模块系统只能处理符合它本身编写规范的模块
*** 目前主要的模块系统
**** Commonjs/module(node.js使用的模块系统)
+ 主要用于非浏览器环境的模块系统，但通过特定方法也可以用于浏览器
+ 优点
  - 依赖管理成熟可靠
  - 社区活跃，规范接受程度高
  - 运行时支持，模块定义非常简单
  - 文件级别的模块作用域隔离
  - 可以处理循环依赖
+ 缺点
  - 不是标准组织规范
  - 同步的require，没有考虑浏览器环境，因为浏览器的加载是一个异步的过程
+ 浏览器使用
  - 需要通过打包工具将多个文件级别的模块打包成一个文件，浏览器引人这一个文件就可以正常使用
  - Browserify
  - webpack
  - component
**** AMD
+ 优点
  - 依赖管理成熟可靠
  - 社区活跃，规范接受程度高
  - 专为异步io环境打造，适合浏览器
  - 库级别支持，不要求特定js版本es3~es6都可以
  - 支持Commonjs的书写方式
  - 通过插件API可以支持加载非js资源
  - 成熟的打包构建工具，并可以结合插件，实现预处理的工作
+ 缺点
  - 模块定义繁琐，需要额外嵌套
  - 知识库级别支持，需要引人额外库
  - 无法处理循环依赖
  - 无法实现条件加载
**** ES6 module（未来、ES6规范未最后确定，浏览器不支持）
+ 优点
  - 语言级别的关键字支持
  - 适应所有js运行时，包括浏览器
  - 可以处理循环依赖
**** Systemjs 统一动态模块加载器（库）
+ 支持加载AMD、Commonjs、ES6
+ 支持加载Transpiler，可以支持任意资源
* 库与框架
** 库与框架的区别（都是解决方案）
+ 库（lib）
  - 针对特定问题的解答
  - 不控制应用程序的流程
  - 被动的被调用
+ 框架（Framework）
  - 控制反转（Inverse of control）与库最大的区别点
  - 决定应用程序的生命周期
  - 一般会集成大量的库
** 前端不同方面的解决方案
*** DOM
**** 包含内容
+ Selector 选择器
+ Manipulation 操作
+ Event(dom) 事件
+ Animation 动画
**** 方案的功能要求
+ 提供便利的DOM查询/操作/移动等操作
+ 提供事件绑定/事件代理等支持
+ 提供浏览器特性检测,UA检测
+ 提供节点属性、样式、类名等操作
+ 实现所有以上操作在目标平台的跨浏览器支持
**** 流行方案
+ JQuery 
+ zepto.js JQuery的轻量级实现
+ Hammer.js 手势
+ Velocity.js 高级动画
+ video.js 视频播放，类似于原生video标签的使用方式，对于低级浏览器可以回退到flash播放
*** Communication(通讯)
**** 职责范围
+ 处理与服务器的请求与响应
+ 预处理请求数据/响应数据 Error/Success的判断封装
+ 多种类型的请求，统一接口(XmlHttpRequest1/2,JSONP,iframe)
+ 处理浏览器兼容性
**** 包含内容
+ XmlHttpRequest
+ Form
+ JSONP
+ Socket
**** 流行方案
+ Reqwest
  - 优点：JSONP支持、稳定、支持IE6、CORS跨域、Promise/A支持
+ qwest
  - 优点：更小的代码量、XmlHttpRequest2、CORS跨域、支持高级数据类型ArrayBuffer、Blob和FormData
+ socket.io 
  - 实时性要求解决方案，例如聊天类的app
  - REAL-TIME
  - 支持二进制数据流
  - 智能自动的回退支持（非二进制数据流）
  - 多种后端语言支持
+ 其他：例如JQuery库就包含这部分功能
*** Utility(工具)
**** 包含内容
+ 函数增强
+ shim
+ Flow Control
**** 职责范围
+ 提供JS原生不提供的功能
+ 方法门面包装，使其更易于使用
+ 异步队列/流程控制等等
**** 流行方案
+ es5-shim
+ es6-shim
+ underscore
+ lodash
*** Templating(模板)
**** 模板技术类型
+ String-based
  - 初始化时间：    短
  - 动态更新：     不支持
  - dom无关：      支持
  - 语法：         简单
  - 学习成本：     低
  - SVG支持：      不支持
  - 安全性：       低
+ Dom-based
  - 初始化时间：   长
  - 动态更新：     支持
  - dom无关：      不支持
  - 语法：         较复杂
  - 学习成本：     较高
  - SVG支持：      支持
  - 安全性：       低
  - 局部更新运行时性能好
+ Living Template
  - 初始化时间：   较长
  - 动态更新：     支持
  - dom无关：      支持
  - 语法：         较复杂
  - 学习成本：     较高
  - SVG支持：      支持
  - 安全性：       高
**** 流行方案
+ String-based
  - dustjs
  - hogan
  - dot.js
+ Dom-based
  - Angulajs
  - Vuejs
  - Knockout
+ Living Template   
  - Regularjs
  - Ractivejs
  - htmlbar
*** Component(组件)
**** 包含内容
+ modal
+ Slider
+ DatePicker
+ Tabs
+ Editor
**** 职责范围
+ 提供基础组件CSS支持
+ 提供常用组件如Slider、modal
+ 提供声明式的调用方式(可选)
**** 流行方案  
+ Bootstrap
+ Foundation
*** Routing(路由)
**** 包含内容
+ Client Side
+ Server Side
**** 职责范围
+ 监听url变化，并通知注册的模块
+ 通过JavaScript进行主动跳转
+ 历史管理
+ 对目标浏览器的兼容性支持
**** 流行方案  
+ page.js
+ Director.js
+ Stateman
*** Architecture(架构/解耦/MVC/MVVM/MV*)
**** 职责范围
+ 提供一种范式帮助(强制)开发者进行模块解耦
+ 视图与模型分离
+ 更容易进行单元测试
+ 更容易实现应用程序的扩展
**** SPA
+ SPA(单页系统)一般情况下应用程序的逻辑比较复杂，需要使用Architecture(架构MV*)进行解耦
+ Routing是MV*系统的可定位状态的信息来源
+ SPA的普适法则：可定位的应用程序状态都应该统一由路由系统进入，以避免网状的信息流
**** 参考网站
+ http://todomvc.com
+ https://www.javascripting.com
* JS常用技巧和注意问题
** 判断条件不要使用的值
+ img的路径
+ 颜色值
** 获取元素的方法
+ #list{}    document.getElementById("list");      静态方法
              只会找到一个元素
+ li{}       document.getElementsByTagName("li");  动态方法
              会找到多个元素，返回的时一个类似于数组的元素集合，类似于数组，但不完全相同
** 获取样式
+ 元素.style.width 只能获取行间样式，其他地方的样式无效
+ getComputedStyle(元素).width; 可以获取样式表、行间样式、js动态指定样式中的值，获取到优先级最高的那个，IE9以下不支持,
  不要去获取之前未设置值的样式属性
+ 元素.currentStyle.width; 与getComputedStyle作用相同，但IE之外的浏览器不支持
+ 可以封装一个getStyle()来处理兼容性问题和方便的获取元素样式属性值
  function getStyle(obj,attr){return obj.currentStyle?obj.currentStyle[attr]:obj.getComputedStyle(obj)[attr];}
** 定时器
用于与时间有关的循环情况
*** setInterval(函数，毫秒);
+ 重复不断的执行，不会主动停止
+ 一般用法:var timer = null; timer = setInterval(函数,毫秒);
+ 注意问题：避免同一事件重复产生多个定时器，可以在事件开头先执行一个clearInterval(timer);清除可能存在的定时器
+ 定时器变量可以使用元素的自定义属性，便于管理，避免冲突
*** clearInterval(定时器变量);
*** setTimeout(函数,毫秒); 
+ 执行一次
*** clearTimeout(timer);
*** 往复循环控制技巧
var i=0,j=4;
if (i<j) {	i++; }else { i=0; }
等同于
i%=j;
** 自定义选择元素函数
+ function $ ( p ){
    if ( typeof p === 'function') {
		window.onload = p;
	}
    else if (typeof p === 'string'){
        return document.getElementById(p);
    }
  }
** 生产随机数字Math.random()
+ 默认情况下为0～1的随机小数
+ 0或1的开关数
  Math.round(Math.random())
+ x~y之间的随机数
  Math.round(Math.random()*(y-x) + x)
* 正则表达式
** 创建正则表达式
+ var re=new RegExp('a','i'); JS风格 
  这种方式可以使用变量
  var re=new RegExp('\\b'+sClass+'\\b', 'i');
+ var re=/a/i; perl风格 常用方式
** 常用参数
+ i (ignore) 忽略大小写
+ g (global) 全局匹配，查找出所有符合规则的字符串
+ 
** 语法规则
*** 标识符号
+ // 正则表达式包含在其中  var re=/a/i;
+ | (或) 分割多个匹配项  var re=/a|\d+/ig;
+ $ 行尾
*** 匹配规则
**** 字符类 []
***** 任意字符(或者)
其中每一个字符都作为一个匹配项，匹配结果是单个字符
+ [abc] 等价于 a|b|c
+ o[usb]t 等价于 out|ost|obt   obt、ost、out
***** 范围
匹配结果是单个字符
+ [a-z]所有英文
+ [0-9] 等价于\d 所有数字
+ [a-z0-9] 英文或者数字
+ id[0-9]    id0、id5
***** 排除
匹配结果是单个字符
+ [^a]
+ o[^0-9]    oat、o?t、o t
***** 以上规则的组合使用
+ o[^0-9]    oat、o?t、o t
**** 转义字符
+ . (点) 任意字符
+ \d (digital) 数字
+ \w (word) 等价于 [a-z0-9_] 英文字符或者数字或者下划线
+ \s (space) 空白 包含空格、制表符
+ \D 等价于 [^0-9] 数字以外的字符
+ \W 等价于 [^a-z0-9_]
+ \S 空白以外的字符
+ \b 单词边界
**** 量词
+ 基本形式
  - {n,m} 最少n次，最多m次
  - {n,} 最少n次，最多不限
  - {,m} 最少不限，最多m次
  - {n} 正好n次
+ + 等价于 {1,} 任意个数，个数不明确  \d+ 一个或多个数字组成的字符串
+ * 等价于 {0,} 不建议使用
+ ? 等价于 {0,1}
** 常用范例
**** 邮箱校验
var re=/^\w+@[a-z0-9]+\.[a-z]{2,4}$/;
**** 去掉首尾空格
var re=/^\s+|\s+$/g;
**** 匹配中文
var re=/[\u4e00-\u9fa5]/;
**** 完美选择class名
var re=new RegExp('\\b'+sClass+'\\b', 'i');
* ES6
** 
